<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>blaze::DenseSubmatrix&lt; MT, AF, SO &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="../../d8/d51/classblaze_1_1DenseSubmatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::DenseSubmatrix&lt; MT, AF, SO &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../d0/d48/group__views.html">Views</a> &raquo; <a class="el" href="../../da/ded/group__dense__submatrix.html">Dense Submatrix</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> on a specific submatrix of a dense matrix.The <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html" title="View on a specific submatrix of a dense matrix.The DenseSubmatrix template represents a view on a spe...">DenseSubmatrix</a> template represents a view on a specific submatrix of a dense matrix primitive. The type of the dense matrix is specified via the first template parameter:  
 <a href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d6/d3b/views_2DenseSubmatrix_8h_source.html">DenseSubmatrix.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">blaze::DenseMatrix&lt; DenseSubmatrix&lt; MT, AF, SO &gt;, SO &gt;</a>, and <a class="el" href="../../d2/d6e/structblaze_1_1Submatrix.html">blaze::Submatrix</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dc9/classblaze_1_1DenseSubmatrix_1_1SubmatrixIterator.html">SubmatrixIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the elements of the sparse submatrix.  <a href="../../dd/dc9/classblaze_1_1DenseSubmatrix_1_1SubmatrixIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ga6bdeda85a701745f673e5464e41253ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6bdeda85a701745f673e5464e41253ab"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>vectorizable</b> = MT::vectorizable
 }</td></tr>
<tr class="memdesc:ga6bdeda85a701745f673e5464e41253ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the expression template evaluation strategy. <br /></td></tr>
<tr class="separator:ga6bdeda85a701745f673e5464e41253ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fe169a23fcb258f3fd497eae990959f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5fe169a23fcb258f3fd497eae990959f"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>smpAssignable</b> = MT::smpAssignable
 }</td></tr>
<tr class="memdesc:ga5fe169a23fcb258f3fd497eae990959f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the expression template assignment strategy. <br /></td></tr>
<tr class="separator:ga5fe169a23fcb258f3fd497eae990959f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0362aea9aa385f871ee7695e1a1241c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0362aea9aa385f871ee7695e1a1241c5"></a>
typedef <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a0362aea9aa385f871ee7695e1a1241c5">This</a></td></tr>
<tr class="memdesc:a0362aea9aa385f871ee7695e1a1241c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html" title="View on a specific submatrix of a dense matrix.The DenseSubmatrix template represents a view on a spe...">DenseSubmatrix</a> instance. <br /></td></tr>
<tr class="separator:a0362aea9aa385f871ee7695e1a1241c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9fe46e2cbd2b2c3d694847ef46d075"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c9fe46e2cbd2b2c3d694847ef46d075"></a>
typedef <a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html">SubmatrixTrait</a>&lt; MT &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a2c9fe46e2cbd2b2c3d694847ef46d075">ResultType</a></td></tr>
<tr class="memdesc:a2c9fe46e2cbd2b2c3d694847ef46d075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br /></td></tr>
<tr class="separator:a2c9fe46e2cbd2b2c3d694847ef46d075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c431432db162a2bc1358e4b589e9e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5c431432db162a2bc1358e4b589e9e9"></a>
typedef <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html#a82dc102228fa4c8dd76f5c75d1f1cac3">ResultType::OppositeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#ac5c431432db162a2bc1358e4b589e9e9">OppositeType</a></td></tr>
<tr class="memdesc:ac5c431432db162a2bc1358e4b589e9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type with opposite storage order for expression template evaluations. <br /></td></tr>
<tr class="separator:ac5c431432db162a2bc1358e4b589e9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4028d49383573b49c1c912dd8c14bca0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4028d49383573b49c1c912dd8c14bca0"></a>
typedef <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html#a02b3d3c589c780c2abaa5275b79b88ba">ResultType::TransposeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a4028d49383573b49c1c912dd8c14bca0">TransposeType</a></td></tr>
<tr class="memdesc:a4028d49383573b49c1c912dd8c14bca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br /></td></tr>
<tr class="separator:a4028d49383573b49c1c912dd8c14bca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa287f4f75c6edefb3b3b8adb19482603"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa287f4f75c6edefb3b3b8adb19482603"></a>
typedef MT::ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aa287f4f75c6edefb3b3b8adb19482603">ElementType</a></td></tr>
<tr class="memdesc:aa287f4f75c6edefb3b3b8adb19482603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the submatrix elements. <br /></td></tr>
<tr class="separator:aa287f4f75c6edefb3b3b8adb19482603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78085952a8bd78c636fb3544d07662eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78085952a8bd78c636fb3544d07662eb"></a>
typedef IT::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a78085952a8bd78c636fb3544d07662eb">IntrinsicType</a></td></tr>
<tr class="memdesc:a78085952a8bd78c636fb3544d07662eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic type of the submatrix elements. <br /></td></tr>
<tr class="separator:a78085952a8bd78c636fb3544d07662eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38f01461480e75b5e7854fdc22ed37f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa38f01461480e75b5e7854fdc22ed37f"></a>
typedef MT::ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aa38f01461480e75b5e7854fdc22ed37f">ReturnType</a></td></tr>
<tr class="memdesc:aa38f01461480e75b5e7854fdc22ed37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br /></td></tr>
<tr class="separator:aa38f01461480e75b5e7854fdc22ed37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2e1bac547473f9ddac92970bdb8ab6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b2e1bac547473f9ddac92970bdb8ab6"></a>
typedef const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a0b2e1bac547473f9ddac92970bdb8ab6">CompositeType</a></td></tr>
<tr class="memdesc:a0b2e1bac547473f9ddac92970bdb8ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br /></td></tr>
<tr class="separator:a0b2e1bac547473f9ddac92970bdb8ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b855bc99d4e727c51a8a42d0c8c62c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9b855bc99d4e727c51a8a42d0c8c62c"></a>
typedef MT::ConstReference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#af9b855bc99d4e727c51a8a42d0c8c62c">ConstReference</a></td></tr>
<tr class="memdesc:af9b855bc99d4e727c51a8a42d0c8c62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant submatrix value. <br /></td></tr>
<tr class="separator:af9b855bc99d4e727c51a8a42d0c8c62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05eb84353184e26a21cbfce403c2789"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af05eb84353184e26a21cbfce403c2789"></a>
typedef <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; useConst, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#af9b855bc99d4e727c51a8a42d0c8c62c">ConstReference</a>, typename MT::Reference &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#af05eb84353184e26a21cbfce403c2789">Reference</a></td></tr>
<tr class="memdesc:af05eb84353184e26a21cbfce403c2789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant submatrix value. <br /></td></tr>
<tr class="separator:af05eb84353184e26a21cbfce403c2789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b771d83f08dd25f647901e12f67c57d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b771d83f08dd25f647901e12f67c57d"></a>
typedef const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aa287f4f75c6edefb3b3b8adb19482603">ElementType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a2b771d83f08dd25f647901e12f67c57d">ConstPointer</a></td></tr>
<tr class="memdesc:a2b771d83f08dd25f647901e12f67c57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a constant submatrix value. <br /></td></tr>
<tr class="separator:a2b771d83f08dd25f647901e12f67c57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4f92ddf7d63c1d1c98aed44e536fff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc4f92ddf7d63c1d1c98aed44e536fff"></a>
typedef <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; useConst, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a2b771d83f08dd25f647901e12f67c57d">ConstPointer</a>, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aa287f4f75c6edefb3b3b8adb19482603">ElementType</a> * &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#afc4f92ddf7d63c1d1c98aed44e536fff">Pointer</a></td></tr>
<tr class="memdesc:afc4f92ddf7d63c1d1c98aed44e536fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a non-constant submatrix value. <br /></td></tr>
<tr class="separator:afc4f92ddf7d63c1d1c98aed44e536fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcd1819a95a1ba6a31b8363f9f1e3ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bcd1819a95a1ba6a31b8363f9f1e3ba"></a>
typedef <a class="el" href="../../dd/dc9/classblaze_1_1DenseSubmatrix_1_1SubmatrixIterator.html">SubmatrixIterator</a>&lt; typename MT::ConstIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7bcd1819a95a1ba6a31b8363f9f1e3ba">ConstIterator</a></td></tr>
<tr class="memdesc:a7bcd1819a95a1ba6a31b8363f9f1e3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br /></td></tr>
<tr class="separator:a7bcd1819a95a1ba6a31b8363f9f1e3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02885bb11af5b3c83b186f23cd3b4b54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02885bb11af5b3c83b186f23cd3b4b54"></a>
typedef <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; useConst, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7bcd1819a95a1ba6a31b8363f9f1e3ba">ConstIterator</a>, <a class="el" href="../../dd/dc9/classblaze_1_1DenseSubmatrix_1_1SubmatrixIterator.html">SubmatrixIterator</a>&lt; typename MT::Iterator &gt; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a02885bb11af5b3c83b186f23cd3b4b54">Iterator</a></td></tr>
<tr class="memdesc:a02885bb11af5b3c83b186f23cd3b4b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br /></td></tr>
<tr class="separator:a02885bb11af5b3c83b186f23cd3b4b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8433a860ba90d8f77df196183ee2891d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8433a860ba90d8f77df196183ee2891d"></a>
typedef MT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a></td></tr>
<tr class="memdesc:a8433a860ba90d8f77df196183ee2891d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the matrix. <br /></td></tr>
<tr class="separator:a8433a860ba90d8f77df196183ee2891d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7abc3395ec6cdcdeee1fe1aa5c4b8e6b"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:a7abc3395ec6cdcdeee1fe1aa5c4b8e6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7abc3395ec6cdcdeee1fe1aa5c4b8e6b">operator=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7abc3395ec6cdcdeee1fe1aa5c4b8e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for different matrices.  <a href="#a7abc3395ec6cdcdeee1fe1aa5c4b8e6b">More...</a><br /></td></tr>
<tr class="separator:a7abc3395ec6cdcdeee1fe1aa5c4b8e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada657b8c629b3087f22cad981ca48447"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ada657b8c629b3087f22cad981ca48447"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt; MT &gt;, <a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">RequiresEvaluation</a>&lt; MT2 &gt; &gt;, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt; &amp; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#ada657b8c629b3087f22cad981ca48447">operator+=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ada657b8c629b3087f22cad981ca48447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator for the addition of a matrix ( <img class="formulaInl" alt="$ A+=B $" src="../../form_55.png"/>).  <a href="#ada657b8c629b3087f22cad981ca48447">More...</a><br /></td></tr>
<tr class="separator:ada657b8c629b3087f22cad981ca48447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09a533cbc83838255b52f1ee45c1fb8"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:aa09a533cbc83838255b52f1ee45c1fb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt; MT &gt;, <a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">RequiresEvaluation</a>&lt; MT2 &gt; &gt;, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt; &amp; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aa09a533cbc83838255b52f1ee45c1fb8">operator+=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa09a533cbc83838255b52f1ee45c1fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator for the addition of a matrix ( <img class="formulaInl" alt="$ A+=B $" src="../../form_55.png"/>).  <a href="#aa09a533cbc83838255b52f1ee45c1fb8">More...</a><br /></td></tr>
<tr class="separator:aa09a533cbc83838255b52f1ee45c1fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ed42770aa84d70b691cda67b3ae367"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:a11ed42770aa84d70b691cda67b3ae367"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt; MT &gt;, <a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">RequiresEvaluation</a>&lt; MT2 &gt; &gt;, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt; &amp; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a11ed42770aa84d70b691cda67b3ae367">operator-=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a11ed42770aa84d70b691cda67b3ae367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator for the subtraction of a matrix ( <img class="formulaInl" alt="$ A-=B $" src="../../form_56.png"/>).  <a href="#a11ed42770aa84d70b691cda67b3ae367">More...</a><br /></td></tr>
<tr class="separator:a11ed42770aa84d70b691cda67b3ae367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13771f3319d57620162ecc86d1036010"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:a13771f3319d57620162ecc86d1036010"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt; MT &gt;, <a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">RequiresEvaluation</a>&lt; MT2 &gt; &gt;, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt; &amp; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a13771f3319d57620162ecc86d1036010">operator-=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a13771f3319d57620162ecc86d1036010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator for the subtraction of a matrix ( <img class="formulaInl" alt="$ A-=B $" src="../../form_56.png"/>).  <a href="#a13771f3319d57620162ecc86d1036010">More...</a><br /></td></tr>
<tr class="separator:a13771f3319d57620162ecc86d1036010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd57b040b6230b01f7d6afaf6e107df0"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:afd57b040b6230b01f7d6afaf6e107df0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#afd57b040b6230b01f7d6afaf6e107df0">operator*=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:afd57b040b6230b01f7d6afaf6e107df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication of a matrix ( <img class="formulaInl" alt="$ A*=B $" src="../../form_57.png"/>).  <a href="#afd57b040b6230b01f7d6afaf6e107df0">More...</a><br /></td></tr>
<tr class="separator:afd57b040b6230b01f7d6afaf6e107df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3330f294b225bdb2320bbbc16d927ec9"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a3330f294b225bdb2320bbbc16d927ec9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a3330f294b225bdb2320bbbc16d927ec9">operator*=</a> (Other rhs)</td></tr>
<tr class="memdesc:a3330f294b225bdb2320bbbc16d927ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication between a dense submatrix and a scalar value ( <img class="formulaInl" alt="$ A*=s $" src="../../form_58.png"/>).  <a href="#a3330f294b225bdb2320bbbc16d927ec9">More...</a><br /></td></tr>
<tr class="separator:a3330f294b225bdb2320bbbc16d927ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc982a2d50e76192f7379fccfed2b1c1"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:afc982a2d50e76192f7379fccfed2b1c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#afc982a2d50e76192f7379fccfed2b1c1">operator/=</a> (Other rhs)</td></tr>
<tr class="memdesc:afc982a2d50e76192f7379fccfed2b1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator for the division of a dense submatrix by a scalar value ( <img class="formulaInl" alt="$ A/=s $" src="../../form_59.png"/>).  <a href="#afc982a2d50e76192f7379fccfed2b1c1">More...</a><br /></td></tr>
<tr class="separator:afc982a2d50e76192f7379fccfed2b1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d909d41414078d47f5af23a3b97adf3"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a3d909d41414078d47f5af23a3b97adf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a3d909d41414078d47f5af23a3b97adf3">scale</a> (const Other &amp;scalar)</td></tr>
<tr class="memdesc:a3d909d41414078d47f5af23a3b97adf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of the dense submatrix by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_63.png"/>).  <a href="#a3d909d41414078d47f5af23a3b97adf3">More...</a><br /></td></tr>
<tr class="separator:a3d909d41414078d47f5af23a3b97adf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fde62a2250d8700875cbee2b6684e7f"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:a6fde62a2250d8700875cbee2b6684e7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt; MT2 &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a6fde62a2250d8700875cbee2b6684e7f">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT3, SO3 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6fde62a2250d8700875cbee2b6684e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying matrix.  <a href="#a6fde62a2250d8700875cbee2b6684e7f">More...</a><br /></td></tr>
<tr class="separator:a6fde62a2250d8700875cbee2b6684e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d31e5b0b38dc251faa90e3da60ec5d"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:aa6d31e5b0b38dc251faa90e3da60ec5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aa6d31e5b0b38dc251faa90e3da60ec5d">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT3, SO3 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa6d31e5b0b38dc251faa90e3da60ec5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying symmetric matrix.  <a href="#aa6d31e5b0b38dc251faa90e3da60ec5d">More...</a><br /></td></tr>
<tr class="separator:aa6d31e5b0b38dc251faa90e3da60ec5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9873d9b8e29d6d957ae258760e79f071"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a9873d9b8e29d6d957ae258760e79f071"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a9873d9b8e29d6d957ae258760e79f071">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9873d9b8e29d6d957ae258760e79f071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying lower triangular matrix.  <a href="#a9873d9b8e29d6d957ae258760e79f071">More...</a><br /></td></tr>
<tr class="separator:a9873d9b8e29d6d957ae258760e79f071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa03c7f4c6a42ab00123580671e8752"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a4aa03c7f4c6a42ab00123580671e8752"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a4aa03c7f4c6a42ab00123580671e8752">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4aa03c7f4c6a42ab00123580671e8752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying lower triangular matrix.  <a href="#a4aa03c7f4c6a42ab00123580671e8752">More...</a><br /></td></tr>
<tr class="separator:a4aa03c7f4c6a42ab00123580671e8752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff18617715a27b536927216edef628e"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:adff18617715a27b536927216edef628e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#adff18617715a27b536927216edef628e">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:adff18617715a27b536927216edef628e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying lower triangular matrix.  <a href="#adff18617715a27b536927216edef628e">More...</a><br /></td></tr>
<tr class="separator:adff18617715a27b536927216edef628e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7886d208e749d34e42e1465c04056d"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a6b7886d208e749d34e42e1465c04056d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a6b7886d208e749d34e42e1465c04056d">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6b7886d208e749d34e42e1465c04056d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying lower triangular matrix.  <a href="#a6b7886d208e749d34e42e1465c04056d">More...</a><br /></td></tr>
<tr class="separator:a6b7886d208e749d34e42e1465c04056d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fff0c2c7c02808a72d3b4403626b4d"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a09fff0c2c7c02808a72d3b4403626b4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a09fff0c2c7c02808a72d3b4403626b4d">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a09fff0c2c7c02808a72d3b4403626b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying upper triangular matrix.  <a href="#a09fff0c2c7c02808a72d3b4403626b4d">More...</a><br /></td></tr>
<tr class="separator:a09fff0c2c7c02808a72d3b4403626b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb462c323407d7201b168c7bac9ec425"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:adb462c323407d7201b168c7bac9ec425"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#adb462c323407d7201b168c7bac9ec425">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:adb462c323407d7201b168c7bac9ec425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying upper triangular matrix.  <a href="#adb462c323407d7201b168c7bac9ec425">More...</a><br /></td></tr>
<tr class="separator:adb462c323407d7201b168c7bac9ec425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bc7587f5689e118ee2e1d3da1a3026"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:aa3bc7587f5689e118ee2e1d3da1a3026"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aa3bc7587f5689e118ee2e1d3da1a3026">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa3bc7587f5689e118ee2e1d3da1a3026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying upper triangular matrix.  <a href="#aa3bc7587f5689e118ee2e1d3da1a3026">More...</a><br /></td></tr>
<tr class="separator:aa3bc7587f5689e118ee2e1d3da1a3026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86044d8096a9ce2b8a7a667dfeb223f6"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a86044d8096a9ce2b8a7a667dfeb223f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a86044d8096a9ce2b8a7a667dfeb223f6">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a86044d8096a9ce2b8a7a667dfeb223f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying upper triangular matrix.  <a href="#a86044d8096a9ce2b8a7a667dfeb223f6">More...</a><br /></td></tr>
<tr class="separator:a86044d8096a9ce2b8a7a667dfeb223f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831ece53aa4a5aad038b215bc5d1af02"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a831ece53aa4a5aad038b215bc5d1af02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a831ece53aa4a5aad038b215bc5d1af02">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a831ece53aa4a5aad038b215bc5d1af02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying diagonal matrix.  <a href="#a831ece53aa4a5aad038b215bc5d1af02">More...</a><br /></td></tr>
<tr class="separator:a831ece53aa4a5aad038b215bc5d1af02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f15f4f6441361398424c74152793132"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a4f15f4f6441361398424c74152793132"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a4f15f4f6441361398424c74152793132">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4f15f4f6441361398424c74152793132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying diagonal matrix.  <a href="#a4f15f4f6441361398424c74152793132">More...</a><br /></td></tr>
<tr class="separator:a4f15f4f6441361398424c74152793132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91cdc3e779d89b9a9ea8c7fda8e5fd6"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:af91cdc3e779d89b9a9ea8c7fda8e5fd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#af91cdc3e779d89b9a9ea8c7fda8e5fd6">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af91cdc3e779d89b9a9ea8c7fda8e5fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying diagonal matrix.  <a href="#af91cdc3e779d89b9a9ea8c7fda8e5fd6">More...</a><br /></td></tr>
<tr class="separator:af91cdc3e779d89b9a9ea8c7fda8e5fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e7cf8a1547c20fccceb5422c3c9397"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a84e7cf8a1547c20fccceb5422c3c9397"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a84e7cf8a1547c20fccceb5422c3c9397">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a84e7cf8a1547c20fccceb5422c3c9397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying diagonal matrix.  <a href="#a84e7cf8a1547c20fccceb5422c3c9397">More...</a><br /></td></tr>
<tr class="separator:a84e7cf8a1547c20fccceb5422c3c9397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93facf0c69c4ee7b662e51fd6c888af"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:af93facf0c69c4ee7b662e51fd6c888af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; MT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#af93facf0c69c4ee7b662e51fd6c888af">assign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af93facf0c69c4ee7b662e51fd6c888af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a row-major dense matrix.  <a href="#af93facf0c69c4ee7b662e51fd6c888af">More...</a><br /></td></tr>
<tr class="separator:af93facf0c69c4ee7b662e51fd6c888af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f4045cf429a605ff988cb5d0047fd3"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:aa7f4045cf429a605ff988cb5d0047fd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; MT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aa7f4045cf429a605ff988cb5d0047fd3">assign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa7f4045cf429a605ff988cb5d0047fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the assignment of a row-major dense matrix.  <a href="#aa7f4045cf429a605ff988cb5d0047fd3">More...</a><br /></td></tr>
<tr class="separator:aa7f4045cf429a605ff988cb5d0047fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa695ce05840fed249c842fd5b334b45"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:aaa695ce05840fed249c842fd5b334b45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; MT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aaa695ce05840fed249c842fd5b334b45">addAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aaa695ce05840fed249c842fd5b334b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a row-major dense matrix.  <a href="#aaa695ce05840fed249c842fd5b334b45">More...</a><br /></td></tr>
<tr class="separator:aaa695ce05840fed249c842fd5b334b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c94862059e4f09249dabe4f34cc49b"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:a02c94862059e4f09249dabe4f34cc49b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; MT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a02c94862059e4f09249dabe4f34cc49b">addAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a02c94862059e4f09249dabe4f34cc49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the addition assignment of a row-major dense matrix.  <a href="#a02c94862059e4f09249dabe4f34cc49b">More...</a><br /></td></tr>
<tr class="separator:a02c94862059e4f09249dabe4f34cc49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca534b70ed859bbc2aa584d860c6073"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:aaca534b70ed859bbc2aa584d860c6073"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; MT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aaca534b70ed859bbc2aa584d860c6073">subAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aaca534b70ed859bbc2aa584d860c6073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a row-major dense matrix.  <a href="#aaca534b70ed859bbc2aa584d860c6073">More...</a><br /></td></tr>
<tr class="separator:aaca534b70ed859bbc2aa584d860c6073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d4a49b1bdea4aaccf84c01b2d636e1"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:a42d4a49b1bdea4aaccf84c01b2d636e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; MT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a42d4a49b1bdea4aaccf84c01b2d636e1">subAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a42d4a49b1bdea4aaccf84c01b2d636e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the subtraction assignment of a row-major dense matrix.  <a href="#a42d4a49b1bdea4aaccf84c01b2d636e1">More...</a><br /></td></tr>
<tr class="separator:a42d4a49b1bdea4aaccf84c01b2d636e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a540a2c4c893ac8d4842bbbfd19a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#af6a540a2c4c893ac8d4842bbbfd19a61">operator~</a> ()</td></tr>
<tr class="memdesc:af6a540a2c4c893ac8d4842bbbfd19a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for non-constant matrices.  <a href="#af6a540a2c4c893ac8d4842bbbfd19a61">More...</a><br /></td></tr>
<tr class="separator:af6a540a2c4c893ac8d4842bbbfd19a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71becdce9e44bcba62ee6458c6f5a6fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a71becdce9e44bcba62ee6458c6f5a6fb">operator~</a> () const </td></tr>
<tr class="memdesc:a71becdce9e44bcba62ee6458c6f5a6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for constant matrices.  <a href="#a71becdce9e44bcba62ee6458c6f5a6fb">More...</a><br /></td></tr>
<tr class="separator:a71becdce9e44bcba62ee6458c6f5a6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:aebe2ea2cde443c6529fa9ff3bd215502"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aebe2ea2cde443c6529fa9ff3bd215502">DenseSubmatrix</a> (<a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a215a0cd611cae8302027df2f48996354">Operand</a> matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:aebe2ea2cde443c6529fa9ff3bd215502"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor for <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html" title="View on a specific submatrix of a dense matrix.The DenseSubmatrix template represents a view on a spe...">DenseSubmatrix</a>.  <a href="#aebe2ea2cde443c6529fa9ff3bd215502">More...</a><br /></td></tr>
<tr class="separator:aebe2ea2cde443c6529fa9ff3bd215502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access functions</div></td></tr>
<tr class="memitem:a0f9d750bff8d2638cb61a865f8cf62b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#af05eb84353184e26a21cbfce403c2789">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a0f9d750bff8d2638cb61a865f8cf62b0">operator()</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="memdesc:a0f9d750bff8d2638cb61a865f8cf62b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D-access to the dense submatrix elements.  <a href="#a0f9d750bff8d2638cb61a865f8cf62b0">More...</a><br /></td></tr>
<tr class="separator:a0f9d750bff8d2638cb61a865f8cf62b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3007230f4e22e6cd8432112e097c5277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#af9b855bc99d4e727c51a8a42d0c8c62c">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a3007230f4e22e6cd8432112e097c5277">operator()</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const </td></tr>
<tr class="memdesc:a3007230f4e22e6cd8432112e097c5277"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D-access to the dense submatrix elements.  <a href="#a3007230f4e22e6cd8432112e097c5277">More...</a><br /></td></tr>
<tr class="separator:a3007230f4e22e6cd8432112e097c5277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b15b42ccb47b7fa05e0f3973223fcf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#afc4f92ddf7d63c1d1c98aed44e536fff">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a8b15b42ccb47b7fa05e0f3973223fcf2">data</a> ()</td></tr>
<tr class="memdesc:a8b15b42ccb47b7fa05e0f3973223fcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the submatrix elements.  <a href="#a8b15b42ccb47b7fa05e0f3973223fcf2">More...</a><br /></td></tr>
<tr class="separator:a8b15b42ccb47b7fa05e0f3973223fcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc2655320d207e9fc632889cab911c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a2b771d83f08dd25f647901e12f67c57d">ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a9bc2655320d207e9fc632889cab911c2">data</a> () const </td></tr>
<tr class="memdesc:a9bc2655320d207e9fc632889cab911c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the submatrix elements.  <a href="#a9bc2655320d207e9fc632889cab911c2">More...</a><br /></td></tr>
<tr class="separator:a9bc2655320d207e9fc632889cab911c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed903ff0b054eeb7f080423a6df2e8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a02885bb11af5b3c83b186f23cd3b4b54">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a2ed903ff0b054eeb7f080423a6df2e8e">begin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:a2ed903ff0b054eeb7f080423a6df2e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first non-zero element of row/column <em>i</em>.  <a href="#a2ed903ff0b054eeb7f080423a6df2e8e">More...</a><br /></td></tr>
<tr class="separator:a2ed903ff0b054eeb7f080423a6df2e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a61560e9b02237850bfc1c869d899de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7bcd1819a95a1ba6a31b8363f9f1e3ba">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a1a61560e9b02237850bfc1c869d899de">begin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:a1a61560e9b02237850bfc1c869d899de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first non-zero element of row/column <em>i</em>.  <a href="#a1a61560e9b02237850bfc1c869d899de">More...</a><br /></td></tr>
<tr class="separator:a1a61560e9b02237850bfc1c869d899de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad917a703cee392d99c99493d9b64877d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7bcd1819a95a1ba6a31b8363f9f1e3ba">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#ad917a703cee392d99c99493d9b64877d">cbegin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:ad917a703cee392d99c99493d9b64877d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first non-zero element of row/column <em>i</em>.  <a href="#ad917a703cee392d99c99493d9b64877d">More...</a><br /></td></tr>
<tr class="separator:ad917a703cee392d99c99493d9b64877d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efa4dbd43cc995c79d5784e30ba8677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a02885bb11af5b3c83b186f23cd3b4b54">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7efa4dbd43cc995c79d5784e30ba8677">end</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:a7efa4dbd43cc995c79d5784e30ba8677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last non-zero element of row/column <em>i</em>.  <a href="#a7efa4dbd43cc995c79d5784e30ba8677">More...</a><br /></td></tr>
<tr class="separator:a7efa4dbd43cc995c79d5784e30ba8677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687b4d272e968a5cf5791974086f3d93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7bcd1819a95a1ba6a31b8363f9f1e3ba">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a687b4d272e968a5cf5791974086f3d93">end</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:a687b4d272e968a5cf5791974086f3d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last non-zero element of row/column <em>i</em>.  <a href="#a687b4d272e968a5cf5791974086f3d93">More...</a><br /></td></tr>
<tr class="separator:a687b4d272e968a5cf5791974086f3d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4454cd9215ecb613efd19a8413a7ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7bcd1819a95a1ba6a31b8363f9f1e3ba">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a2b4454cd9215ecb613efd19a8413a7ce">cend</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:a2b4454cd9215ecb613efd19a8413a7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last non-zero element of row/column <em>i</em>.  <a href="#a2b4454cd9215ecb613efd19a8413a7ce">More...</a><br /></td></tr>
<tr class="separator:a2b4454cd9215ecb613efd19a8413a7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment operators</div></td></tr>
<tr class="memitem:af45ae3b7883d48e4942b3d9372e7b13a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#af45ae3b7883d48e4942b3d9372e7b13a">operator=</a> (const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aa287f4f75c6edefb3b3b8adb19482603">ElementType</a> &amp;rhs)</td></tr>
<tr class="memdesc:af45ae3b7883d48e4942b3d9372e7b13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Homogenous assignment to all submatrix elements.  <a href="#af45ae3b7883d48e4942b3d9372e7b13a">More...</a><br /></td></tr>
<tr class="separator:af45ae3b7883d48e4942b3d9372e7b13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a10a7c7ebfbd1bf89c87207145840d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a2a10a7c7ebfbd1bf89c87207145840d3">operator=</a> (const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a> &amp;rhs)</td></tr>
<tr class="memdesc:a2a10a7c7ebfbd1bf89c87207145840d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html" title="View on a specific submatrix of a dense matrix.The DenseSubmatrix template represents a view on a spe...">DenseSubmatrix</a>.  <a href="#a2a10a7c7ebfbd1bf89c87207145840d3">More...</a><br /></td></tr>
<tr class="separator:a2a10a7c7ebfbd1bf89c87207145840d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade220d277af6239c6f09c89e53098f7e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ade220d277af6239c6f09c89e53098f7e"></a>
template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ade220d277af6239c6f09c89e53098f7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:ade220d277af6239c6f09c89e53098f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c2b8acf0030278708fade3d025cdac"><td class="memTemplParams" colspan="2"><a class="anchor" id="af3c2b8acf0030278708fade3d025cdac"></a>
template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:af3c2b8acf0030278708fade3d025cdac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt; MT &gt;, <a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">RequiresEvaluation</a>&lt; MT2 &gt; &gt;, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a> &amp; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:af3c2b8acf0030278708fade3d025cdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9922e60e26b1b9ad60ee46822103009a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9922e60e26b1b9ad60ee46822103009a"></a>
template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:a9922e60e26b1b9ad60ee46822103009a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt; MT &gt;, <a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">RequiresEvaluation</a>&lt; MT2 &gt; &gt;, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a> &amp; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a9922e60e26b1b9ad60ee46822103009a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002deadce942b2e25e1363840ff9a13c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a002deadce942b2e25e1363840ff9a13c"></a>
template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:a002deadce942b2e25e1363840ff9a13c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt; MT &gt;, <a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">RequiresEvaluation</a>&lt; MT2 &gt; &gt;, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a> &amp; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a002deadce942b2e25e1363840ff9a13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e88045fa7610992233b8c265067d01d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7e88045fa7610992233b8c265067d01d"></a>
template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:a7e88045fa7610992233b8c265067d01d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt; MT &gt;, <a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">RequiresEvaluation</a>&lt; MT2 &gt; &gt;, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a> &amp; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a7e88045fa7610992233b8c265067d01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7f5e6c372064f4e62c869e4d6ce598"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6c7f5e6c372064f4e62c869e4d6ce598"></a>
template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:a6c7f5e6c372064f4e62c869e4d6ce598"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a6c7f5e6c372064f4e62c869e4d6ce598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ecbc23dc6618bcf7a67be9cd57fa86"><td class="memTemplParams" colspan="2"><a class="anchor" id="a24ecbc23dc6618bcf7a67be9cd57fa86"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a24ecbc23dc6618bcf7a67be9cd57fa86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (Other rhs)</td></tr>
<tr class="separator:a24ecbc23dc6618bcf7a67be9cd57fa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57a5b15707c329368475fc92571075a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae57a5b15707c329368475fc92571075a"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ae57a5b15707c329368475fc92571075a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (Other rhs)</td></tr>
<tr class="separator:ae57a5b15707c329368475fc92571075a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression template evaluation functions</div></td></tr>
<tr class="memitem:a29aaca43e6b9bec1585d65d6b2bdd48b"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a29aaca43e6b9bec1585d65d6b2bdd48b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a29aaca43e6b9bec1585d65d6b2bdd48b">canAlias</a> (const Other *alias) const </td></tr>
<tr class="memdesc:a29aaca43e6b9bec1585d65d6b2bdd48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the submatrix can alias with the given address <em>alias</em>.  <a href="#a29aaca43e6b9bec1585d65d6b2bdd48b">More...</a><br /></td></tr>
<tr class="separator:a29aaca43e6b9bec1585d65d6b2bdd48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e789e5e662f7133796db508ae2d22c"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool AF2, bool SO2&gt; </td></tr>
<tr class="memitem:a65e789e5e662f7133796db508ae2d22c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a65e789e5e662f7133796db508ae2d22c">canAlias</a> (const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT2, AF2, SO2 &gt; *alias) const </td></tr>
<tr class="memdesc:a65e789e5e662f7133796db508ae2d22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the submatrix can alias with the given dense submatrix <em>alias</em>.  <a href="#a65e789e5e662f7133796db508ae2d22c">More...</a><br /></td></tr>
<tr class="separator:a65e789e5e662f7133796db508ae2d22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03fddea4c74cc4ddd0f08a53ece3018"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:af03fddea4c74cc4ddd0f08a53ece3018"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#af03fddea4c74cc4ddd0f08a53ece3018">isAliased</a> (const Other *alias) const </td></tr>
<tr class="memdesc:af03fddea4c74cc4ddd0f08a53ece3018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the submatrix is aliased with the given address <em>alias</em>.  <a href="#af03fddea4c74cc4ddd0f08a53ece3018">More...</a><br /></td></tr>
<tr class="separator:af03fddea4c74cc4ddd0f08a53ece3018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed7e6efea20367881f6cca64e7c0310"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool AF2, bool SO2&gt; </td></tr>
<tr class="memitem:aaed7e6efea20367881f6cca64e7c0310"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aaed7e6efea20367881f6cca64e7c0310">isAliased</a> (const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT2, AF2, SO2 &gt; *alias) const </td></tr>
<tr class="memdesc:aaed7e6efea20367881f6cca64e7c0310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the submatrix is aliased with the given dense submatrix <em>alias</em>.  <a href="#aaed7e6efea20367881f6cca64e7c0310">More...</a><br /></td></tr>
<tr class="separator:aaed7e6efea20367881f6cca64e7c0310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b9a052a7b732636cb45bfee9086649"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#ae8b9a052a7b732636cb45bfee9086649">isAligned</a> () const </td></tr>
<tr class="memdesc:ae8b9a052a7b732636cb45bfee9086649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the submatrix is properly aligned in memory.  <a href="#ae8b9a052a7b732636cb45bfee9086649">More...</a><br /></td></tr>
<tr class="separator:ae8b9a052a7b732636cb45bfee9086649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace48b9d112e7067c9a780f0e7a87f073"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#ace48b9d112e7067c9a780f0e7a87f073">canSMPAssign</a> () const </td></tr>
<tr class="memdesc:ace48b9d112e7067c9a780f0e7a87f073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the submatrix can be used in SMP assignments.  <a href="#ace48b9d112e7067c9a780f0e7a87f073">More...</a><br /></td></tr>
<tr class="separator:ace48b9d112e7067c9a780f0e7a87f073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab571040cf99fdfac22de37495d542c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a78085952a8bd78c636fb3544d07662eb">IntrinsicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aab571040cf99fdfac22de37495d542c3">load</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const </td></tr>
<tr class="memdesc:aab571040cf99fdfac22de37495d542c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned load of an intrinsic element of the submatrix.  <a href="#aab571040cf99fdfac22de37495d542c3">More...</a><br /></td></tr>
<tr class="separator:aab571040cf99fdfac22de37495d542c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20e1a890410a1cd477095fd67b10039"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a78085952a8bd78c636fb3544d07662eb">IntrinsicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#ae20e1a890410a1cd477095fd67b10039">loadu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const </td></tr>
<tr class="memdesc:ae20e1a890410a1cd477095fd67b10039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned load of an intrinsic element of the submatrix.  <a href="#ae20e1a890410a1cd477095fd67b10039">More...</a><br /></td></tr>
<tr class="separator:ae20e1a890410a1cd477095fd67b10039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83fb3c81271a510addb03e8b578c313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#ab83fb3c81271a510addb03e8b578c313">store</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a78085952a8bd78c636fb3544d07662eb">IntrinsicType</a> &amp;value)</td></tr>
<tr class="memdesc:ab83fb3c81271a510addb03e8b578c313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of an intrinsic element of the submatrix.  <a href="#ab83fb3c81271a510addb03e8b578c313">More...</a><br /></td></tr>
<tr class="separator:ab83fb3c81271a510addb03e8b578c313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1329e5583d3d919181012652e921ac48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a1329e5583d3d919181012652e921ac48">storeu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a78085952a8bd78c636fb3544d07662eb">IntrinsicType</a> &amp;value)</td></tr>
<tr class="memdesc:a1329e5583d3d919181012652e921ac48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of an intrinsic element of the submatrix.  <a href="#a1329e5583d3d919181012652e921ac48">More...</a><br /></td></tr>
<tr class="separator:a1329e5583d3d919181012652e921ac48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5d33386e14749b29cbc8d876a03a18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#abc5d33386e14749b29cbc8d876a03a18">stream</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a78085952a8bd78c636fb3544d07662eb">IntrinsicType</a> &amp;value)</td></tr>
<tr class="memdesc:abc5d33386e14749b29cbc8d876a03a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of an intrinsic element of the submatrix.  <a href="#abc5d33386e14749b29cbc8d876a03a18">More...</a><br /></td></tr>
<tr class="separator:abc5d33386e14749b29cbc8d876a03a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c2bc84c3ec44abf2474c2de94f3e94"><td class="memTemplParams" colspan="2"><a class="anchor" id="a93c2bc84c3ec44abf2474c2de94f3e94"></a>
template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:a93c2bc84c3ec44abf2474c2de94f3e94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedAssign&lt; MT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:a93c2bc84c3ec44abf2474c2de94f3e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4208b1146bfe514674005aaccb628689"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4208b1146bfe514674005aaccb628689"></a>
template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:a4208b1146bfe514674005aaccb628689"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedAssign&lt; MT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:a4208b1146bfe514674005aaccb628689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e140085135a89ac96c21a866f76f5a0"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:a6e140085135a89ac96c21a866f76f5a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a6e140085135a89ac96c21a866f76f5a0">assign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6e140085135a89ac96c21a866f76f5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a column-major dense matrix.  <a href="#a6e140085135a89ac96c21a866f76f5a0">More...</a><br /></td></tr>
<tr class="separator:a6e140085135a89ac96c21a866f76f5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2c3b47bd5b98760861b633546e23c3"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:abf2c3b47bd5b98760861b633546e23c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#abf2c3b47bd5b98760861b633546e23c3">assign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:abf2c3b47bd5b98760861b633546e23c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a row-major sparse matrix.  <a href="#abf2c3b47bd5b98760861b633546e23c3">More...</a><br /></td></tr>
<tr class="separator:abf2c3b47bd5b98760861b633546e23c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9e6afd8af528aa84d4f32c36a5cc7a"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:aeb9e6afd8af528aa84d4f32c36a5cc7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aeb9e6afd8af528aa84d4f32c36a5cc7a">assign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aeb9e6afd8af528aa84d4f32c36a5cc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a column-major sparse matrix.  <a href="#aeb9e6afd8af528aa84d4f32c36a5cc7a">More...</a><br /></td></tr>
<tr class="separator:aeb9e6afd8af528aa84d4f32c36a5cc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea28b80d4e5271553bcb438737de5cdb"><td class="memTemplParams" colspan="2"><a class="anchor" id="aea28b80d4e5271553bcb438737de5cdb"></a>
template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:aea28b80d4e5271553bcb438737de5cdb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedAddAssign&lt; MT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:aea28b80d4e5271553bcb438737de5cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4af6d1a9251dd0374a122811bc23a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4f4af6d1a9251dd0374a122811bc23a4"></a>
template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:a4f4af6d1a9251dd0374a122811bc23a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedAddAssign&lt; MT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:a4f4af6d1a9251dd0374a122811bc23a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef16192a6d3aa801b00f27828f9d403"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:a7ef16192a6d3aa801b00f27828f9d403"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7ef16192a6d3aa801b00f27828f9d403">addAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7ef16192a6d3aa801b00f27828f9d403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a column-major dense matrix.  <a href="#a7ef16192a6d3aa801b00f27828f9d403">More...</a><br /></td></tr>
<tr class="separator:a7ef16192a6d3aa801b00f27828f9d403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba077221797455dec72b03af30bb5157"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:aba077221797455dec72b03af30bb5157"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aba077221797455dec72b03af30bb5157">addAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aba077221797455dec72b03af30bb5157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a row-major sparse matrix.  <a href="#aba077221797455dec72b03af30bb5157">More...</a><br /></td></tr>
<tr class="separator:aba077221797455dec72b03af30bb5157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d19d3662358662872aa76698f84d298"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:a4d19d3662358662872aa76698f84d298"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a4d19d3662358662872aa76698f84d298">addAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4d19d3662358662872aa76698f84d298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a column-major sparse matrix.  <a href="#a4d19d3662358662872aa76698f84d298">More...</a><br /></td></tr>
<tr class="separator:a4d19d3662358662872aa76698f84d298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c41bbda9c8cbd898fc2705ad91f0145"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0c41bbda9c8cbd898fc2705ad91f0145"></a>
template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:a0c41bbda9c8cbd898fc2705ad91f0145"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedSubAssign&lt; MT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:a0c41bbda9c8cbd898fc2705ad91f0145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb2f313f301f61b695e9b217eed271a"><td class="memTemplParams" colspan="2"><a class="anchor" id="aecb2f313f301f61b695e9b217eed271a"></a>
template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:aecb2f313f301f61b695e9b217eed271a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedSubAssign&lt; MT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:aecb2f313f301f61b695e9b217eed271a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ca712438380e9178a2e05bc2c23dcc"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:a42ca712438380e9178a2e05bc2c23dcc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a42ca712438380e9178a2e05bc2c23dcc">subAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a42ca712438380e9178a2e05bc2c23dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a column-major dense matrix.  <a href="#a42ca712438380e9178a2e05bc2c23dcc">More...</a><br /></td></tr>
<tr class="separator:a42ca712438380e9178a2e05bc2c23dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8790aa8a03f2772ecfba1c092cefa132"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:a8790aa8a03f2772ecfba1c092cefa132"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a8790aa8a03f2772ecfba1c092cefa132">subAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8790aa8a03f2772ecfba1c092cefa132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a row-major sparse matrix.  <a href="#a8790aa8a03f2772ecfba1c092cefa132">More...</a><br /></td></tr>
<tr class="separator:a8790aa8a03f2772ecfba1c092cefa132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3be47da5db7b5563b4e6a9893dcf7c"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:abb3be47da5db7b5563b4e6a9893dcf7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#abb3be47da5db7b5563b4e6a9893dcf7c">subAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:abb3be47da5db7b5563b4e6a9893dcf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a column-major sparse matrix.  <a href="#abb3be47da5db7b5563b4e6a9893dcf7c">More...</a><br /></td></tr>
<tr class="separator:abb3be47da5db7b5563b4e6a9893dcf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:gad12ba0df64c7d3bece20ca25e7e7ebee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>useConst</b> = IsConst&lt;MT&gt;::value
 }</td></tr>
<tr class="memdesc:gad12ba0df64c7d3bece20ca25e7e7ebee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the non-const reference and iterator types.  <a href="../../da/ded/group__dense__submatrix.html#gad12ba0df64c7d3bece20ca25e7e7ebee">More...</a><br /></td></tr>
<tr class="separator:gad12ba0df64c7d3bece20ca25e7e7ebee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215a0cd611cae8302027df2f48996354"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a215a0cd611cae8302027df2f48996354"></a>
typedef <a class="el" href="../../d7/d0c/structblaze_1_1If.html">If</a>&lt; <a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html">IsExpression</a>&lt; MT &gt;, MT, MT &amp; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a215a0cd611cae8302027df2f48996354">Operand</a></td></tr>
<tr class="memdesc:a215a0cd611cae8302027df2f48996354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite data type of the dense matrix expression. <br /></td></tr>
<tr class="separator:a215a0cd611cae8302027df2f48996354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1336ddfe891edbfdcedbd77e6377f259"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1336ddfe891edbfdcedbd77e6377f259"></a>
typedef <a class="el" href="../../d7/d73/classblaze_1_1IntrinsicTrait.html">IntrinsicTrait</a>&lt; typename MT::ElementType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a1336ddfe891edbfdcedbd77e6377f259">IT</a></td></tr>
<tr class="memdesc:a1336ddfe891edbfdcedbd77e6377f259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic trait for the matrix element type. <br /></td></tr>
<tr class="separator:a1336ddfe891edbfdcedbd77e6377f259"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:aed9c7a47ee2791aac94e27da957712a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed9c7a47ee2791aac94e27da957712a3"></a>
<a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a215a0cd611cae8302027df2f48996354">Operand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aed9c7a47ee2791aac94e27da957712a3">matrix_</a></td></tr>
<tr class="memdesc:aed9c7a47ee2791aac94e27da957712a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dense matrix containing the submatrix. <br /></td></tr>
<tr class="separator:aed9c7a47ee2791aac94e27da957712a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a1e36b58c494d4ae04f2fe4ef68bc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2a1e36b58c494d4ae04f2fe4ef68bc9"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#ad2a1e36b58c494d4ae04f2fe4ef68bc9">row_</a></td></tr>
<tr class="memdesc:ad2a1e36b58c494d4ae04f2fe4ef68bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first row of the submatrix. <br /></td></tr>
<tr class="separator:ad2a1e36b58c494d4ae04f2fe4ef68bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594e570e8fa117973eb61befd37cddbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a594e570e8fa117973eb61befd37cddbb"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a594e570e8fa117973eb61befd37cddbb">column_</a></td></tr>
<tr class="memdesc:a594e570e8fa117973eb61befd37cddbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first column of the submatrix. <br /></td></tr>
<tr class="separator:a594e570e8fa117973eb61befd37cddbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c27093508c65bb9e019ff880bf52a08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c27093508c65bb9e019ff880bf52a08"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a1c27093508c65bb9e019ff880bf52a08">m_</a></td></tr>
<tr class="memdesc:a1c27093508c65bb9e019ff880bf52a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of rows of the submatrix. <br /></td></tr>
<tr class="separator:a1c27093508c65bb9e019ff880bf52a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed43dbe8ddbff9423db84c40fd8bbeb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed43dbe8ddbff9423db84c40fd8bbeb4"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aed43dbe8ddbff9423db84c40fd8bbeb4">n_</a></td></tr>
<tr class="memdesc:aed43dbe8ddbff9423db84c40fd8bbeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of columns of the submatrix. <br /></td></tr>
<tr class="separator:aed43dbe8ddbff9423db84c40fd8bbeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2766f7087137974d7c80e3735609e737"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2766f7087137974d7c80e3735609e737"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a2766f7087137974d7c80e3735609e737">rest_</a></td></tr>
<tr class="memdesc:a2766f7087137974d7c80e3735609e737"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of remaining elements in an unaligned intrinsic operation. <br /></td></tr>
<tr class="separator:a2766f7087137974d7c80e3735609e737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25150993d90ceca2284e02f4f4c0eb5c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a25150993d90ceca2284e02f4f4c0eb5c">final_</a></td></tr>
<tr class="memdesc:a25150993d90ceca2284e02f4f4c0eb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The final index for unaligned intrinsic operations.  <a href="#a25150993d90ceca2284e02f4f4c0eb5c">More...</a><br /></td></tr>
<tr class="separator:a25150993d90ceca2284e02f4f4c0eb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a823f812e2d39352b4d769892d782e"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a13a823f812e2d39352b4d769892d782e">isAligned_</a></td></tr>
<tr class="memdesc:a13a823f812e2d39352b4d769892d782e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory alignment flag.  <a href="#a13a823f812e2d39352b4d769892d782e">More...</a><br /></td></tr>
<tr class="separator:a13a823f812e2d39352b4d769892d782e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Utility functions</h2></td></tr>
<tr class="memitem:a2d003bceb6d8452493d38f913544726d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a2d003bceb6d8452493d38f913544726d">rows</a> () const </td></tr>
<tr class="memdesc:a2d003bceb6d8452493d38f913544726d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows of the dense submatrix.  <a href="#a2d003bceb6d8452493d38f913544726d">More...</a><br /></td></tr>
<tr class="separator:a2d003bceb6d8452493d38f913544726d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cf9c340a9ff0e4c42dbb7f69e38df9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aa2cf9c340a9ff0e4c42dbb7f69e38df9">columns</a> () const </td></tr>
<tr class="memdesc:aa2cf9c340a9ff0e4c42dbb7f69e38df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns of the dense submatrix.  <a href="#aa2cf9c340a9ff0e4c42dbb7f69e38df9">More...</a><br /></td></tr>
<tr class="separator:aa2cf9c340a9ff0e4c42dbb7f69e38df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b047d8f4dd4954ed8d3d0b955f9aef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a78b047d8f4dd4954ed8d3d0b955f9aef">spacing</a> () const </td></tr>
<tr class="memdesc:a78b047d8f4dd4954ed8d3d0b955f9aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the spacing between the beginning of two rows/columns.  <a href="#a78b047d8f4dd4954ed8d3d0b955f9aef">More...</a><br /></td></tr>
<tr class="separator:a78b047d8f4dd4954ed8d3d0b955f9aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0f5e3e2e2a666b357bb27d9eea0e45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a6a0f5e3e2e2a666b357bb27d9eea0e45">capacity</a> () const </td></tr>
<tr class="memdesc:a6a0f5e3e2e2a666b357bb27d9eea0e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the dense submatrix.  <a href="#a6a0f5e3e2e2a666b357bb27d9eea0e45">More...</a><br /></td></tr>
<tr class="separator:a6a0f5e3e2e2a666b357bb27d9eea0e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32efb12dc7f846b3c80e6066d7ed164e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a32efb12dc7f846b3c80e6066d7ed164e">capacity</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:a32efb12dc7f846b3c80e6066d7ed164e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the specified row/column.  <a href="#a32efb12dc7f846b3c80e6066d7ed164e">More...</a><br /></td></tr>
<tr class="separator:a32efb12dc7f846b3c80e6066d7ed164e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7677188e12158044d0b4ace37c9295f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7677188e12158044d0b4ace37c9295f4">nonZeros</a> () const </td></tr>
<tr class="memdesc:a7677188e12158044d0b4ace37c9295f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the dense submatrix.  <a href="#a7677188e12158044d0b4ace37c9295f4">More...</a><br /></td></tr>
<tr class="separator:a7677188e12158044d0b4ace37c9295f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f4020cd0cdf048e8b4d5bdddd1b36e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a12f4020cd0cdf048e8b4d5bdddd1b36e">nonZeros</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:a12f4020cd0cdf048e8b4d5bdddd1b36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the specified row/column.  <a href="#a12f4020cd0cdf048e8b4d5bdddd1b36e">More...</a><br /></td></tr>
<tr class="separator:a12f4020cd0cdf048e8b4d5bdddd1b36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb69976f71a3a3f9bc8e30954490b8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a9cb69976f71a3a3f9bc8e30954490b8b">reset</a> ()</td></tr>
<tr class="memdesc:a9cb69976f71a3a3f9bc8e30954490b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to the default initial values.  <a href="#a9cb69976f71a3a3f9bc8e30954490b8b">More...</a><br /></td></tr>
<tr class="separator:a9cb69976f71a3a3f9bc8e30954490b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e7629dcb57ca64f1cb6b36400558f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a96e7629dcb57ca64f1cb6b36400558f3">reset</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:a96e7629dcb57ca64f1cb6b36400558f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column to the default initial values.  <a href="#a96e7629dcb57ca64f1cb6b36400558f3">More...</a><br /></td></tr>
<tr class="separator:a96e7629dcb57ca64f1cb6b36400558f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422dcf6d780ce03f4fcfb6136f1baed4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a422dcf6d780ce03f4fcfb6136f1baed4">transpose</a> ()</td></tr>
<tr class="memdesc:a422dcf6d780ce03f4fcfb6136f1baed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposing the submatrix.  <a href="#a422dcf6d780ce03f4fcfb6136f1baed4">More...</a><br /></td></tr>
<tr class="separator:a422dcf6d780ce03f4fcfb6136f1baed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8ddbe0937f98b7a76231c097569d02"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2e8ddbe0937f98b7a76231c097569d02"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a2e8ddbe0937f98b7a76231c097569d02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scale</b> (const Other &amp;scalar)</td></tr>
<tr class="separator:a2e8ddbe0937f98b7a76231c097569d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ff181be5f953d4a546d59edd7ecf00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a68ff181be5f953d4a546d59edd7ecf00">hasOverlap</a> () const </td></tr>
<tr class="memdesc:a68ff181be5f953d4a546d59edd7ecf00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking whether there exists an overlap in the context of a symmetric matrix.  <a href="#a68ff181be5f953d4a546d59edd7ecf00">More...</a><br /></td></tr>
<tr class="separator:a68ff181be5f953d4a546d59edd7ecf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fde62a2250d8700875cbee2b6684e7f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6fde62a2250d8700875cbee2b6684e7f"></a>
template&lt;typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:a6fde62a2250d8700875cbee2b6684e7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt; MT2 &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT3, SO3 &gt; &amp;rhs)</td></tr>
<tr class="separator:a6fde62a2250d8700875cbee2b6684e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d31e5b0b38dc251faa90e3da60ec5d"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa6d31e5b0b38dc251faa90e3da60ec5d"></a>
template&lt;typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:aa6d31e5b0b38dc251faa90e3da60ec5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT3, SO3 &gt; &amp;rhs)</td></tr>
<tr class="separator:aa6d31e5b0b38dc251faa90e3da60ec5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9873d9b8e29d6d957ae258760e79f071"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9873d9b8e29d6d957ae258760e79f071"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a9873d9b8e29d6d957ae258760e79f071"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a9873d9b8e29d6d957ae258760e79f071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa03c7f4c6a42ab00123580671e8752"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4aa03c7f4c6a42ab00123580671e8752"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a4aa03c7f4c6a42ab00123580671e8752"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a4aa03c7f4c6a42ab00123580671e8752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff18617715a27b536927216edef628e"><td class="memTemplParams" colspan="2"><a class="anchor" id="adff18617715a27b536927216edef628e"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:adff18617715a27b536927216edef628e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="separator:adff18617715a27b536927216edef628e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7886d208e749d34e42e1465c04056d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b7886d208e749d34e42e1465c04056d"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a6b7886d208e749d34e42e1465c04056d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a6b7886d208e749d34e42e1465c04056d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fff0c2c7c02808a72d3b4403626b4d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a09fff0c2c7c02808a72d3b4403626b4d"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a09fff0c2c7c02808a72d3b4403626b4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a09fff0c2c7c02808a72d3b4403626b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb462c323407d7201b168c7bac9ec425"><td class="memTemplParams" colspan="2"><a class="anchor" id="adb462c323407d7201b168c7bac9ec425"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:adb462c323407d7201b168c7bac9ec425"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="separator:adb462c323407d7201b168c7bac9ec425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bc7587f5689e118ee2e1d3da1a3026"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa3bc7587f5689e118ee2e1d3da1a3026"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:aa3bc7587f5689e118ee2e1d3da1a3026"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="separator:aa3bc7587f5689e118ee2e1d3da1a3026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86044d8096a9ce2b8a7a667dfeb223f6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a86044d8096a9ce2b8a7a667dfeb223f6"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a86044d8096a9ce2b8a7a667dfeb223f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a86044d8096a9ce2b8a7a667dfeb223f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831ece53aa4a5aad038b215bc5d1af02"><td class="memTemplParams" colspan="2"><a class="anchor" id="a831ece53aa4a5aad038b215bc5d1af02"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a831ece53aa4a5aad038b215bc5d1af02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a831ece53aa4a5aad038b215bc5d1af02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f15f4f6441361398424c74152793132"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4f15f4f6441361398424c74152793132"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a4f15f4f6441361398424c74152793132"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a4f15f4f6441361398424c74152793132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91cdc3e779d89b9a9ea8c7fda8e5fd6"><td class="memTemplParams" colspan="2"><a class="anchor" id="af91cdc3e779d89b9a9ea8c7fda8e5fd6"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:af91cdc3e779d89b9a9ea8c7fda8e5fd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="separator:af91cdc3e779d89b9a9ea8c7fda8e5fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e7cf8a1547c20fccceb5422c3c9397"><td class="memTemplParams" colspan="2"><a class="anchor" id="a84e7cf8a1547c20fccceb5422c3c9397"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a84e7cf8a1547c20fccceb5422c3c9397"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a84e7cf8a1547c20fccceb5422c3c9397"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt;<br />
class blaze::DenseSubmatrix&lt; MT, AF, SO &gt;</h3>

<p><a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> on a specific submatrix of a dense matrix.</p>
<p>The <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html" title="View on a specific submatrix of a dense matrix.The DenseSubmatrix template represents a view on a spe...">DenseSubmatrix</a> template represents a view on a specific submatrix of a dense matrix primitive. The type of the dense matrix is specified via the first template parameter: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MT, <span class="keywordtype">bool</span> AF, <span class="keywordtype">bool</span> SO &gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aebe2ea2cde443c6529fa9ff3bd215502">DenseSubmatrix</a>;</div>
</div><!-- fragment --><ul>
<li>MT: specifies the type of the dense matrix primitive. <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html" title="View on a specific submatrix of a dense matrix.The DenseSubmatrix template represents a view on a spe...">DenseSubmatrix</a> can be used with every dense matrix primitive, but does not work with any matrix expression type.</li>
<li>AF: the alignment flag specifies whether the submatrix is aligned (<em><a class="el" href="../../d2/de9/namespaceblaze.html#a30a412c45e10cff7eba4dacc999d55c7" title="Alignment flag for aligned subvectors and submatrices. ">blaze::aligned</a></em>) or unaligned (<em><a class="el" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5" title="Alignment flag for unaligned subvectors and submatrices. ">blaze::unaligned</a></em>). The default value is <em><a class="el" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5" title="Alignment flag for unaligned subvectors and submatrices. ">blaze::unaligned</a></em>.</li>
<li>SO: specifies the storage order (<a class="el" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices. ">blaze::rowMajor</a>, <a class="el" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583" title="Storage order flag for column-major matrices. ">blaze::columnMajor</a>) of the dense matrix. This template parameter doesn't have to be explicitly defined, but is automatically derived from the first template parameter.</li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="dense_submatrix_setup"></a>
Setup of Dense Submatrices</h1>
<p>A view on a dense submatrix can be created very conveniently via the <code><a class="el" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a" title="Creating a view on a specific submatrix of the given matrix. ">submatrix()</a></code> function:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a>  DenseMatrixType;</div>
<div class="line"></div>
<div class="line">DenseMatrixType A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a dense submatrix of size 8x16, starting in row 0 and column 4</span></div>
<div class="line"><a class="code" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix&lt;DenseMatrixType&gt;</a> sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 0UL, 4UL, 8UL, 16UL );</div>
</div><!-- fragment --><p>This view can be treated as any other dense matrix, i.e. it can be assigned to, it can be copied from, and it can be used in arithmetic operations. The view can also be used on both sides of an assignment: The submatrix can either be used as an alias to grant write access to a specific submatrix of a dense matrix primitive on the left-hand side of an assignment or to grant read-access to a specific submatrix of a dense matrix primitive or expression on the right-hand side of an assignment. The following example demonstrates this in detail:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a>  DenseMatrixType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::rowMajor&gt;</a>  SparseMatrixType;</div>
<div class="line"></div>
<div class="line">DenseMatrixType A, B;</div>
<div class="line">SparseMatrixType C;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a dense submatrix of size 8x4, starting in row 0 and column 2</span></div>
<div class="line"><a class="code" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix&lt;DenseMatrixType&gt;</a> sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 0UL, 2UL, 8UL, 4UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the submatrix of A to a 8x4 submatrix of B</span></div>
<div class="line">sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( B, 0UL, 0UL, 8UL, 4UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Copying the sparse matrix C into another 8x4 submatrix of A</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 8UL, 2UL, 8UL, 4UL ) = C;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Assigning part of the result of a matrix addition to the first submatrix</span></div>
<div class="line">sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( B + C, 0UL, 0UL, 8UL, 4UL );</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="dense_submatrix_element_access"></a>
Element access</h1>
<p>A dense submatrix can be used like any other dense matrix. For instance, the elements of the dense submatrix can be directly accessed with the function call operator:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a>  <a class="code" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>;</div>
<div class="line">MatrixType A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a 8x8 submatrix, starting from position (4,4)</span></div>
<div class="line"><a class="code" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix&lt;MatrixType&gt;</a> sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 4UL, 4UL, 8UL, 8UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the element (0,0) of the submatrix, which corresponds to</span></div>
<div class="line"><span class="comment">// the element at position (4,4) in matrix A</span></div>
<div class="line">sm(0,0) = 2.0;</div>
</div><!-- fragment --><p>Alternatively, the elements of a submatrix can be traversed via (const) iterators. Just as with matrices, in case of non-const submatrices, <code><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a2ed903ff0b054eeb7f080423a6df2e8e" title="Returns an iterator to the first non-zero element of row/column i. ">begin()</a></code> and <code><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7efa4dbd43cc995c79d5784e30ba8677" title="Returns an iterator just past the last non-zero element of row/column i. ">end()</a></code> return an Iterator, which allows a manipulation of the non-zero values, in case of constant submatrices a ConstIterator is returned:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a>  <a class="code" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix&lt;MatrixType&gt;</a>          SubmatrixType;</div>
<div class="line"></div>
<div class="line">MatrixType A( 256UL, 512UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a reference to a specific submatrix of matrix A</span></div>
<div class="line">SubmatrixType sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 16UL, 16UL, 64UL, 128UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Traversing the elements of the 0th row via iterators to non-const elements</span></div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">SubmatrixType::Iterator</a> it=sm.begin(0); it!=sm.end(0); ++it ) {</div>
<div class="line">   *it = ...;  <span class="comment">// OK: Write access to the dense submatrix value.</span></div>
<div class="line">   ... = *it;  <span class="comment">// OK: Read access to the dense submatrix value.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Traversing the elements of the 1st row via iterators to const elements</span></div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">SubmatrixType::ConstIterator</a> it=sm.begin(1); it!=sm.end(1); ++it ) {</div>
<div class="line">   *it = ...;  <span class="comment">// Compilation error: Assignment to the value via a ConstIterator is invalid.</span></div>
<div class="line">   ... = *it;  <span class="comment">// OK: Read access to the dense submatrix value.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="dense_submatrix_common_operations"></a>
Common Operations</h1>
<p>The current size of the matrix, i.e. the number of rows or columns can be obtained via the <code><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a2d003bceb6d8452493d38f913544726d" title="Returns the number of rows of the dense submatrix. ">rows()</a></code> and <code><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aa2cf9c340a9ff0e4c42dbb7f69e38df9" title="Returns the number of columns of the dense submatrix. ">columns()</a></code> functions, the current total capacity via the <code><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a6a0f5e3e2e2a666b357bb27d9eea0e45" title="Returns the maximum capacity of the dense submatrix. ">capacity()</a></code> function, and the number of non-zero elements via the <code><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7677188e12158044d0b4ace37c9295f4" title="Returns the number of non-zero elements in the dense submatrix. ">nonZeros()</a></code> function. However, since submatrices are views on a specific submatrix of a matrix, several operations are not possible on views, such as resizing and swapping:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a>  <a class="code" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix&lt;MatrixType&gt;</a>          SubmatrixType;</div>
<div class="line"></div>
<div class="line">MatrixType A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a view on the a 8x12 submatrix of matrix A</span></div>
<div class="line">SubmatrixType sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 0UL, 0UL, 8UL, 12UL );</div>
<div class="line"></div>
<div class="line">sm.rows();      <span class="comment">// Returns the number of rows of the submatrix</span></div>
<div class="line">sm.columns();   <span class="comment">// Returns the number of columns of the submatrix</span></div>
<div class="line">sm.capacity();  <span class="comment">// Returns the capacity of the submatrix</span></div>
<div class="line">sm.nonZeros();  <span class="comment">// Returns the number of non-zero elements contained in the submatrix</span></div>
<div class="line"></div>
<div class="line">sm.resize( 10UL, 8UL );  <span class="comment">// Compilation error: Cannot resize a submatrix of a matrix</span></div>
<div class="line"></div>
<div class="line">SubmatrixType sm2 = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 8UL, 0UL, 12UL, 8UL );</div>
<div class="line"><a class="code" href="../../d0/d90/group__diagonal__matrix.html#ga172895200063f120b6ffd241af12bbae">swap</a>( sm, sm2 );  <span class="comment">// Compilation error: Swap operation not allowed</span></div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="dense_submatrix_arithmetic_operations"></a>
Arithmetic Operations</h1>
<p>The following example gives an impression of the use of <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html" title="View on a specific submatrix of a dense matrix.The DenseSubmatrix template represents a view on a spe...">DenseSubmatrix</a> within arithmetic operations. All operations (addition, subtraction, multiplication, scaling, ...) can be performed on all possible combinations of dense and sparse matrices with fitting element types:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a>     DenseMatrixType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::rowMajor&gt;</a>  SparseMatrixType;</div>
<div class="line">DenseMatrixType D1, D2, D3;</div>
<div class="line">SparseMatrixType S1, S2;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::columnVector&gt;</a>  SparseVectorType;</div>
<div class="line">SparseVectorType a, b;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> DenseSubmatrix&lt;DenseMatrixType&gt;  SubmatrixType;</div>
<div class="line">SubmatrixType sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( D1, 0UL, 0UL, 8UL, 8UL );  <span class="comment">// View on the 8x8 submatrix of matrix D1</span></div>
<div class="line">                                                         <span class="comment">// starting from row 0 and column 0</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( D1, 0UL, 8UL, 8UL, 8UL ) = D2;  <span class="comment">// Dense matrix initialization of the 8x8 submatrix</span></div>
<div class="line">                                           <span class="comment">// starting in row 0 and column 8</span></div>
<div class="line">sm = S1;                                   <span class="comment">// Sparse matrix initialization of the second 8x8 submatrix</span></div>
<div class="line"></div>
<div class="line">D3 = sm + D2;                                    <span class="comment">// Dense matrix/dense matrix addition</span></div>
<div class="line">S2 = S1  - <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( D1, 8UL, 0UL, 8UL, 8UL );  <span class="comment">// Sparse matrix/dense matrix subtraction</span></div>
<div class="line">D2 = sm * <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( D1, 8UL, 8UL, 8UL, 8UL );   <span class="comment">// Dense matrix/dense matrix multiplication</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( D1, 8UL, 0UL, 8UL, 8UL ) *= 2.0;      <span class="comment">// In-place scaling of a submatrix of D1</span></div>
<div class="line">D2 = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( D1, 8UL, 8UL, 8UL, 8UL ) * 2.0;  <span class="comment">// Scaling of the a submatrix of D1</span></div>
<div class="line">D2 = 2.0 * sm;                                   <span class="comment">// Scaling of the a submatrix of D1</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( D1, 0UL, 8UL, 8UL, 8UL ) += D2;  <span class="comment">// Addition assignment</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( D1, 8UL, 0UL, 8UL, 8UL ) -= S1;  <span class="comment">// Subtraction assignment</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( D1, 8UL, 8UL, 8UL, 8UL ) *= sm;  <span class="comment">// Multiplication assignment</span></div>
<div class="line"></div>
<div class="line">a = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( D1, 4UL, 4UL, 8UL, 8UL ) * b;  <span class="comment">// Dense matrix/sparse vector multiplication</span></div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="dense_submatrix_aligned_submatrix"></a>
Aligned Submatrices</h1>
<p>Usually submatrices can be defined anywhere within a matrix. They may start at any position and may have an arbitrary extension (only restricted by the extension of the underlying matrix). However, in contrast to matrices themselves, which are always properly aligned in memory and therefore can provide maximum performance, this means that submatrices in general have to be considered to be unaligned. This can be made explicit by the <em><a class="el" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5" title="Alignment flag for unaligned subvectors and submatrices. ">blaze::unaligned</a></em> flag:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5">blaze::unaligned</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a>  DenseMatrixType;</div>
<div class="line"></div>
<div class="line">DenseMatrixType A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Identical creations of an unaligned submatrix of size 8x8, starting in row 0 and column 0</span></div>
<div class="line"><a class="code" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix&lt;DenseMatrixType&gt;</a>           sm1 = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>           ( A, 0UL, 0UL, 8UL, 8UL );</div>
<div class="line"><a class="code" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix&lt;DenseMatrixType&gt;</a>           sm2 = submatrix&lt;unaligned&gt;( A, 0UL, 0UL, 8UL, 8UL );</div>
<div class="line"><a class="code" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix&lt;DenseMatrixType,unaligned&gt;</a> sm3 = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>           ( A, 0UL, 0UL, 8UL, 8UL );</div>
<div class="line"><a class="code" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix&lt;DenseMatrixType,unaligned&gt;</a> sm4 = submatrix&lt;unaligned&gt;( A, 0UL, 0UL, 8UL, 8UL );</div>
</div><!-- fragment --><p>All of these calls to the <code><a class="el" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a" title="Creating a view on a specific submatrix of the given matrix. ">submatrix()</a></code> function are identical. Whether the alignment flag is explicitly specified or not, it always returns an unaligned submatrix. Whereas this may provide full flexibility in the creation of submatrices, this might result in performance restrictions (even in case the specified submatrix could be aligned). However, it is also possible to create aligned submatrices. Aligned submatrices are identical to unaligned submatrices in all aspects, except that they may pose additional alignment restrictions and therefore have less flexibility during creation, but don't suffer from performance penalties and provide the same performance as the underlying matrix. Aligned submatrices are created by explicitly specifying the <em><a class="el" href="../../d2/de9/namespaceblaze.html#a30a412c45e10cff7eba4dacc999d55c7" title="Alignment flag for aligned subvectors and submatrices. ">blaze::aligned</a></em> flag:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a30a412c45e10cff7eba4dacc999d55c7">blaze::aligned</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating an aligned submatrix of size 8x8, starting in row 0 and column 0</span></div>
<div class="line"><a class="code" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix&lt;DenseMatrixType,aligned&gt;</a> sv = submatrix&lt;aligned&gt;( A, 0UL, 0UL, 8UL, 8UL );</div>
</div><!-- fragment --><p>The alignment restrictions refer to system dependent address restrictions for the used element type and the available vectorization mode (SSE, AVX, ...). The following source code gives some examples for a double precision dense matrix, assuming that AVX is available, which packs 4 <code>double</code> values into an intrinsic vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a>      <a class="code" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix&lt;MatrixType,aligned&gt;</a>  SubmatrixType;</div>
<div class="line"></div>
<div class="line">MatrixType D( 13UL, 17UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// OK: Starts at position (0,0) and the number of rows and columns are a multiple of 4</span></div>
<div class="line">SubmatrixType dsm1 = submatrix&lt;aligned&gt;( D, 0UL, 0UL, 8UL, 12UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// OK: First row and column and the number of rows and columns are all a multiple of 4</span></div>
<div class="line">SubmatrixType dsm2 = submatrix&lt;aligned&gt;( D, 4UL, 12UL, 8UL, 16UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// OK: First row and column are a multiple of 4 and the submatrix includes the last row and column</span></div>
<div class="line">SubmatrixType dsm3 = submatrix&lt;aligned&gt;( D, 4UL, 0UL, 9UL, 17UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Error: First row is not a multiple of 4</span></div>
<div class="line">SubmatrixType dsm4 = submatrix&lt;aligned&gt;( D, 2UL, 4UL, 12UL, 12UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Error: First column is not a multiple of 4</span></div>
<div class="line">SubmatrixType dsm5 = submatrix&lt;aligned&gt;( D, 0UL, 2UL, 8UL, 8UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Error: The number of rows is not a multiple of 4 and the submatrix does not include the last row</span></div>
<div class="line">SubmatrixType dsm6 = submatrix&lt;aligned&gt;( D, 0UL, 0UL, 7UL, 8UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Error: The number of columns is not a multiple of 4 and the submatrix does not include the last column</span></div>
<div class="line">SubmatrixType dsm6 = submatrix&lt;aligned&gt;( D, 0UL, 0UL, 8UL, 11UL );</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="dense_submatrix_on_dense_submatrix"></a>
Submatrix on Submatrix</h1>
<p>It is also possible to create a submatrix view on another submatrix. In this context it is important to remember that the type returned by the <code><a class="el" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a" title="Creating a view on a specific submatrix of the given matrix. ">submatrix()</a></code> function is the same type as the type of the given submatrix, since the view on a submatrix is just another view on the underlying dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a>  <a class="code" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix&lt;MatrixType&gt;</a>             SubmatrixType;</div>
<div class="line"></div>
<div class="line">MatrixType D1;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a submatrix view on the dense matrix D1</span></div>
<div class="line">SubmatrixType sm1 = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( D1, 4UL, 4UL, 8UL, 16UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a submatrix view on the dense submatrix sm1</span></div>
<div class="line">SubmatrixType sm2 = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( sm1, 1UL, 1UL, 4UL, 8UL );</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="dense_submatrix_on_symmetric_matrices"></a>
Submatrix on Symmetric Matrices</h1>
<p>Submatrices can also be created on symmetric matrices (see the <a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html" title="Matrix adapter for symmetric  matrices. ">SymmetricMatrix</a> class template):</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">blaze::SymmetricMatrix</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> SymmetricMatrix&lt; DynamicMatrix&lt;int&gt; &gt;   SymmetricDynamicType;</div>
<div class="line"><span class="keyword">typedef</span> DenseSubmatrix&lt; SymmetricDynamicType &gt;  SubmatrixType;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setup of a 16x16 symmetric matrix</span></div>
<div class="line">SymmetricDynamicType A( 16UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a dense submatrix of size 8x12, starting in row 2 and column 4</span></div>
<div class="line">SubmatrixType sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 2UL, 4UL, 8UL, 12UL );</div>
</div><!-- fragment --><p>It is important to note, however, that (compound) assignments to such submatrices have a special restriction: The symmetry of the underlying symmetric matrix must not be broken! Since the modification of element <img class="formulaInl" alt="$ a_{ij} $" src="../../form_11.png"/> of a symmetric matrix also modifies the element <img class="formulaInl" alt="$ a_{ji} $" src="../../form_12.png"/>, the matrix to be assigned must be structured such that the symmetry of the symmetric matrix is preserved. Otherwise a <em>std::invalid_argument</em> exception is thrown:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">blaze::SymmetricMatrix</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setup of two default 4x4 symmetric matrices</span></div>
<div class="line">SymmetricMatrix&lt; DynamicMatrix&lt;int&gt; &gt; A1( 4 ), A2( 4 );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setup of the 3x2 dynamic matrix</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//       ( 0 9 )</span></div>
<div class="line"><span class="comment">//   B = ( 9 8 )</span></div>
<div class="line"><span class="comment">//       ( 0 7 )</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">DynamicMatrix&lt;int&gt; B( 3UL, 2UL );</div>
<div class="line">B(0,0) = 1;</div>
<div class="line">B(0,1) = 2;</div>
<div class="line">B(1,0) = 3;</div>
<div class="line">B(1,1) = 4;</div>
<div class="line">B(2,1) = 5;</div>
<div class="line">B(2,2) = 6;</div>
<div class="line"></div>
<div class="line"><span class="comment">// OK: Assigning B to a submatrix of A1 such that the symmetry can be preserved</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//        ( 0 0 1 2 )</span></div>
<div class="line"><span class="comment">//   A1 = ( 0 0 3 4 )</span></div>
<div class="line"><span class="comment">//        ( 1 3 5 6 )</span></div>
<div class="line"><span class="comment">//        ( 2 4 6 0 )</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A1, 0UL, 2UL, 3UL, 2UL ) = B;  <span class="comment">// OK</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Error: Assigning B to a submatrix of A2 such that the symmetry cannot be preserved!</span></div>
<div class="line"><span class="comment">//   The elements marked with X cannot be assigned unambiguously!</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//        ( 0 1 2 0 )</span></div>
<div class="line"><span class="comment">//   A2 = ( 1 3 X 0 )</span></div>
<div class="line"><span class="comment">//        ( 2 X 6 0 )</span></div>
<div class="line"><span class="comment">//        ( 0 0 0 0 )</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A2, 0UL, 1UL, 3UL, 2UL ) = B;  <span class="comment">// Assignment throws an exception!</span></div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aebe2ea2cde443c6529fa9ff3bd215502"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a215a0cd611cae8302027df2f48996354">Operand</a>&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constructor for <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html" title="View on a specific submatrix of a dense matrix.The DenseSubmatrix template represents a view on a spe...">DenseSubmatrix</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The dense matrix containing the submatrix. </td></tr>
    <tr><td class="paramname">row</td><td>The index of the first row of the submatrix in the given dense matrix. </td></tr>
    <tr><td class="paramname">column</td><td>The index of the first column of the submatrix in the given dense matrix. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows of the submatrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns of the submatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid submatrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the submatrix is not properly specified (i.e. if the specified submatrix is not contained in the given dense matrix) a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7ef16192a6d3aa801b00f27828f9d403"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a column-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="aba077221797455dec72b03af30bb5157"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a4d19d3662358662872aa76698f84d298"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="aaa695ce05840fed249c842fd5b334b45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt;MT,AF,SO&gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt;MT2&gt; &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a02c94862059e4f09249dabe4f34cc49b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt;MT,AF,SO&gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt;MT2&gt; &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the addition assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a6e140085135a89ac96c21a866f76f5a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a column-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="abf2c3b47bd5b98760861b633546e23c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="aeb9e6afd8af528aa84d4f32c36a5cc7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="af93facf0c69c4ee7b662e51fd6c888af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt;MT,AF,SO&gt;::BLAZE_TEMPLATE VectorizedAssign&lt;MT2&gt; &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="aa7f4045cf429a605ff988cb5d0047fd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt;MT,AF,SO&gt;::BLAZE_TEMPLATE VectorizedAssign&lt;MT2&gt; &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a2ed903ff0b054eeb7f080423a6df2e8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a02885bb11af5b3c83b186f23cd3b4b54">Iterator</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first non-zero element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first non-zero element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first non-zero element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a1a61560e9b02237850bfc1c869d899de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7bcd1819a95a1ba6a31b8363f9f1e3ba">ConstIterator</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first non-zero element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first non-zero element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first non-zero element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a29aaca43e6b9bec1585d65d6b2bdd48b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::canAlias </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the submatrix can alias with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this submatrix, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address can alias with the submatrix. In contrast to the <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#af03fddea4c74cc4ddd0f08a53ece3018" title="Returns whether the submatrix is aliased with the given address alias. ">isAliased()</a> function this function is allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="a65e789e5e662f7133796db508ae2d22c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool AF2, bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::canAlias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT2, AF2, SO2 &gt; *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the submatrix can alias with the given dense submatrix <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this submatrix, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address can alias with the submatrix. In contrast to the <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#af03fddea4c74cc4ddd0f08a53ece3018" title="Returns whether the submatrix is aliased with the given address alias. ">isAliased()</a> function this function is allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="ace48b9d112e7067c9a780f0e7a87f073"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::canSMPAssign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the submatrix can be used in SMP assignments. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the submatrix can be used in SMP assignments, <em>false</em> if not.</dd></dl>
<p>This function returns whether the submatrix can be used in SMP assignments. In contrast to the <em>smpAssignable</em> member enumeration, which is based solely on compile time information, this function additionally provides runtime information (as for instance the current number of rows and/or columns of the submatrix). </p>

</div>
</div>
<a class="anchor" id="a6a0f5e3e2e2a666b357bb27d9eea0e45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the dense submatrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the dense submatrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a32efb12dc7f846b3c80e6066d7ed164e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current capacity of the specified row/column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current capacity of row/column <em>i</em>.</dd></dl>
<p>This function returns the current capacity of the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the capacity of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the capacity of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="ad917a703cee392d99c99493d9b64877d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7bcd1819a95a1ba6a31b8363f9f1e3ba">ConstIterator</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first non-zero element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first non-zero element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first non-zero element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a2b4454cd9215ecb613efd19a8413a7ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7bcd1819a95a1ba6a31b8363f9f1e3ba">ConstIterator</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last non-zero element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last non-zero element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last non-zero element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="aa2cf9c340a9ff0e4c42dbb7f69e38df9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns of the dense submatrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of columns of the dense submatrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b15b42ccb47b7fa05e0f3973223fcf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#afc4f92ddf7d63c1d1c98aed44e536fff">Pointer</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the submatrix elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage of the dense submatrix. Note that you can NOT assume that all matrix elements lie adjacent to each other! The dense submatrix may use techniques such as padding to improve the alignment of the data. </p>

</div>
</div>
<a class="anchor" id="a9bc2655320d207e9fc632889cab911c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a2b771d83f08dd25f647901e12f67c57d">ConstPointer</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the submatrix elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage of the dense submatrix. Note that you can NOT assume that all matrix elements lie adjacent to each other! The dense submatrix may use techniques such as padding to improve the alignment of the data. </p>

</div>
</div>
<a class="anchor" id="a7efa4dbd43cc995c79d5784e30ba8677"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a02885bb11af5b3c83b186f23cd3b4b54">Iterator</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last non-zero element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last non-zero element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last non-zero element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a687b4d272e968a5cf5791974086f3d93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a7bcd1819a95a1ba6a31b8363f9f1e3ba">ConstIterator</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last non-zero element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last non-zero element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last non-zero element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a68ff181be5f953d4a546d59edd7ecf00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::hasOverlap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking whether there exists an overlap in the context of a symmetric matrix. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case an overlap exists, <em>false</em> if not.</dd></dl>
<p>This function checks if in the context of a symmetric matrix the submatrix has an overlap with its counterpart. In case an overlap exists, the function return <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="af03fddea4c74cc4ddd0f08a53ece3018"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the submatrix is aliased with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this submatrix, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address is aliased with the submatrix. In contrast to the <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a29aaca43e6b9bec1585d65d6b2bdd48b" title="Returns whether the submatrix can alias with the given address alias. ">canAlias()</a> function this function is not allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="aaed7e6efea20367881f6cca64e7c0310"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool AF2, bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT2, AF2, SO2 &gt; *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the submatrix is aliased with the given dense submatrix <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this submatrix, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address is aliased with the submatrix. In contrast to the <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a29aaca43e6b9bec1585d65d6b2bdd48b" title="Returns whether the submatrix can alias with the given address alias. ">canAlias()</a> function this function is not allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="ae8b9a052a7b732636cb45bfee9086649"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::isAligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the submatrix is properly aligned in memory. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the submatrix is aligned, <em>false</em> if not.</dd></dl>
<p>This function returns whether the submatrix is guaranteed to be properly aligned in memory, i.e. whether the beginning and the end of each row/column of the submatrix are guaranteed to conform to the alignment restrictions of the underlying element type. </p>

</div>
</div>
<a class="anchor" id="aab571040cf99fdfac22de37495d542c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a78085952a8bd78c636fb3544d07662eb">IntrinsicType</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligned load of an intrinsic element of the submatrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded intrinsic element.</dd></dl>
<p>This function performs an aligned load of a specific intrinsic element of the dense submatrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="ae20e1a890410a1cd477095fd67b10039"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a78085952a8bd78c636fb3544d07662eb">IntrinsicType</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::loadu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unaligned load of an intrinsic element of the submatrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded intrinsic element.</dd></dl>
<p>This function performs an unaligned load of a specific intrinsic element of the dense submatrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a7677188e12158044d0b4ace37c9295f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the dense submatrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the dense submatrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a12f4020cd0cdf048e8b4d5bdddd1b36e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the specified row/column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements of row/column <em>i</em>.</dd></dl>
<p>This function returns the current number of non-zero elements in the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the number of non-zero elements in row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the number of non-zero elements in column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a0f9d750bff8d2638cb61a865f8cf62b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#af05eb84353184e26a21cbfce403c2789">Reference</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2D-access to the dense submatrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="a3007230f4e22e6cd8432112e097c5277"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#af9b855bc99d4e727c51a8a42d0c8c62c">ConstReference</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2D-access to the dense submatrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="afd57b040b6230b01f7d6afaf6e107df0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt;MT,AF,SO&gt;&amp; <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication of a matrix ( <img class="formulaInl" alt="$ A*=B $" src="../../form_57.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the dense submatrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to matrix adaptor.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower triangular, upper triangular, or symmetric matrix and the assignment would violate its lower, upper, or symmetry property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a3330f294b225bdb2320bbbc16d927ec9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt;MT,AF,SO&gt; &gt;::Type&amp; <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication between a dense submatrix and a scalar value ( <img class="formulaInl" alt="$ A*=s $" src="../../form_58.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the dense submatrix.</dd></dl>
<p>This operator cannot be used for submatrices on lower or upper unitriangular matrices. The attempt to scale such a submatrix results in a compilation error! </p>

</div>
</div>
<a class="anchor" id="ada657b8c629b3087f22cad981ca48447"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt;MT&gt;, <a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">RequiresEvaluation</a>&lt;MT2&gt; &gt; , <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt;MT,AF,SO&gt;&amp; &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator for the addition of a matrix ( <img class="formulaInl" alt="$ A+=B $" src="../../form_55.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix to be added to the submatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the dense submatrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to matrix adaptor.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower triangular, upper triangular, or symmetric matrix and the assignment would violate its lower, upper, or symmetry property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="aa09a533cbc83838255b52f1ee45c1fb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt;MT&gt;, <a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">RequiresEvaluation</a>&lt;MT2&gt; &gt; , <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt;MT,AF,SO&gt;&amp; &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator for the addition of a matrix ( <img class="formulaInl" alt="$ A+=B $" src="../../form_55.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix to be added to the submatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the dense submatrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to matrix adaptor.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower triangular, upper triangular, or symmetric matrix and the assignment would violate its lower, upper, or symmetry property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a11ed42770aa84d70b691cda67b3ae367"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt;MT&gt;, <a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">RequiresEvaluation</a>&lt;MT2&gt; &gt; , <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt;MT,AF,SO&gt;&amp; &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator for the subtraction of a matrix ( <img class="formulaInl" alt="$ A-=B $" src="../../form_56.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix to be subtracted from the submatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the dense submatrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to matrix adaptor.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower triangular, upper triangular, or symmetric matrix and the assignment would violate its lower, upper, or symmetry property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a13771f3319d57620162ecc86d1036010"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt;MT&gt;, <a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">RequiresEvaluation</a>&lt;MT2&gt; &gt; , <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt;MT,AF,SO&gt;&amp; &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator for the subtraction of a matrix ( <img class="formulaInl" alt="$ A-=B $" src="../../form_56.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix to be subtracted from the submatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the dense submatrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to matrix adaptor.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower triangular, upper triangular, or symmetric matrix and the assignment would violate its lower, upper, or symmetry property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="afc982a2d50e76192f7379fccfed2b1c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt;MT,AF,SO&gt; &gt;::Type&amp; <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator for the division of a dense submatrix by a scalar value ( <img class="formulaInl" alt="$ A/=s $" src="../../form_59.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the dense submatrix.</dd></dl>
<p>This operator cannot be used for submatrices on lower or upper unitriangular matrices. The attempt to scale such a submatrix results in a compilation error!</p>
<p><b>Note:</b> A division by zero is only checked by an user assert. </p>

</div>
</div>
<a class="anchor" id="af45ae3b7883d48e4942b3d9372e7b13a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt; &amp; <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#aa287f4f75c6edefb3b3b8adb19482603">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Homogenous assignment to all submatrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Scalar value to be assigned to all submatrix elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned submatrix.</dd></dl>
<p>This function homogeneously assigns the given value to all dense matrix elements. Note that in case the underlying dense matrix is a lower/upper matrix only lower/upper and diagonal elements of the underlying matrix are modified. </p>

</div>
</div>
<a class="anchor" id="a2a10a7c7ebfbd1bf89c87207145840d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt; &amp; <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator for <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html" title="View on a specific submatrix of a dense matrix.The DenseSubmatrix template represents a view on a spe...">DenseSubmatrix</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Sparse submatrix to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned submatrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d2/d6e/structblaze_1_1Submatrix.html" title="Base class for all submatrices.The Submatrix class serves as a tag for all submatrices (i...">Submatrix</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to matrix adaptor.</td></tr>
  </table>
  </dd>
</dl>
<p>The dense submatrix is initialized as a copy of the given dense submatrix. In case the current sizes of the two submatrices don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower triangular, upper triangular, or symmetric matrix and the assignment would violate its lower, upper, or symmetry property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a7abc3395ec6cdcdeee1fe1aa5c4b8e6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt;MT,AF,SO&gt;&amp; <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for different matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned submatrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to matrix adaptor.</td></tr>
  </table>
  </dd>
</dl>
<p>The dense submatrix is initialized as a copy of the given matrix. In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower triangular, upper triangular, or symmetric matrix and the assignment would violate its lower, upper, or symmetry property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="af6a540a2c4c893ac8d4842bbbfd19a61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>&amp; <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">blaze::Matrix</a>&lt; MT, SO &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for non-constant matrices. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference of the actual type of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a71becdce9e44bcba62ee6458c6f5a6fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>&amp; <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">blaze::Matrix</a>&lt; MT, SO &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for constant matrices. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant reference of the actual type of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a6fde62a2250d8700875cbee2b6684e7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt;MT2&gt; &gt;, bool &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT3, SO3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying matrix of type <em>MT</em> would be violated by an assignment of the given matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="aa6d31e5b0b38dc251faa90e3da60ec5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT3, SO3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying symmetric matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The symmetric matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying symmetric matrix of type <em>MT</em> would be violated by an assignment of the given row-major matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a9873d9b8e29d6d957ae258760e79f071"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The lower matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying lower triangular matrix of type <em>MT</em> would be violated by an assignment of the given row-major dense matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a4aa03c7f4c6a42ab00123580671e8752"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The lower matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying lower triangular matrix of type <em>MT</em> would be violated by an assignment of the given column-major dense matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="adff18617715a27b536927216edef628e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The lower matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying lower triangular matrix of type <em>MT</em> would be violated by an assignment of the given row-major sparse matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a6b7886d208e749d34e42e1465c04056d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The lower matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying lower triangular matrix of type <em>MT</em> would be violated by an assignment of the given column-major sparse matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a09fff0c2c7c02808a72d3b4403626b4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The upper matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying upper triangular matrix of type <em>MT</em> would be violated by an assignment of the given row-major dense matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="adb462c323407d7201b168c7bac9ec425"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The upper matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying upper triangular matrix of type <em>MT</em> would be violated by an assignment of the given column-major dense matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="aa3bc7587f5689e118ee2e1d3da1a3026"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The upper matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying upper triangular matrix of type <em>MT</em> would be violated by an assignment of the given row-major sparse matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a86044d8096a9ce2b8a7a667dfeb223f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The upper matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying upper triangular matrix of type <em>MT</em> would be violated by an assignment of the given column-major sparse matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a831ece53aa4a5aad038b215bc5d1af02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt;, bool &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying diagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The diagonal matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying diagonal matrix of type <em>MT</em> would be violated by an assignment of the given row-major dense matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a4f15f4f6441361398424c74152793132"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt;, bool &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying diagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The diagonal matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying diagonal matrix of type <em>MT</em> would be violated by an assignment of the given column-major dense matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="af91cdc3e779d89b9a9ea8c7fda8e5fd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt;, bool &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying diagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The diagonal matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying diagonal matrix of type <em>MT</em> would be violated by an assignment of the given row-major sparse matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a84e7cf8a1547c20fccceb5422c3c9397"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt;, bool &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying diagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The diagonal matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying diagonal matrix of type <em>MT</em> would be violated by an assignment of the given column-major sparse matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a9cb69976f71a3a3f9bc8e30954490b8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to the default initial values. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a96e7629dcb57ca64f1cb6b36400558f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the specified row/column to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets the values in the specified row/column to their default value. In case the storage order is set to <em>rowMajor</em> the function resets the values in row <em>i</em>, in case the storage order is set to <em>columnMajor</em> the function resets the values in column <em>i</em>. Note that the capacity of the row/column remains unchanged. </p>

</div>
</div>
<a class="anchor" id="a2d003bceb6d8452493d38f913544726d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of rows of the dense submatrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of rows of the dense submatrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d909d41414078d47f5af23a3b97adf3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt;MT,AF,SO&gt;&amp; <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scaling of the dense submatrix by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_63.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value for the submatrix scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the dense submatrix.</dd></dl>
<p>This function scales all elements of the submatrix by the given scalar value <em>scalar</em>. Note that the function cannot be used to scale a submatrix on a lower or upper unitriangular matrix. The attempt to scale such a submatrix results in a compile time error! </p>

</div>
</div>
<a class="anchor" id="a78b047d8f4dd4954ed8d3d0b955f9aef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::spacing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the spacing between the beginning of two rows/columns. </p>
<dl class="section return"><dt>Returns</dt><dd>The spacing between the beginning of two rows/columns.</dd></dl>
<p>This function returns the spacing between the beginning of two rows/columns, i.e. the total number of elements of a row/column. In case the storage order is set to <em>rowMajor</em> the function returns the spacing between two rows, in case the storage flag is set to <em>columnMajor</em> the function returns the spacing between two columns. </p>

</div>
</div>
<a class="anchor" id="ab83fb3c81271a510addb03e8b578c313"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a78085952a8bd78c636fb3544d07662eb">IntrinsicType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligned store of an intrinsic element of the submatrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
    <tr><td class="paramname">value</td><td>The intrinsic element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an aligned store of a specific intrinsic element of the dense submatrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a1329e5583d3d919181012652e921ac48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::storeu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a78085952a8bd78c636fb3544d07662eb">IntrinsicType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unaligned store of an intrinsic element of the submatrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
    <tr><td class="paramname">value</td><td>The intrinsic element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an unaligned store of a specific intrinsic element of the dense submatrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="abc5d33386e14749b29cbc8d876a03a18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html#a78085952a8bd78c636fb3544d07662eb">IntrinsicType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligned, non-temporal store of an intrinsic element of the submatrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
    <tr><td class="paramname">value</td><td>The intrinsic element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an aligned, non-temporal store of a specific intrinsic element of the dense submatrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a42ca712438380e9178a2e05bc2c23dcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a column-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a8790aa8a03f2772ecfba1c092cefa132"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="abb3be47da5db7b5563b4e6a9893dcf7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="aaca534b70ed859bbc2aa584d860c6073"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt;MT,AF,SO&gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt;MT2&gt; &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a42d4a49b1bdea4aaccf84c01b2d636e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt;MT,AF,SO&gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt;MT2&gt; &gt;::Type <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the subtraction assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a422dcf6d780ce03f4fcfb6136f1baed4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">DenseSubmatrix</a>&lt; MT, AF, SO &gt; &amp; <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transposing the submatrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the transposed submatrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Invalid transpose of a non-quadratic submatrix. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>Invalid transpose of a lower matrix. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>Invalid transpose of an upper matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This function transposes the dense submatrix in-place. Note that this function can only be used for quadratic submatrices, i.e. if the number of rows is equal to the number of columns. Also, in case the underlying matrix is a lower or upper triangular matrix the function can only be used in case the submatrix does not contain elements from the upper or lower part of the matrix, respectively. The attempt to transpose a non-quadratic submatrix or an invalid part of a lower or triangular matrix results in a <em>std::runtime_error</em> exception. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a25150993d90ceca2284e02f4f4c0eb5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::final_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The final index for unaligned intrinsic operations. </p>
<p>In case the submatrix is not fully aligned and the submatrix is involved in a vectorized operation, the final index indicates at which index a special treatment for the remaining elements is required. </p>

</div>
</div>
<a class="anchor" id="a13a823f812e2d39352b4d769892d782e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html">blaze::DenseSubmatrix</a>&lt; MT, AF, SO &gt;::isAligned_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory alignment flag. </p>
<p>The alignment flag indicates whether the submatrix is fully aligned. In case the submatrix is fully aligned, no special handling has to be used for the last elements of the submatrix in a vectorized operation. In order to be aligned, the following conditions must hold for the submatrix:</p><ul>
<li>The first element of each row/column must be aligned</li>
<li>The submatrix must be at the end of the given matrix or</li>
<li>The number of rows/columns of the submatrix must be a multiple of the number of values per intrinsic element. </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>blaze/math/views/<a class="el" href="../../d6/d3b/views_2DenseSubmatrix_8h_source.html">DenseSubmatrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:55:23 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
