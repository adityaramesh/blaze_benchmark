<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Sparse Vectors</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sparse Vectors<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../dc/dcf/group__vector.html">Vectors</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:d9/dd2/group__sparse__vector__expression"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd2/group__sparse__vector__expression.html">Expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/da9/group__compressed__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da9/group__compressed__vector.html">CompressedVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">blaze::SparseVector&lt; VT, TF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sparse vectors.The <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html" title="Base class for sparse vectors.The SparseVector class is a base class for all arbitrarily sized (N-dim...">SparseVector</a> class is a base class for all arbitrarily sized (N-dimensional) sparse vectors. It provides an abstraction from the actual type of the sparse vector, but enables a conversion back to this type via the <a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> base class.  <a href="../../d6/d31/structblaze_1_1SparseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab3fbcd035fcb7ffda672fbc102afb585"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gab3fbcd035fcb7ffda672fbc102afb585"><td class="memTemplItemLeft" align="right" valign="top">const DVecSVecMultExpr&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gab3fbcd035fcb7ffda672fbc102afb585">blaze::operator*</a> (const DenseVector&lt; T1, TF &gt; &amp;lhs, const SparseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab3fbcd035fcb7ffda672fbc102afb585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_123.png"/>).  <a href="#gab3fbcd035fcb7ffda672fbc102afb585">More...</a><br /></td></tr>
<tr class="separator:gab3fbcd035fcb7ffda672fbc102afb585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9688cb03b30fc369cf5d5f3a96115958"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga9688cb03b30fc369cf5d5f3a96115958"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf&lt; Or&lt; IsSymmetric&lt; T1 &gt;, IsMatMatMultExpr&lt; T1 &gt; &gt;, SMatSVecMultExpr&lt; T1, T2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga9688cb03b30fc369cf5d5f3a96115958">blaze::operator*</a> (const SparseMatrix&lt; T1, false &gt; &amp;mat, const SparseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga9688cb03b30fc369cf5d5f3a96115958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=B*\vec{c} $" src="../../form_130.png"/>).  <a href="#ga9688cb03b30fc369cf5d5f3a96115958">More...</a><br /></td></tr>
<tr class="separator:ga9688cb03b30fc369cf5d5f3a96115958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4030f434bb2acdea2622f2ca07df99e6"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4030f434bb2acdea2622f2ca07df99e6"><td class="memTemplItemLeft" align="right" valign="top">const SVecAbsExpr&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga4030f434bb2acdea2622f2ca07df99e6">blaze::abs</a> (const SparseVector&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga4030f434bb2acdea2622f2ca07df99e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the absolute values of each single element of <em>sv</em>.  <a href="#ga4030f434bb2acdea2622f2ca07df99e6">More...</a><br /></td></tr>
<tr class="separator:ga4030f434bb2acdea2622f2ca07df99e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="memTemplItemLeft" align="right" valign="top">const SVecDVecMultExpr&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga931bca871bc8961db7f2a7b5d9892b3c">blaze::operator*</a> (const SparseVector&lt; T1, TF &gt; &amp;lhs, const DenseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_123.png"/>).  <a href="#ga931bca871bc8961db7f2a7b5d9892b3c">More...</a><br /></td></tr>
<tr class="separator:ga931bca871bc8961db7f2a7b5d9892b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9a411c9688799b2ef0f334c98f216cf"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gac9a411c9688799b2ef0f334c98f216cf"><td class="memTemplItemLeft" align="right" valign="top">const SVecEvalExpr&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gac9a411c9688799b2ef0f334c98f216cf">blaze::eval</a> (const SparseVector&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gac9a411c9688799b2ef0f334c98f216cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given sparse vector expression <em>sv</em>.  <a href="#gac9a411c9688799b2ef0f334c98f216cf">More...</a><br /></td></tr>
<tr class="separator:gac9a411c9688799b2ef0f334c98f216cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b7ada6f6e68205ac96cdb308f5d4bd7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga0b7ada6f6e68205ac96cdb308f5d4bd7"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsNumeric&lt; T2 &gt;, typename DivExprTrait&lt; T1, T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga0b7ada6f6e68205ac96cdb308f5d4bd7">blaze::operator/</a> (const SparseVector&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga0b7ada6f6e68205ac96cdb308f5d4bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the divison of a sparse vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_125.png"/>).  <a href="#ga0b7ada6f6e68205ac96cdb308f5d4bd7">More...</a><br /></td></tr>
<tr class="separator:ga0b7ada6f6e68205ac96cdb308f5d4bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6ef1ca2e0a236659aaf0df816b52c52"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gab6ef1ca2e0a236659aaf0df816b52c52"><td class="memTemplItemLeft" align="right" valign="top">const SVecScalarMultExpr&lt; VT, typename BaseElementType&lt; VT &gt;::Type, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gab6ef1ca2e0a236659aaf0df816b52c52">blaze::operator-</a> (const SparseVector&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gab6ef1ca2e0a236659aaf0df816b52c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a sparse vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_126.png"/>).  <a href="#gab6ef1ca2e0a236659aaf0df816b52c52">More...</a><br /></td></tr>
<tr class="separator:gab6ef1ca2e0a236659aaf0df816b52c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a13a11aab1762aba19e74a9cea87266"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga2a13a11aab1762aba19e74a9cea87266"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsNumeric&lt; T2 &gt;, typename MultExprTrait&lt; T1, T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga2a13a11aab1762aba19e74a9cea87266">blaze::operator*</a> (const SparseVector&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga2a13a11aab1762aba19e74a9cea87266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_72.png"/>).  <a href="#ga2a13a11aab1762aba19e74a9cea87266">More...</a><br /></td></tr>
<tr class="separator:ga2a13a11aab1762aba19e74a9cea87266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19736a03fdce17b21867a7d4ce5e4587"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga19736a03fdce17b21867a7d4ce5e4587"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsNumeric&lt; T1 &gt;, typename MultExprTrait&lt; T1, T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga19736a03fdce17b21867a7d4ce5e4587">blaze::operator*</a> (T1 scalar, const SparseVector&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga19736a03fdce17b21867a7d4ce5e4587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_127.png"/>).  <a href="#ga19736a03fdce17b21867a7d4ce5e4587">More...</a><br /></td></tr>
<tr class="separator:ga19736a03fdce17b21867a7d4ce5e4587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43666f6cb23c23f8cff15a5195ce2852"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga43666f6cb23c23f8cff15a5195ce2852"><td class="memTemplItemLeft" align="right" valign="top">const SVecSerialExpr&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga43666f6cb23c23f8cff15a5195ce2852">blaze::serial</a> (const SparseVector&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga43666f6cb23c23f8cff15a5195ce2852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the serial evaluation of the given sparse vector expression <em>sv</em>.  <a href="#ga43666f6cb23c23f8cff15a5195ce2852">More...</a><br /></td></tr>
<tr class="separator:ga43666f6cb23c23f8cff15a5195ce2852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3012773ba555712c006466a901f2b7b6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga3012773ba555712c006466a901f2b7b6"><td class="memTemplItemLeft" align="right" valign="top">const SVecSVecAddExpr&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga3012773ba555712c006466a901f2b7b6">blaze::operator+</a> (const SparseVector&lt; T1, TF &gt; &amp;lhs, const SparseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3012773ba555712c006466a901f2b7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_120.png"/>).  <a href="#ga3012773ba555712c006466a901f2b7b6">More...</a><br /></td></tr>
<tr class="separator:ga3012773ba555712c006466a901f2b7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccf01f6322bcd426a734b284aa123b8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaaccf01f6322bcd426a734b284aa123b8"><td class="memTemplItemLeft" align="right" valign="top">const SVecSVecMultExpr&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaaccf01f6322bcd426a734b284aa123b8">blaze::operator*</a> (const SparseVector&lt; T1, TF &gt; &amp;lhs, const SparseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaaccf01f6322bcd426a734b284aa123b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise multiplication of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_123.png"/>).  <a href="#gaaccf01f6322bcd426a734b284aa123b8">More...</a><br /></td></tr>
<tr class="separator:gaaccf01f6322bcd426a734b284aa123b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="memTemplItemLeft" align="right" valign="top">const SVecSVecSubExpr&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga1a9bad0a58b194a184fa8b9e14618a4f">blaze::operator-</a> (const SparseVector&lt; T1, TF &gt; &amp;lhs, const SparseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_124.png"/>).  <a href="#ga1a9bad0a58b194a184fa8b9e14618a4f">More...</a><br /></td></tr>
<tr class="separator:ga1a9bad0a58b194a184fa8b9e14618a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24d22f5812d106f439ea9d7e72cd78d8"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga24d22f5812d106f439ea9d7e72cd78d8"><td class="memTemplItemLeft" align="right" valign="top">const SVecTransExpr&lt; VT,!TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga24d22f5812d106f439ea9d7e72cd78d8">blaze::trans</a> (const SparseVector&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga24d22f5812d106f439ea9d7e72cd78d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given sparse vector.  <a href="#ga24d22f5812d106f439ea9d7e72cd78d8">More...</a><br /></td></tr>
<tr class="separator:ga24d22f5812d106f439ea9d7e72cd78d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38eeea18da3978abfc138b094e984f6d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga38eeea18da3978abfc138b094e984f6d"><td class="memTemplItemLeft" align="right" valign="top">const MultTrait&lt; typename T1::ElementType, typename T2::ElementType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga38eeea18da3978abfc138b094e984f6d">blaze::operator*</a> (const DenseVector&lt; T1, true &gt; &amp;lhs, const SparseVector&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga38eeea18da3978abfc138b094e984f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of a dense and a sparse vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_135.png"/>).  <a href="#ga38eeea18da3978abfc138b094e984f6d">More...</a><br /></td></tr>
<tr class="separator:ga38eeea18da3978abfc138b094e984f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae59ab01e702dfd082c425a359b7c2bf2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae59ab01e702dfd082c425a359b7c2bf2"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf&lt; IsMatMatMultExpr&lt; T1 &gt;, TSMatSVecMultExpr&lt; T1, T2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gae59ab01e702dfd082c425a359b7c2bf2">blaze::operator*</a> (const SparseMatrix&lt; T1, true &gt; &amp;mat, const SparseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gae59ab01e702dfd082c425a359b7c2bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_113.png"/>).  <a href="#gae59ab01e702dfd082c425a359b7c2bf2">More...</a><br /></td></tr>
<tr class="separator:gae59ab01e702dfd082c425a359b7c2bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa669e7fdfba70b0a9b33729e7bf329d6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa669e7fdfba70b0a9b33729e7bf329d6"><td class="memTemplItemLeft" align="right" valign="top">const MultTrait&lt; typename T1::ElementType, typename T2::ElementType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa669e7fdfba70b0a9b33729e7bf329d6">blaze::operator*</a> (const SparseVector&lt; T1, true &gt; &amp;lhs, const DenseVector&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa669e7fdfba70b0a9b33729e7bf329d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of a sparse and a dense vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_135.png"/>).  <a href="#gaa669e7fdfba70b0a9b33729e7bf329d6">More...</a><br /></td></tr>
<tr class="separator:gaa669e7fdfba70b0a9b33729e7bf329d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfec08873101a5b3600d7c34be7d5c54"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gacfec08873101a5b3600d7c34be7d5c54"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf&lt; IsMatMatMultExpr&lt; T2 &gt;, TSVecSMatMultExpr&lt; T1, T2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gacfec08873101a5b3600d7c34be7d5c54">blaze::operator*</a> (const SparseVector&lt; T1, true &gt; &amp;vec, const SparseMatrix&lt; T2, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:gacfec08873101a5b3600d7c34be7d5c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>).  <a href="#gacfec08873101a5b3600d7c34be7d5c54">More...</a><br /></td></tr>
<tr class="separator:gacfec08873101a5b3600d7c34be7d5c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0abe3eab9e7afe0dde91f8ee179d718"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gab0abe3eab9e7afe0dde91f8ee179d718"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsMatMatMultExpr&lt; T2 &gt;, typename MultExprTrait&lt; T1, T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gab0abe3eab9e7afe0dde91f8ee179d718">blaze::operator*</a> (const SparseVector&lt; T1, true &gt; &amp;vec, const SparseMatrix&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:gab0abe3eab9e7afe0dde91f8ee179d718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a sparse matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_133.png"/>).  <a href="#gab0abe3eab9e7afe0dde91f8ee179d718">More...</a><br /></td></tr>
<tr class="separator:gab0abe3eab9e7afe0dde91f8ee179d718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75acb12c5e42f8164aeb6c1272a77580"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga75acb12c5e42f8164aeb6c1272a77580"><td class="memTemplItemLeft" align="right" valign="top">const MultTrait&lt; typename T1::ElementType, typename T2::ElementType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga75acb12c5e42f8164aeb6c1272a77580">blaze::operator*</a> (const SparseVector&lt; T1, true &gt; &amp;lhs, const SparseVector&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga75acb12c5e42f8164aeb6c1272a77580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the scalar product (inner product) of two sparse vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_135.png"/>).  <a href="#ga75acb12c5e42f8164aeb6c1272a77580">More...</a><br /></td></tr>
<tr class="separator:ga75acb12c5e42f8164aeb6c1272a77580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7170f84062db500e51c7ae55095e6792"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga7170f84062db500e51c7ae55095e6792"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf&lt; Or&lt; IsSymmetric&lt; T2 &gt;, IsMatMatMultExpr&lt; T2 &gt; &gt;, TSVecTSMatMultExpr&lt; T1, T2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga7170f84062db500e51c7ae55095e6792">blaze::operator*</a> (const SparseVector&lt; T1, true &gt; &amp;vec, const SparseMatrix&lt; T2, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga7170f84062db500e51c7ae55095e6792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>).  <a href="#ga7170f84062db500e51c7ae55095e6792">More...</a><br /></td></tr>
<tr class="separator:ga7170f84062db500e51c7ae55095e6792"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseVector operators</h2></td></tr>
<tr class="memitem:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga3abacbc4a4ecdb439384f1ce2ae38246">blaze::operator==</a> (const SparseVector&lt; T1, TF1 &gt; &amp;lhs, const SparseVector&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two sparse vectors.  <a href="#ga3abacbc4a4ecdb439384f1ce2ae38246">More...</a><br /></td></tr>
<tr class="separator:ga3abacbc4a4ecdb439384f1ce2ae38246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga47bd825d8a1516cf16134c4dc9ac918a">blaze::operator!=</a> (const SparseVector&lt; T1, TF1 &gt; &amp;lhs, const SparseVector&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two sparse vectors.  <a href="#ga47bd825d8a1516cf16134c4dc9ac918a">More...</a><br /></td></tr>
<tr class="separator:ga47bd825d8a1516cf16134c4dc9ac918a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseVector functions</h2></td></tr>
<tr class="memitem:ga4490b16f3da675eb29db391adcf46f98"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4490b16f3da675eb29db391adcf46f98"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga4490b16f3da675eb29db391adcf46f98">blaze::isnan</a> (const SparseVector&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga4490b16f3da675eb29db391adcf46f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given sparse vector for not-a-number elements.  <a href="#ga4490b16f3da675eb29db391adcf46f98">More...</a><br /></td></tr>
<tr class="separator:ga4490b16f3da675eb29db391adcf46f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa58862b9f216db8c76842cd7c649d092"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaa58862b9f216db8c76842cd7c649d092"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaa58862b9f216db8c76842cd7c649d092">blaze::isUniform</a> (const SparseVector&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaa58862b9f216db8c76842cd7c649d092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given sparse vector is a uniform vector.  <a href="#gaa58862b9f216db8c76842cd7c649d092">More...</a><br /></td></tr>
<tr class="separator:gaa58862b9f216db8c76842cd7c649d092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fcbcad1a4ede9c56f560ac0e7c25528"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga2fcbcad1a4ede9c56f560ac0e7c25528"><td class="memTemplItemLeft" align="right" valign="top">CMathTrait&lt; typename VT::ElementType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga2fcbcad1a4ede9c56f560ac0e7c25528">blaze::length</a> (const SparseVector&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga2fcbcad1a4ede9c56f560ac0e7c25528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the sparse vector length <img class="formulaInl" alt="$|\vec{a}|$" src="../../form_46.png"/>.  <a href="#ga2fcbcad1a4ede9c56f560ac0e7c25528">More...</a><br /></td></tr>
<tr class="separator:ga2fcbcad1a4ede9c56f560ac0e7c25528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e81413a433257d85cce1c5fc8f6a262"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga0e81413a433257d85cce1c5fc8f6a262"><td class="memTemplItemLeft" align="right" valign="top">const VT::ElementType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga0e81413a433257d85cce1c5fc8f6a262">blaze::sqrLength</a> (const SparseVector&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga0e81413a433257d85cce1c5fc8f6a262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the sparse vector square length <img class="formulaInl" alt="$|\vec{a}|^2$" src="../../form_47.png"/>.  <a href="#ga0e81413a433257d85cce1c5fc8f6a262">More...</a><br /></td></tr>
<tr class="separator:ga0e81413a433257d85cce1c5fc8f6a262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dfece09c8894df8c71845d072c5ef01"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4dfece09c8894df8c71845d072c5ef01"><td class="memTemplItemLeft" align="right" valign="top">const VT::ElementType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#ga4dfece09c8894df8c71845d072c5ef01">blaze::min</a> (const SparseVector&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga4dfece09c8894df8c71845d072c5ef01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the sparse vector.  <a href="#ga4dfece09c8894df8c71845d072c5ef01">More...</a><br /></td></tr>
<tr class="separator:ga4dfece09c8894df8c71845d072c5ef01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5abd27e95a034535519cb8d7cf77b96"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaf5abd27e95a034535519cb8d7cf77b96"><td class="memTemplItemLeft" align="right" valign="top">const VT::ElementType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d2f/group__sparse__vector.html#gaf5abd27e95a034535519cb8d7cf77b96">blaze::max</a> (const SparseVector&lt; VT, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaf5abd27e95a034535519cb8d7cf77b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the sparse vector.  <a href="#gaf5abd27e95a034535519cb8d7cf77b96">More...</a><br /></td></tr>
<tr class="separator:gaf5abd27e95a034535519cb8d7cf77b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga4030f434bb2acdea2622f2ca07df99e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SVecAbsExpr&lt;VT,TF&gt; blaze::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the absolute values of each single element of <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The integral sparse input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of each single element of <em>sv</em>.</dd></dl>
<p>The <em>abs</em> function calculates the absolute value of each element of the sparse input vector <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>abs</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaf0f17914afcea53bd79d0da9b5ae863">abs</a>( a );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gac9a411c9688799b2ef0f334c98f216cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SVecEvalExpr&lt;VT,TF&gt; blaze::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the evaluation of the given sparse vector expression <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated sparse vector.</dd></dl>
<p>The <em>eval</em> function forces the evaluation of the given sparse vector expression <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>eval</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gacb9f8190d38edb0e52d9c376da5486d6">eval</a>( a );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga4490b16f3da675eb29db391adcf46f98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the given sparse vector for not-a-number elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse vector to be checked for not-a-number elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the vector is not-a-number, <em>false</em> otherwise.</dd></dl>
<p>This function checks the N-dimensional sparse vector for not-a-number (NaN) elements. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> at least one element of the vector is not-a-number, the function returns <em>true</em>, otherwise it returns <em>false</em>.</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga99ba6a5b32152077ba7d013be1add4dc">isnan</a>( a ) ) { ... }</div>
</div><!-- fragment --><p>Note that this function only works for vectors with floating point elements. The attempt to use it for a vector with a non-floating point element type results in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gaa58862b9f216db8c76842cd7c649d092"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given sparse vector is a uniform vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the vector is a uniform vector, <em>false</em> if not.</dd></dl>
<p>This function checks if the given sparse vector is a uniform vector. The vector is considered to be uniform if all its elements are identical. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;int,blaze::columnVector&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Initialization</span></div>
<div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7aafd1dd369f715e523850f4adb36696">isUniform</a>( a ) ) { ... }</div>
</div><!-- fragment --><p>It is also possible to check if a vector expression results in a uniform vector:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7aafd1dd369f715e523850f4adb36696">isUniform</a>( a + b ) ) { ... }</div>
</div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary vector. </p>

</div>
</div>
<a class="anchor" id="ga2fcbcad1a4ede9c56f560ac0e7c25528"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CMathTrait&lt; typename VT::ElementType &gt;::Type blaze::length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the sparse vector length <img class="formulaInl" alt="$|\vec{a}|$" src="../../form_46.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The given sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the sparse vector.</dd></dl>
<p>This function calculates the actual length of the sparse vector. The return type of the <a class="el" href="../../de/d90/group__dense__vector.html#ga0643d4e96e0b9f11356f4d28589963c3" title="Calculation of the dense vector length . ">length()</a> function depends on the actual element type of the vector instance:</p>
<table  border="0" cellspacing="0" cellpadding="1">
<tr>
<td width="250px"><b>Type</b>  </td><td width="100px"><b>LengthType</b>   </td></tr>
<tr>
<td>float </td><td>float  </td></tr>
<tr>
<td>integral data types and double </td><td>double  </td></tr>
<tr>
<td>long double </td><td>long double  </td></tr>
</table>
<p><b>Note:</b> This operation is only defined for numeric data types. In case the element type is not a numeric data type (i.e. a user defined data type or boolean) the attempt to use the <a class="el" href="../../de/d90/group__dense__vector.html#ga0643d4e96e0b9f11356f4d28589963c3" title="Calculation of the dense vector length . ">length()</a> function results in a compile time error! </p>

</div>
</div>
<a class="anchor" id="gaf5abd27e95a034535519cb8d7cf77b96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VT::ElementType blaze::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the largest element of the sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The given sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest sparse vector element.</dd></dl>
<p>This function returns the largest element of the given sparse vector. This function can only be used for element types that support the smaller-than relationship. In case the vector currently has a size of 0, the returned value is the default value (e.g. 0 in case of fundamental data types).</p>
<p><b>Note:</b> In case the compressed vector is not completely filled, the zero elements are also taken into account. Example: the following compressed vector has only 2 non-zero elements. However, the maximum of this vector is 0:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left(\begin{array}{*{4}{c}} -1 &amp; 0 &amp; -3 &amp; 0 \\ \end{array}\right) \]" src="../../form_143.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="ga4dfece09c8894df8c71845d072c5ef01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VT::ElementType blaze::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smallest element of the sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The given sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest sparse vector element.</dd></dl>
<p>This function returns the smallest element of the given sparse vector. This function can only be used for element types that support the smaller-than relationship. In case the vector currently has a size of 0, the returned value is the default value (e.g. 0 in case of fundamental data types).</p>
<p><b>Note:</b> In case the sparse vector is not completely filled, the zero elements are also taken into account. Example: the following compressed vector has only 2 non-zero elements. However, the minimum of this vector is 0:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left(\begin{array}{*{4}{c}} 1 &amp; 0 &amp; 3 &amp; 0 \\ \end{array}\right) \]" src="../../form_142.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="ga47bd825d8a1516cf16134c4dc9ac918a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of two sparse vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="ga75acb12c5e42f8164aeb6c1272a77580"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MultTrait&lt;typename T1::ElementType,typename T2::ElementType&gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the scalar product (inner product) of two sparse vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_135.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of two sparse vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> a, b;</div>
<div class="line"><a class="code" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">blaze::real</a> res;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">res = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>(a) * b;</div>
</div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gaa669e7fdfba70b0a9b33729e7bf329d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MultTrait&lt;typename T1::ElementType,typename T2::ElementType&gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the scalar product (inner product) of a sparse and a dense vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_135.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> a;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> b;</div>
<div class="line"><a class="code" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">blaze::real</a> res;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">res = a * b;</div>
</div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga38eeea18da3978abfc138b094e984f6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MultTrait&lt;typename T1::ElementType,typename T2::ElementType&gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the scalar product (inner product) of a dense and a sparse vector ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_135.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a> a;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> b;</div>
<div class="line"><a class="code" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">blaze::real</a> res;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">res = a * b;</div>
</div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gaaccf01f6322bcd426a734b284aa123b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SVecSVecMultExpr&lt;T1,T2,TF&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the componentwise multiplication of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_123.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the componentwise multiplication of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a * b;</div>
</div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga931bca871bc8961db7f2a7b5d9892b3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SVecDVecMultExpr&lt;T1,T2,TF&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the componentwise product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_123.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the componentwise multiplication of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, c;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a * b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gab3fbcd035fcb7ffda672fbc102afb585"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecSVecMultExpr&lt;T1,T2,TF&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the componentwise product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_123.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the componentwise multiplication of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a * b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga2a13a11aab1762aba19e74a9cea87266"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsNumeric&lt;T2&gt;, typename MultExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a sparse vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_72.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the multiplication between a sparse vector and a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = a * 1.25;</div>
</div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a class="anchor" id="ga19736a03fdce17b21867a7d4ce5e4587"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsNumeric&lt;T1&gt;, typename MultExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a scalar value and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_127.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the multiplication between a a scalar value and sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = 1.25 * a;</div>
</div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the involved data types <em>T1</em> and <em>T2::ElementType</em>. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a class="anchor" id="gae59ab01e702dfd082c425a359b7c2bf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T1&gt;, TSMatSVecMultExpr&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse matrix and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> x, y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse matrix type <em>T1</em> and the sparse vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gacfec08873101a5b3600d7c34be7d5c54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T2&gt;, TSVecSMatMultExpr&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side row-major sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse vector and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> x, y;</div>
<div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = x * A;</div>
</div><!-- fragment --><p>The operator returns an expression representing a transpose sparse vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse vector type <em>T1</em> and the sparse matrix type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gab0abe3eab9e7afe0dde91f8ee179d718"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsMatMatMultExpr&lt;T2&gt;, typename MultExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a sparse matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_133.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side sparse matrix-matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector.</dd></dl>
<p>This operator implements a performance optimized treatment of the multiplication of a sparse vector and a sparse matrix-matrix multiplication expression. It restructures the expression <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_133.png"/> to the expression <img class="formulaInl" alt="$ \vec{y}^T=(\vec{x}^T*A)*B $" src="../../form_134.png"/>. </p>

</div>
</div>
<a class="anchor" id="ga7170f84062db500e51c7ae55095e6792"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; Or&lt; IsSymmetric&lt;T2&gt;, IsMatMatMultExpr&lt;T2&gt; &gt; , TSVecTSMatMultExpr&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a column-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side column-major sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse vector and a column-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> x, y;</div>
<div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = x * A;</div>
</div><!-- fragment --><p>The operator returns an expression representing a transpose sparse vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse vector type <em>T1</em> and the sparse matrix type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga9688cb03b30fc369cf5d5f3a96115958"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; Or&lt; IsSymmetric&lt;T1&gt;, IsMatMatMultExpr&lt;T1&gt; &gt; , SMatSVecMultExpr&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major sparse matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=B*\vec{c} $" src="../../form_130.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a row-major sparse matrix and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> x, y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a sparse vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse matrix type <em>T1</em> and the sparse vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga3012773ba555712c006466a901f2b7b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SVecSVecAddExpr&lt;T1,T2,TF&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_120.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the vector addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the vector addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a + b;</div>
</div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga1a9bad0a58b194a184fa8b9e14618a4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SVecSVecSubExpr&lt;T1,T2,TF&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_124.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the vector subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted from the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a - b;</div>
</div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gab6ef1ca2e0a236659aaf0df816b52c52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SVecScalarMultExpr&lt;VT,typename BaseElementType&lt;VT&gt;::Type,TF&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus operator for the negation of a sparse vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_126.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse vector to be negated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The negation of the vector.</dd></dl>
<p>This operator represents the negation of a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = -a;</div>
</div><!-- fragment --><p>The operator returns an expression representing the negation of the given sparse vector. </p>

</div>
</div>
<a class="anchor" id="ga0b7ada6f6e68205ac96cdb308f5d4bd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsNumeric&lt;T2&gt;, typename DivExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for the divison of a sparse vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_125.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side sparse vector for the division. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the division of a sparse vector by a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = a / 0.24;</div>
</div><!-- fragment --><p>The operator returns a sparse vector of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Note that this operator only works for scalar values of built-in data type.</p>
<p><b>Note:</b> A division by zero is only checked by an user assert. </p>

</div>
</div>
<a class="anchor" id="ga3abacbc4a4ecdb439384f1ce2ae38246"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two sparse vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two sparse vectors are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga43666f6cb23c23f8cff15a5195ce2852"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SVecSerialExpr&lt; VT, TF &gt; blaze::serial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the serial evaluation of the given sparse vector expression <em>sv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated sparse vector.</dd></dl>
<p>The <em>serial</em> function forces the serial evaluation of the given sparse vector expression <em>sv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>serial</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaeac3b9aff5df5e547819e485321f4762">serial</a>( a );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga0e81413a433257d85cce1c5fc8f6a262"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VT::ElementType blaze::sqrLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the sparse vector square length <img class="formulaInl" alt="$|\vec{a}|^2$" src="../../form_47.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The given sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square length of the vector.</dd></dl>
<p>This function calculates the actual square length of the sparse vector.</p>
<p><b>Note:</b> This operation is only defined for numeric data types. In case the element type is not a numeric data type (i.e. a user defined data type or boolean) the attempt to use the <a class="el" href="../../de/d90/group__dense__vector.html#ga7b68c5a39cd2fd6fb9fd91caea1747d1" title="Calculation of the dense vector square length . ">sqrLength()</a> function results in a compile time error! </p>

</div>
</div>
<a class="anchor" id="ga24d22f5812d106f439ea9d7e72cd78d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SVecTransExpr&lt; VT,!TF &gt; blaze::trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the transpose of the given sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse vector to be transposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transpose of the sparse vector.</dd></dl>
<p>This function returns an expression representing the transpose of the given sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> a;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( a );</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:55:21 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
