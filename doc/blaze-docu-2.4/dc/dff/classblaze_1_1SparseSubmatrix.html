<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>blaze::SparseSubmatrix&lt; MT, AF, SO &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="../../db/d4e/classblaze_1_1SparseSubmatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::SparseSubmatrix&lt; MT, AF, SO &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../d0/d48/group__views.html">Views</a> &raquo; <a class="el" href="../../d8/d94/group__sparse__submatrix.html">Sparse Submatrix</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> on a specific submatrix of a sparse matrix.The <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html" title="View on a specific submatrix of a sparse matrix.The SparseSubmatrix template represents a view on a s...">SparseSubmatrix</a> template represents a view on a specific submatrix of a sparse matrix primitive. The type of the sparse matrix is specified via the first template parameter:  
 <a href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../db/d5a/views_2SparseSubmatrix_8h_source.html">SparseSubmatrix.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">blaze::SparseMatrix&lt; SparseSubmatrix&lt; MT, AF, SO &gt;, SO &gt;</a>, and <a class="el" href="../../d2/d6e/structblaze_1_1Submatrix.html">blaze::Submatrix</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4a/classblaze_1_1SparseSubmatrix_1_1SubmatrixElement.html">SubmatrixElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for a specific element of the sparse submatrix.  <a href="../../d5/d4a/classblaze_1_1SparseSubmatrix_1_1SubmatrixElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d39/classblaze_1_1SparseSubmatrix_1_1SubmatrixIterator.html">SubmatrixIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the elements of the sparse submatrix.  <a href="../../d7/d39/classblaze_1_1SparseSubmatrix_1_1SubmatrixIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:gaf71472d55c6971c862bd3b7701d40d65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf71472d55c6971c862bd3b7701d40d65"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>smpAssignable</b> = MT::smpAssignable
 }</td></tr>
<tr class="memdesc:gaf71472d55c6971c862bd3b7701d40d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the expression template assignment strategy. <br /></td></tr>
<tr class="separator:gaf71472d55c6971c862bd3b7701d40d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff02329e68c135a559aa8a9ad9e0d9f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff02329e68c135a559aa8a9ad9e0d9f7"></a>
typedef <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#aff02329e68c135a559aa8a9ad9e0d9f7">This</a></td></tr>
<tr class="memdesc:aff02329e68c135a559aa8a9ad9e0d9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html" title="View on a specific submatrix of a sparse matrix.The SparseSubmatrix template represents a view on a s...">SparseSubmatrix</a> instance. <br /></td></tr>
<tr class="separator:aff02329e68c135a559aa8a9ad9e0d9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065d44699f8e989d8dc1743f22affe0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a065d44699f8e989d8dc1743f22affe0a"></a>
typedef <a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html">SubmatrixTrait</a>&lt; MT &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a065d44699f8e989d8dc1743f22affe0a">ResultType</a></td></tr>
<tr class="memdesc:a065d44699f8e989d8dc1743f22affe0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br /></td></tr>
<tr class="separator:a065d44699f8e989d8dc1743f22affe0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4266ce8bd92cf887f6c4b1f1e7c73e01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4266ce8bd92cf887f6c4b1f1e7c73e01"></a>
typedef <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html#a82dc102228fa4c8dd76f5c75d1f1cac3">ResultType::OppositeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a4266ce8bd92cf887f6c4b1f1e7c73e01">OppositeType</a></td></tr>
<tr class="memdesc:a4266ce8bd92cf887f6c4b1f1e7c73e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type with opposite storage order for expression template evaluations. <br /></td></tr>
<tr class="separator:a4266ce8bd92cf887f6c4b1f1e7c73e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320665eb62eb2ea3a7809b2c15bf6dcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a320665eb62eb2ea3a7809b2c15bf6dcd"></a>
typedef <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html#a02b3d3c589c780c2abaa5275b79b88ba">ResultType::TransposeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a320665eb62eb2ea3a7809b2c15bf6dcd">TransposeType</a></td></tr>
<tr class="memdesc:a320665eb62eb2ea3a7809b2c15bf6dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br /></td></tr>
<tr class="separator:a320665eb62eb2ea3a7809b2c15bf6dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553ac461dc0b491cd44be7e96f1b5317"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a553ac461dc0b491cd44be7e96f1b5317"></a>
typedef MT::ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a553ac461dc0b491cd44be7e96f1b5317">ElementType</a></td></tr>
<tr class="memdesc:a553ac461dc0b491cd44be7e96f1b5317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the submatrix elements. <br /></td></tr>
<tr class="separator:a553ac461dc0b491cd44be7e96f1b5317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acedac7dc08d40666ea70bc168ee274"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4acedac7dc08d40666ea70bc168ee274"></a>
typedef MT::ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a4acedac7dc08d40666ea70bc168ee274">ReturnType</a></td></tr>
<tr class="memdesc:a4acedac7dc08d40666ea70bc168ee274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br /></td></tr>
<tr class="separator:a4acedac7dc08d40666ea70bc168ee274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d796c0e28573642df7630a274b800dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d796c0e28573642df7630a274b800dd"></a>
typedef const <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a8d796c0e28573642df7630a274b800dd">CompositeType</a></td></tr>
<tr class="memdesc:a8d796c0e28573642df7630a274b800dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br /></td></tr>
<tr class="separator:a8d796c0e28573642df7630a274b800dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad569e64dcdbc66ad1ab22f78d70f803e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad569e64dcdbc66ad1ab22f78d70f803e"></a>
typedef MT::ConstReference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad569e64dcdbc66ad1ab22f78d70f803e">ConstReference</a></td></tr>
<tr class="memdesc:ad569e64dcdbc66ad1ab22f78d70f803e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant submatrix value. <br /></td></tr>
<tr class="separator:ad569e64dcdbc66ad1ab22f78d70f803e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ab2d5ad6e142226599f059d621d2eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73ab2d5ad6e142226599f059d621d2eb"></a>
typedef <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; useConst, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad569e64dcdbc66ad1ab22f78d70f803e">ConstReference</a>, typename MT::Reference &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a73ab2d5ad6e142226599f059d621d2eb">Reference</a></td></tr>
<tr class="memdesc:a73ab2d5ad6e142226599f059d621d2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant submatrix value. <br /></td></tr>
<tr class="separator:a73ab2d5ad6e142226599f059d621d2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b6573b1a8d23b804dbe31cc47fdb13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98b6573b1a8d23b804dbe31cc47fdb13"></a>
typedef <a class="el" href="../../d7/d39/classblaze_1_1SparseSubmatrix_1_1SubmatrixIterator.html">SubmatrixIterator</a>&lt; const MT, typename MT::ConstIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a></td></tr>
<tr class="memdesc:a98b6573b1a8d23b804dbe31cc47fdb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br /></td></tr>
<tr class="separator:a98b6573b1a8d23b804dbe31cc47fdb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2964f30bc0bdd80a52b6242cd7839390"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2964f30bc0bdd80a52b6242cd7839390"></a>
typedef <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; useConst, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a>, <a class="el" href="../../d7/d39/classblaze_1_1SparseSubmatrix_1_1SubmatrixIterator.html">SubmatrixIterator</a>&lt; MT, typename MT::Iterator &gt; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a></td></tr>
<tr class="memdesc:a2964f30bc0bdd80a52b6242cd7839390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br /></td></tr>
<tr class="separator:a2964f30bc0bdd80a52b6242cd7839390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8433a860ba90d8f77df196183ee2891d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8433a860ba90d8f77df196183ee2891d"></a>
typedef <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a></td></tr>
<tr class="memdesc:a8433a860ba90d8f77df196183ee2891d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the matrix. <br /></td></tr>
<tr class="separator:a8433a860ba90d8f77df196183ee2891d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab26ec6e5c9effcd5b98f99fdd8174de2"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ab26ec6e5c9effcd5b98f99fdd8174de2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ab26ec6e5c9effcd5b98f99fdd8174de2">operator=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab26ec6e5c9effcd5b98f99fdd8174de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for different matrices.  <a href="#ab26ec6e5c9effcd5b98f99fdd8174de2">More...</a><br /></td></tr>
<tr class="separator:ab26ec6e5c9effcd5b98f99fdd8174de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984b8b018a1a5a49bebafdf5c8c1f37d"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:a984b8b018a1a5a49bebafdf5c8c1f37d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a984b8b018a1a5a49bebafdf5c8c1f37d">operator+=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a984b8b018a1a5a49bebafdf5c8c1f37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator for the addition of a matrix ( <img class="formulaInl" alt="$ A+=B $" src="../../form_55.png"/>).  <a href="#a984b8b018a1a5a49bebafdf5c8c1f37d">More...</a><br /></td></tr>
<tr class="separator:a984b8b018a1a5a49bebafdf5c8c1f37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b041b8886050ae4862697108b6de1e"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:a11b041b8886050ae4862697108b6de1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a11b041b8886050ae4862697108b6de1e">operator-=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a11b041b8886050ae4862697108b6de1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator for the subtraction of a matrix ( <img class="formulaInl" alt="$ A-=B $" src="../../form_56.png"/>).  <a href="#a11b041b8886050ae4862697108b6de1e">More...</a><br /></td></tr>
<tr class="separator:a11b041b8886050ae4862697108b6de1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cc9b3a65e6ea3083370d6cb5099201"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:a74cc9b3a65e6ea3083370d6cb5099201"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a74cc9b3a65e6ea3083370d6cb5099201">operator*=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a74cc9b3a65e6ea3083370d6cb5099201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication of a matrix ( <img class="formulaInl" alt="$ A*=B $" src="../../form_57.png"/>).  <a href="#a74cc9b3a65e6ea3083370d6cb5099201">More...</a><br /></td></tr>
<tr class="separator:a74cc9b3a65e6ea3083370d6cb5099201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b3d9e7cc35da329506addf8514333e"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ad0b3d9e7cc35da329506addf8514333e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad0b3d9e7cc35da329506addf8514333e">operator*=</a> (Other rhs)</td></tr>
<tr class="memdesc:ad0b3d9e7cc35da329506addf8514333e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication between a sparse submatrix and a scalar value ( <img class="formulaInl" alt="$ A*=s $" src="../../form_58.png"/>).  <a href="#ad0b3d9e7cc35da329506addf8514333e">More...</a><br /></td></tr>
<tr class="separator:ad0b3d9e7cc35da329506addf8514333e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addccb10f997a7ddbcefeeb3415696551"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:addccb10f997a7ddbcefeeb3415696551"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#addccb10f997a7ddbcefeeb3415696551">operator/=</a> (Other rhs)</td></tr>
<tr class="memdesc:addccb10f997a7ddbcefeeb3415696551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator for the division of a sparse submatrix by a scalar value ( <img class="formulaInl" alt="$ A/=s $" src="../../form_59.png"/>).  <a href="#addccb10f997a7ddbcefeeb3415696551">More...</a><br /></td></tr>
<tr class="separator:addccb10f997a7ddbcefeeb3415696551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bad2369326af8aab38afcb929b60011"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a3bad2369326af8aab38afcb929b60011"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a3bad2369326af8aab38afcb929b60011">scale</a> (const Other &amp;scalar)</td></tr>
<tr class="memdesc:a3bad2369326af8aab38afcb929b60011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of the sparse submatrix by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_63.png"/>).  <a href="#a3bad2369326af8aab38afcb929b60011">More...</a><br /></td></tr>
<tr class="separator:a3bad2369326af8aab38afcb929b60011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5350356f08685ecc2d0336d9ad9a57f0"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:a5350356f08685ecc2d0336d9ad9a57f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt; MT2 &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a5350356f08685ecc2d0336d9ad9a57f0">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT3, SO3 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5350356f08685ecc2d0336d9ad9a57f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying matrix.  <a href="#a5350356f08685ecc2d0336d9ad9a57f0">More...</a><br /></td></tr>
<tr class="separator:a5350356f08685ecc2d0336d9ad9a57f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc78e2ba5fcbfa9d5648d5d0d80946e2"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:acc78e2ba5fcbfa9d5648d5d0d80946e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#acc78e2ba5fcbfa9d5648d5d0d80946e2">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT3, SO3 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:acc78e2ba5fcbfa9d5648d5d0d80946e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying symmetric matrix.  <a href="#acc78e2ba5fcbfa9d5648d5d0d80946e2">More...</a><br /></td></tr>
<tr class="separator:acc78e2ba5fcbfa9d5648d5d0d80946e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a5ee7f8c1136b37c39b4698b311173"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:ac8a5ee7f8c1136b37c39b4698b311173"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ac8a5ee7f8c1136b37c39b4698b311173">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac8a5ee7f8c1136b37c39b4698b311173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying lower triangular matrix.  <a href="#ac8a5ee7f8c1136b37c39b4698b311173">More...</a><br /></td></tr>
<tr class="separator:ac8a5ee7f8c1136b37c39b4698b311173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b99ef8b5490556c89bfa39c54378283"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a9b99ef8b5490556c89bfa39c54378283"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a9b99ef8b5490556c89bfa39c54378283">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9b99ef8b5490556c89bfa39c54378283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying lower triangular matrix.  <a href="#a9b99ef8b5490556c89bfa39c54378283">More...</a><br /></td></tr>
<tr class="separator:a9b99ef8b5490556c89bfa39c54378283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd10bf13e9f3c17cf9ce53219e2fb77"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:aadd10bf13e9f3c17cf9ce53219e2fb77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#aadd10bf13e9f3c17cf9ce53219e2fb77">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aadd10bf13e9f3c17cf9ce53219e2fb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying lower triangular matrix.  <a href="#aadd10bf13e9f3c17cf9ce53219e2fb77">More...</a><br /></td></tr>
<tr class="separator:aadd10bf13e9f3c17cf9ce53219e2fb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee18f45de724791715223bab4f4ae4b"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a0ee18f45de724791715223bab4f4ae4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a0ee18f45de724791715223bab4f4ae4b">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0ee18f45de724791715223bab4f4ae4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying lower triangular matrix.  <a href="#a0ee18f45de724791715223bab4f4ae4b">More...</a><br /></td></tr>
<tr class="separator:a0ee18f45de724791715223bab4f4ae4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cab4eaa84bf6d2ad927578742b8304"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a25cab4eaa84bf6d2ad927578742b8304"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a25cab4eaa84bf6d2ad927578742b8304">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a25cab4eaa84bf6d2ad927578742b8304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying upper triangular matrix.  <a href="#a25cab4eaa84bf6d2ad927578742b8304">More...</a><br /></td></tr>
<tr class="separator:a25cab4eaa84bf6d2ad927578742b8304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33223a9266cbcd3e7bdbef6b6bbb98ea"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a33223a9266cbcd3e7bdbef6b6bbb98ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a33223a9266cbcd3e7bdbef6b6bbb98ea">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a33223a9266cbcd3e7bdbef6b6bbb98ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying upper triangular matrix.  <a href="#a33223a9266cbcd3e7bdbef6b6bbb98ea">More...</a><br /></td></tr>
<tr class="separator:a33223a9266cbcd3e7bdbef6b6bbb98ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc36d4321b88c2f55ff7cc6eee0504cc"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:abc36d4321b88c2f55ff7cc6eee0504cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#abc36d4321b88c2f55ff7cc6eee0504cc">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:abc36d4321b88c2f55ff7cc6eee0504cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying upper triangular matrix.  <a href="#abc36d4321b88c2f55ff7cc6eee0504cc">More...</a><br /></td></tr>
<tr class="separator:abc36d4321b88c2f55ff7cc6eee0504cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac063e557defc24fa3843905ee960bb32"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:ac063e557defc24fa3843905ee960bb32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ac063e557defc24fa3843905ee960bb32">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac063e557defc24fa3843905ee960bb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying upper triangular matrix.  <a href="#ac063e557defc24fa3843905ee960bb32">More...</a><br /></td></tr>
<tr class="separator:ac063e557defc24fa3843905ee960bb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664e48d7f2525b633daee76fa6e60053"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a664e48d7f2525b633daee76fa6e60053"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a664e48d7f2525b633daee76fa6e60053">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a664e48d7f2525b633daee76fa6e60053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying diagonal matrix.  <a href="#a664e48d7f2525b633daee76fa6e60053">More...</a><br /></td></tr>
<tr class="separator:a664e48d7f2525b633daee76fa6e60053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40e06643c2aa96b8d1de37d71735651"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:ad40e06643c2aa96b8d1de37d71735651"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad40e06643c2aa96b8d1de37d71735651">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad40e06643c2aa96b8d1de37d71735651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying diagonal matrix.  <a href="#ad40e06643c2aa96b8d1de37d71735651">More...</a><br /></td></tr>
<tr class="separator:ad40e06643c2aa96b8d1de37d71735651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5747257be187c38c44f4868eda29abc"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:ad5747257be187c38c44f4868eda29abc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad5747257be187c38c44f4868eda29abc">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad5747257be187c38c44f4868eda29abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying diagonal matrix.  <a href="#ad5747257be187c38c44f4868eda29abc">More...</a><br /></td></tr>
<tr class="separator:ad5747257be187c38c44f4868eda29abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdc0a2b5f2f21195f0ec770d1bb62c9"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a7bdc0a2b5f2f21195f0ec770d1bb62c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a7bdc0a2b5f2f21195f0ec770d1bb62c9">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7bdc0a2b5f2f21195f0ec770d1bb62c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying diagonal matrix.  <a href="#a7bdc0a2b5f2f21195f0ec770d1bb62c9">More...</a><br /></td></tr>
<tr class="separator:a7bdc0a2b5f2f21195f0ec770d1bb62c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a540a2c4c893ac8d4842bbbfd19a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#af6a540a2c4c893ac8d4842bbbfd19a61">operator~</a> ()</td></tr>
<tr class="memdesc:af6a540a2c4c893ac8d4842bbbfd19a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for non-constant matrices.  <a href="#af6a540a2c4c893ac8d4842bbbfd19a61">More...</a><br /></td></tr>
<tr class="separator:af6a540a2c4c893ac8d4842bbbfd19a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71becdce9e44bcba62ee6458c6f5a6fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a71becdce9e44bcba62ee6458c6f5a6fb">operator~</a> () const</td></tr>
<tr class="memdesc:a71becdce9e44bcba62ee6458c6f5a6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for constant matrices.  <a href="#a71becdce9e44bcba62ee6458c6f5a6fb">More...</a><br /></td></tr>
<tr class="separator:a71becdce9e44bcba62ee6458c6f5a6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a5e2da4f490c23ada35e43f0faac4a523"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a5e2da4f490c23ada35e43f0faac4a523">SparseSubmatrix</a> (<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#af1ded03b2e6218c66c3e13e4b8caee0e">Operand</a> matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:a5e2da4f490c23ada35e43f0faac4a523"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor for <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html" title="View on a specific submatrix of a sparse matrix.The SparseSubmatrix template represents a view on a s...">SparseSubmatrix</a>.  <a href="#a5e2da4f490c23ada35e43f0faac4a523">More...</a><br /></td></tr>
<tr class="separator:a5e2da4f490c23ada35e43f0faac4a523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access functions</div></td></tr>
<tr class="memitem:a3f0c34471e288f409d53a2660a26ddfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a73ab2d5ad6e142226599f059d621d2eb">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a3f0c34471e288f409d53a2660a26ddfd">operator()</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="memdesc:a3f0c34471e288f409d53a2660a26ddfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D-access to the sparse submatrix elements.  <a href="#a3f0c34471e288f409d53a2660a26ddfd">More...</a><br /></td></tr>
<tr class="separator:a3f0c34471e288f409d53a2660a26ddfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4f1951840e28a972d660d12fcf49a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad569e64dcdbc66ad1ab22f78d70f803e">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a7f4f1951840e28a972d660d12fcf49a2">operator()</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const </td></tr>
<tr class="memdesc:a7f4f1951840e28a972d660d12fcf49a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D-access to the sparse submatrix elements.  <a href="#a7f4f1951840e28a972d660d12fcf49a2">More...</a><br /></td></tr>
<tr class="separator:a7f4f1951840e28a972d660d12fcf49a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ccc7294d1a9351333d3745cff2c09e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ac3ccc7294d1a9351333d3745cff2c09e">begin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ac3ccc7294d1a9351333d3745cff2c09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first non-zero element of row/column <em>i</em>.  <a href="#ac3ccc7294d1a9351333d3745cff2c09e">More...</a><br /></td></tr>
<tr class="separator:ac3ccc7294d1a9351333d3745cff2c09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af217989027f8fd47dcc2529421a58be7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#af217989027f8fd47dcc2529421a58be7">begin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:af217989027f8fd47dcc2529421a58be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first non-zero element of row/column <em>i</em>.  <a href="#af217989027f8fd47dcc2529421a58be7">More...</a><br /></td></tr>
<tr class="separator:af217989027f8fd47dcc2529421a58be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25336e80e7d4381e2cc934441768977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#af25336e80e7d4381e2cc934441768977">cbegin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:af25336e80e7d4381e2cc934441768977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first non-zero element of row/column <em>i</em>.  <a href="#af25336e80e7d4381e2cc934441768977">More...</a><br /></td></tr>
<tr class="separator:af25336e80e7d4381e2cc934441768977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c5b86d48daf666bc7fe257a818f94e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad9c5b86d48daf666bc7fe257a818f94e">end</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:ad9c5b86d48daf666bc7fe257a818f94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last non-zero element of row/column <em>i</em>.  <a href="#ad9c5b86d48daf666bc7fe257a818f94e">More...</a><br /></td></tr>
<tr class="separator:ad9c5b86d48daf666bc7fe257a818f94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75bed0de6e456ffedc69c1f00cc0705"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ac75bed0de6e456ffedc69c1f00cc0705">end</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:ac75bed0de6e456ffedc69c1f00cc0705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last non-zero element of row/column <em>i</em>.  <a href="#ac75bed0de6e456ffedc69c1f00cc0705">More...</a><br /></td></tr>
<tr class="separator:ac75bed0de6e456ffedc69c1f00cc0705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc1ca52d85b66f3f9bbe8fd53cad756"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a5bc1ca52d85b66f3f9bbe8fd53cad756">cend</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:a5bc1ca52d85b66f3f9bbe8fd53cad756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last non-zero element of row/column <em>i</em>.  <a href="#a5bc1ca52d85b66f3f9bbe8fd53cad756">More...</a><br /></td></tr>
<tr class="separator:a5bc1ca52d85b66f3f9bbe8fd53cad756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment operators</div></td></tr>
<tr class="memitem:af2efa2eb18305ecb556893ae0ca9dee4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#af2efa2eb18305ecb556893ae0ca9dee4">operator=</a> (const <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a> &amp;rhs)</td></tr>
<tr class="memdesc:af2efa2eb18305ecb556893ae0ca9dee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html" title="View on a specific submatrix of a sparse matrix.The SparseSubmatrix template represents a view on a s...">SparseSubmatrix</a>.  <a href="#af2efa2eb18305ecb556893ae0ca9dee4">More...</a><br /></td></tr>
<tr class="separator:af2efa2eb18305ecb556893ae0ca9dee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74147f7421614180e14a002edbe313f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac74147f7421614180e14a002edbe313f"></a>
template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ac74147f7421614180e14a002edbe313f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:ac74147f7421614180e14a002edbe313f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc86e9bfe2bc553a51596994f8d86c84"><td class="memTemplParams" colspan="2"><a class="anchor" id="abc86e9bfe2bc553a51596994f8d86c84"></a>
template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:abc86e9bfe2bc553a51596994f8d86c84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:abc86e9bfe2bc553a51596994f8d86c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0317bbf51d8dc6ff46860144d74f141"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac0317bbf51d8dc6ff46860144d74f141"></a>
template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:ac0317bbf51d8dc6ff46860144d74f141"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:ac0317bbf51d8dc6ff46860144d74f141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78217589eba6c901b2eaf4d91fc8cec2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a78217589eba6c901b2eaf4d91fc8cec2"></a>
template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:a78217589eba6c901b2eaf4d91fc8cec2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a78217589eba6c901b2eaf4d91fc8cec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff174c5af6397fdaf06444ac4b981f81"><td class="memTemplParams" colspan="2"><a class="anchor" id="aff174c5af6397fdaf06444ac4b981f81"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:aff174c5af6397fdaf06444ac4b981f81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (Other rhs)</td></tr>
<tr class="separator:aff174c5af6397fdaf06444ac4b981f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c80d4f169bc18c1a3d436be185353d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a19c80d4f169bc18c1a3d436be185353d"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a19c80d4f169bc18c1a3d436be185353d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (Other rhs)</td></tr>
<tr class="separator:a19c80d4f169bc18c1a3d436be185353d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Lookup functions</div></td></tr>
<tr class="memitem:a3af55d228199f73e594cad285c51aba2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a3af55d228199f73e594cad285c51aba2">find</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="memdesc:a3af55d228199f73e594cad285c51aba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a specific submatrix element.  <a href="#a3af55d228199f73e594cad285c51aba2">More...</a><br /></td></tr>
<tr class="separator:a3af55d228199f73e594cad285c51aba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca29d4eb845515e81dbec535da3f84f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a9ca29d4eb845515e81dbec535da3f84f">find</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const </td></tr>
<tr class="memdesc:a9ca29d4eb845515e81dbec535da3f84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a specific submatrix element.  <a href="#a9ca29d4eb845515e81dbec535da3f84f">More...</a><br /></td></tr>
<tr class="separator:a9ca29d4eb845515e81dbec535da3f84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288d4acddc6f5dbfd674c1b9afb05bca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a288d4acddc6f5dbfd674c1b9afb05bca">lowerBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="memdesc:a288d4acddc6f5dbfd674c1b9afb05bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index not less then the given index.  <a href="#a288d4acddc6f5dbfd674c1b9afb05bca">More...</a><br /></td></tr>
<tr class="separator:a288d4acddc6f5dbfd674c1b9afb05bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e8a7db94471e2b7f9fab1352610a12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad8e8a7db94471e2b7f9fab1352610a12">lowerBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const </td></tr>
<tr class="memdesc:ad8e8a7db94471e2b7f9fab1352610a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index not less then the given index.  <a href="#ad8e8a7db94471e2b7f9fab1352610a12">More...</a><br /></td></tr>
<tr class="separator:ad8e8a7db94471e2b7f9fab1352610a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1371fb8908776cda8efa4892d4cc7a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a1371fb8908776cda8efa4892d4cc7a21">upperBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="memdesc:a1371fb8908776cda8efa4892d4cc7a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index greater then the given index.  <a href="#a1371fb8908776cda8efa4892d4cc7a21">More...</a><br /></td></tr>
<tr class="separator:a1371fb8908776cda8efa4892d4cc7a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12ea65bec868bb59bc29f22f6481378"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ae12ea65bec868bb59bc29f22f6481378">upperBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const </td></tr>
<tr class="memdesc:ae12ea65bec868bb59bc29f22f6481378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index greater then the given index.  <a href="#ae12ea65bec868bb59bc29f22f6481378">More...</a><br /></td></tr>
<tr class="separator:ae12ea65bec868bb59bc29f22f6481378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low-level utility functions</div></td></tr>
<tr class="memitem:a087c32f6b256c04457e88129aa06d3c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a087c32f6b256c04457e88129aa06d3c8">append</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a553ac461dc0b491cd44be7e96f1b5317">ElementType</a> &amp;value, bool check=false)</td></tr>
<tr class="memdesc:a087c32f6b256c04457e88129aa06d3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appending an element to the specified row/column of the sparse submatrix.  <a href="#a087c32f6b256c04457e88129aa06d3c8">More...</a><br /></td></tr>
<tr class="separator:a087c32f6b256c04457e88129aa06d3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccee02e131f1fa0f8d1be1c6f3d83d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#afccee02e131f1fa0f8d1be1c6f3d83d7">finalize</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:afccee02e131f1fa0f8d1be1c6f3d83d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizing the element insertion of a row/column.  <a href="#afccee02e131f1fa0f8d1be1c6f3d83d7">More...</a><br /></td></tr>
<tr class="separator:afccee02e131f1fa0f8d1be1c6f3d83d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression template evaluation functions</div></td></tr>
<tr class="memitem:a0f5d1be05f7f89ed26cb85dc4ffd2e63"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a0f5d1be05f7f89ed26cb85dc4ffd2e63"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a0f5d1be05f7f89ed26cb85dc4ffd2e63">canAlias</a> (const Other *alias) const </td></tr>
<tr class="memdesc:a0f5d1be05f7f89ed26cb85dc4ffd2e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the submatrix can alias with the given address <em>alias</em>.  <a href="#a0f5d1be05f7f89ed26cb85dc4ffd2e63">More...</a><br /></td></tr>
<tr class="separator:a0f5d1be05f7f89ed26cb85dc4ffd2e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a67f6e1885718d95f4c62c4976f8db"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a07a67f6e1885718d95f4c62c4976f8db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a07a67f6e1885718d95f4c62c4976f8db">isAliased</a> (const Other *alias) const </td></tr>
<tr class="memdesc:a07a67f6e1885718d95f4c62c4976f8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the submatrix is aliased with the given address <em>alias</em>.  <a href="#a07a67f6e1885718d95f4c62c4976f8db">More...</a><br /></td></tr>
<tr class="separator:a07a67f6e1885718d95f4c62c4976f8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15c045cd6646176f960420f7e3bb656"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ae15c045cd6646176f960420f7e3bb656">canSMPAssign</a> () const </td></tr>
<tr class="memdesc:ae15c045cd6646176f960420f7e3bb656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the submatrix can be used in SMP assignments.  <a href="#ae15c045cd6646176f960420f7e3bb656">More...</a><br /></td></tr>
<tr class="separator:ae15c045cd6646176f960420f7e3bb656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b611bb991b39d9cf45ab0ebfe9d2d95"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:a6b611bb991b39d9cf45ab0ebfe9d2d95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a6b611bb991b39d9cf45ab0ebfe9d2d95">assign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6b611bb991b39d9cf45ab0ebfe9d2d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a dense matrix.  <a href="#a6b611bb991b39d9cf45ab0ebfe9d2d95">More...</a><br /></td></tr>
<tr class="separator:a6b611bb991b39d9cf45ab0ebfe9d2d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f1f524e0974dfa1f9c225e8fff042c"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:a05f1f524e0974dfa1f9c225e8fff042c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a05f1f524e0974dfa1f9c225e8fff042c">assign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a05f1f524e0974dfa1f9c225e8fff042c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a row-major sparse matrix.  <a href="#a05f1f524e0974dfa1f9c225e8fff042c">More...</a><br /></td></tr>
<tr class="separator:a05f1f524e0974dfa1f9c225e8fff042c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f982272b9bf61393eaed8c0eae864f"><td class="memTemplParams" colspan="2">template&lt;typename MT2 &gt; </td></tr>
<tr class="memitem:a51f982272b9bf61393eaed8c0eae864f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a51f982272b9bf61393eaed8c0eae864f">assign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a51f982272b9bf61393eaed8c0eae864f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a column-major sparse matrix.  <a href="#a51f982272b9bf61393eaed8c0eae864f">More...</a><br /></td></tr>
<tr class="separator:a51f982272b9bf61393eaed8c0eae864f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3169db385ed6dd05ae3594a915bcf8c"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:aa3169db385ed6dd05ae3594a915bcf8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#aa3169db385ed6dd05ae3594a915bcf8c">addAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa3169db385ed6dd05ae3594a915bcf8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a dense matrix.  <a href="#aa3169db385ed6dd05ae3594a915bcf8c">More...</a><br /></td></tr>
<tr class="separator:aa3169db385ed6dd05ae3594a915bcf8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1657e3c7575e0ad072036dce7a8bf0bb"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:a1657e3c7575e0ad072036dce7a8bf0bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a1657e3c7575e0ad072036dce7a8bf0bb">addAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1657e3c7575e0ad072036dce7a8bf0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a sparse matrix.  <a href="#a1657e3c7575e0ad072036dce7a8bf0bb">More...</a><br /></td></tr>
<tr class="separator:a1657e3c7575e0ad072036dce7a8bf0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8a12d49a52f676b66f18996ecad378"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:a9f8a12d49a52f676b66f18996ecad378"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a9f8a12d49a52f676b66f18996ecad378">subAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9f8a12d49a52f676b66f18996ecad378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a dense matrix.  <a href="#a9f8a12d49a52f676b66f18996ecad378">More...</a><br /></td></tr>
<tr class="separator:a9f8a12d49a52f676b66f18996ecad378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd489acd891c681cfe13f0aea8844e5"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2&gt; </td></tr>
<tr class="memitem:a2bd489acd891c681cfe13f0aea8844e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2bd489acd891c681cfe13f0aea8844e5">subAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2bd489acd891c681cfe13f0aea8844e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a sparse matrix.  <a href="#a2bd489acd891c681cfe13f0aea8844e5">More...</a><br /></td></tr>
<tr class="separator:a2bd489acd891c681cfe13f0aea8844e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:gafe165cb7f345f96a069eb8d6feda7db6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>useConst</b> = IsConst&lt;MT&gt;::value
 }</td></tr>
<tr class="memdesc:gafe165cb7f345f96a069eb8d6feda7db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the non-const reference and iterator types.  <a href="../../d8/d94/group__sparse__submatrix.html#gafe165cb7f345f96a069eb8d6feda7db6">More...</a><br /></td></tr>
<tr class="separator:gafe165cb7f345f96a069eb8d6feda7db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ded03b2e6218c66c3e13e4b8caee0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1ded03b2e6218c66c3e13e4b8caee0e"></a>
typedef <a class="el" href="../../d7/d0c/structblaze_1_1If.html">If</a>&lt; <a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html">IsExpression</a>&lt; MT &gt;, MT, MT &amp; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#af1ded03b2e6218c66c3e13e4b8caee0e">Operand</a></td></tr>
<tr class="memdesc:af1ded03b2e6218c66c3e13e4b8caee0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite data type of the dense matrix expression. <br /></td></tr>
<tr class="separator:af1ded03b2e6218c66c3e13e4b8caee0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:a91d2f45c303286daab039c6ffaf1ae2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91d2f45c303286daab039c6ffaf1ae2d"></a>
<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#af1ded03b2e6218c66c3e13e4b8caee0e">Operand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a91d2f45c303286daab039c6ffaf1ae2d">matrix_</a></td></tr>
<tr class="memdesc:a91d2f45c303286daab039c6ffaf1ae2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sparse matrix containing the submatrix. <br /></td></tr>
<tr class="separator:a91d2f45c303286daab039c6ffaf1ae2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38950e9fa1c4803c1461039993b66db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa38950e9fa1c4803c1461039993b66db"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#aa38950e9fa1c4803c1461039993b66db">row_</a></td></tr>
<tr class="memdesc:aa38950e9fa1c4803c1461039993b66db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first row of the submatrix. <br /></td></tr>
<tr class="separator:aa38950e9fa1c4803c1461039993b66db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a7b499fc9132a57983ffbc0d70bda9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7a7b499fc9132a57983ffbc0d70bda9"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ae7a7b499fc9132a57983ffbc0d70bda9">column_</a></td></tr>
<tr class="memdesc:ae7a7b499fc9132a57983ffbc0d70bda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first column of the submatrix. <br /></td></tr>
<tr class="separator:ae7a7b499fc9132a57983ffbc0d70bda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ed4a486add381f7166f10412d1e06c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51ed4a486add381f7166f10412d1e06c"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a51ed4a486add381f7166f10412d1e06c">m_</a></td></tr>
<tr class="memdesc:a51ed4a486add381f7166f10412d1e06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of rows of the submatrix. <br /></td></tr>
<tr class="separator:a51ed4a486add381f7166f10412d1e06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a88d0d2e7da118ff5f80da5563b667"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23a88d0d2e7da118ff5f80da5563b667"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a23a88d0d2e7da118ff5f80da5563b667">n_</a></td></tr>
<tr class="memdesc:a23a88d0d2e7da118ff5f80da5563b667"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of columns of the submatrix. <br /></td></tr>
<tr class="separator:a23a88d0d2e7da118ff5f80da5563b667"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Utility functions</h2></td></tr>
<tr class="memitem:a2ee5245021a866633c2ce607b9f45163"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2ee5245021a866633c2ce607b9f45163">rows</a> () const </td></tr>
<tr class="memdesc:a2ee5245021a866633c2ce607b9f45163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows of the sparse submatrix.  <a href="#a2ee5245021a866633c2ce607b9f45163">More...</a><br /></td></tr>
<tr class="separator:a2ee5245021a866633c2ce607b9f45163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e448d68fc5d239262f9888a478642ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2e448d68fc5d239262f9888a478642ab">columns</a> () const </td></tr>
<tr class="memdesc:a2e448d68fc5d239262f9888a478642ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns of the sparse submatrix.  <a href="#a2e448d68fc5d239262f9888a478642ab">More...</a><br /></td></tr>
<tr class="separator:a2e448d68fc5d239262f9888a478642ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3830cf8e42aed22e4932928d29e0ac44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a3830cf8e42aed22e4932928d29e0ac44">capacity</a> () const </td></tr>
<tr class="memdesc:a3830cf8e42aed22e4932928d29e0ac44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the sparse submatrix.  <a href="#a3830cf8e42aed22e4932928d29e0ac44">More...</a><br /></td></tr>
<tr class="separator:a3830cf8e42aed22e4932928d29e0ac44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859d36d95a65e516bfe3a765538bb527"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a859d36d95a65e516bfe3a765538bb527">capacity</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:a859d36d95a65e516bfe3a765538bb527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the specified row/column.  <a href="#a859d36d95a65e516bfe3a765538bb527">More...</a><br /></td></tr>
<tr class="separator:a859d36d95a65e516bfe3a765538bb527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2534556460f30db297ca5fc6ad90aa7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2534556460f30db297ca5fc6ad90aa7c">nonZeros</a> () const </td></tr>
<tr class="memdesc:a2534556460f30db297ca5fc6ad90aa7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the sparse submatrix.  <a href="#a2534556460f30db297ca5fc6ad90aa7c">More...</a><br /></td></tr>
<tr class="separator:a2534556460f30db297ca5fc6ad90aa7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecebc96a4aa86ec4c3006a8f689419b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#abecebc96a4aa86ec4c3006a8f689419b">nonZeros</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:abecebc96a4aa86ec4c3006a8f689419b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the specified row/column.  <a href="#abecebc96a4aa86ec4c3006a8f689419b">More...</a><br /></td></tr>
<tr class="separator:abecebc96a4aa86ec4c3006a8f689419b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6050c0c43bc5e311bf29c72fa67af7e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a6050c0c43bc5e311bf29c72fa67af7e3">reset</a> ()</td></tr>
<tr class="memdesc:a6050c0c43bc5e311bf29c72fa67af7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to the default initial values.  <a href="#a6050c0c43bc5e311bf29c72fa67af7e3">More...</a><br /></td></tr>
<tr class="separator:a6050c0c43bc5e311bf29c72fa67af7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44358e4bb9119b19b657fb4bf6183345"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a44358e4bb9119b19b657fb4bf6183345">reset</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:a44358e4bb9119b19b657fb4bf6183345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column to the default initial values.  <a href="#a44358e4bb9119b19b657fb4bf6183345">More...</a><br /></td></tr>
<tr class="separator:a44358e4bb9119b19b657fb4bf6183345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf09d283c5eef27446a1e8c0eba1e817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#acf09d283c5eef27446a1e8c0eba1e817">set</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a553ac461dc0b491cd44be7e96f1b5317">ElementType</a> &amp;value)</td></tr>
<tr class="memdesc:acf09d283c5eef27446a1e8c0eba1e817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an element of the sparse submatrix.  <a href="#acf09d283c5eef27446a1e8c0eba1e817">More...</a><br /></td></tr>
<tr class="separator:acf09d283c5eef27446a1e8c0eba1e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49406ff8da9d228d4c6f667bafca7ef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a49406ff8da9d228d4c6f667bafca7ef3">insert</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a553ac461dc0b491cd44be7e96f1b5317">ElementType</a> &amp;value)</td></tr>
<tr class="memdesc:a49406ff8da9d228d4c6f667bafca7ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserting an element into the sparse submatrix.  <a href="#a49406ff8da9d228d4c6f667bafca7ef3">More...</a><br /></td></tr>
<tr class="separator:a49406ff8da9d228d4c6f667bafca7ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9507f66208fb7a66f7b4fb97719cc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a5d9507f66208fb7a66f7b4fb97719cc4">erase</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="memdesc:a5d9507f66208fb7a66f7b4fb97719cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing an element from the sparse submatrix.  <a href="#a5d9507f66208fb7a66f7b4fb97719cc4">More...</a><br /></td></tr>
<tr class="separator:a5d9507f66208fb7a66f7b4fb97719cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f86342d13c6696c92cc226b8ae1a92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a20f86342d13c6696c92cc226b8ae1a92">erase</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a> pos)</td></tr>
<tr class="memdesc:a20f86342d13c6696c92cc226b8ae1a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing an element from the sparse submatrix.  <a href="#a20f86342d13c6696c92cc226b8ae1a92">More...</a><br /></td></tr>
<tr class="separator:a20f86342d13c6696c92cc226b8ae1a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f71eba9414bb580cd40dd6afb16fe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad6f71eba9414bb580cd40dd6afb16fe3">erase</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a> first, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a> last)</td></tr>
<tr class="memdesc:ad6f71eba9414bb580cd40dd6afb16fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing a range of elements from the sparse submatrix.  <a href="#ad6f71eba9414bb580cd40dd6afb16fe3">More...</a><br /></td></tr>
<tr class="separator:ad6f71eba9414bb580cd40dd6afb16fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9513fb5d34843df50953c3cc860d9d12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a9513fb5d34843df50953c3cc860d9d12">reserve</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> nonzeros)</td></tr>
<tr class="memdesc:a9513fb5d34843df50953c3cc860d9d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the minimum capacity of the sparse submatrix.  <a href="#a9513fb5d34843df50953c3cc860d9d12">More...</a><br /></td></tr>
<tr class="separator:a9513fb5d34843df50953c3cc860d9d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7378ae6a6175cb89f33d93935ec8eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a8e7378ae6a6175cb89f33d93935ec8eb">reserve</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> nonzeros)</td></tr>
<tr class="memdesc:a8e7378ae6a6175cb89f33d93935ec8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the minimum capacity of a specific row/column of the sparse submatrix.  <a href="#a8e7378ae6a6175cb89f33d93935ec8eb">More...</a><br /></td></tr>
<tr class="separator:a8e7378ae6a6175cb89f33d93935ec8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5e33a8933463d0e6d3c70383c40572"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#aad5e33a8933463d0e6d3c70383c40572">trim</a> ()</td></tr>
<tr class="memdesc:aad5e33a8933463d0e6d3c70383c40572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removing all excessive capacity from all rows/columns.  <a href="#aad5e33a8933463d0e6d3c70383c40572">More...</a><br /></td></tr>
<tr class="separator:aad5e33a8933463d0e6d3c70383c40572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac06300bf8ce9fdf4c0205f80b7f2068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#aac06300bf8ce9fdf4c0205f80b7f2068">trim</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:aac06300bf8ce9fdf4c0205f80b7f2068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removing all excessive capacity of a specific row/column of the sparse matrix.  <a href="#aac06300bf8ce9fdf4c0205f80b7f2068">More...</a><br /></td></tr>
<tr class="separator:aac06300bf8ce9fdf4c0205f80b7f2068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abd1d530487699f53e891c65c57672f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a9abd1d530487699f53e891c65c57672f">transpose</a> ()</td></tr>
<tr class="memdesc:a9abd1d530487699f53e891c65c57672f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposing the submatrix.  <a href="#a9abd1d530487699f53e891c65c57672f">More...</a><br /></td></tr>
<tr class="separator:a9abd1d530487699f53e891c65c57672f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63237b687114bbc7b5a5e01943c4ca0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae63237b687114bbc7b5a5e01943c4ca0"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ae63237b687114bbc7b5a5e01943c4ca0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scale</b> (const Other &amp;scalar)</td></tr>
<tr class="separator:ae63237b687114bbc7b5a5e01943c4ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25eb15ae1607d0d125c741fc82b170a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a25eb15ae1607d0d125c741fc82b170a5">hasOverlap</a> () const </td></tr>
<tr class="memdesc:a25eb15ae1607d0d125c741fc82b170a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking whether there exists an overlap in the context of a symmetric matrix.  <a href="#a25eb15ae1607d0d125c741fc82b170a5">More...</a><br /></td></tr>
<tr class="separator:a25eb15ae1607d0d125c741fc82b170a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5350356f08685ecc2d0336d9ad9a57f0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5350356f08685ecc2d0336d9ad9a57f0"></a>
template&lt;typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:a5350356f08685ecc2d0336d9ad9a57f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt; MT2 &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT3, SO3 &gt; &amp;rhs)</td></tr>
<tr class="separator:a5350356f08685ecc2d0336d9ad9a57f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc78e2ba5fcbfa9d5648d5d0d80946e2"><td class="memTemplParams" colspan="2"><a class="anchor" id="acc78e2ba5fcbfa9d5648d5d0d80946e2"></a>
template&lt;typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </td></tr>
<tr class="memitem:acc78e2ba5fcbfa9d5648d5d0d80946e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT3, SO3 &gt; &amp;rhs)</td></tr>
<tr class="separator:acc78e2ba5fcbfa9d5648d5d0d80946e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a5ee7f8c1136b37c39b4698b311173"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac8a5ee7f8c1136b37c39b4698b311173"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:ac8a5ee7f8c1136b37c39b4698b311173"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="separator:ac8a5ee7f8c1136b37c39b4698b311173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b99ef8b5490556c89bfa39c54378283"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9b99ef8b5490556c89bfa39c54378283"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a9b99ef8b5490556c89bfa39c54378283"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a9b99ef8b5490556c89bfa39c54378283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd10bf13e9f3c17cf9ce53219e2fb77"><td class="memTemplParams" colspan="2"><a class="anchor" id="aadd10bf13e9f3c17cf9ce53219e2fb77"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:aadd10bf13e9f3c17cf9ce53219e2fb77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="separator:aadd10bf13e9f3c17cf9ce53219e2fb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee18f45de724791715223bab4f4ae4b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0ee18f45de724791715223bab4f4ae4b"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a0ee18f45de724791715223bab4f4ae4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a0ee18f45de724791715223bab4f4ae4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cab4eaa84bf6d2ad927578742b8304"><td class="memTemplParams" colspan="2"><a class="anchor" id="a25cab4eaa84bf6d2ad927578742b8304"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a25cab4eaa84bf6d2ad927578742b8304"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a25cab4eaa84bf6d2ad927578742b8304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33223a9266cbcd3e7bdbef6b6bbb98ea"><td class="memTemplParams" colspan="2"><a class="anchor" id="a33223a9266cbcd3e7bdbef6b6bbb98ea"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a33223a9266cbcd3e7bdbef6b6bbb98ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a33223a9266cbcd3e7bdbef6b6bbb98ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc36d4321b88c2f55ff7cc6eee0504cc"><td class="memTemplParams" colspan="2"><a class="anchor" id="abc36d4321b88c2f55ff7cc6eee0504cc"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:abc36d4321b88c2f55ff7cc6eee0504cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="separator:abc36d4321b88c2f55ff7cc6eee0504cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac063e557defc24fa3843905ee960bb32"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac063e557defc24fa3843905ee960bb32"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:ac063e557defc24fa3843905ee960bb32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="separator:ac063e557defc24fa3843905ee960bb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664e48d7f2525b633daee76fa6e60053"><td class="memTemplParams" colspan="2"><a class="anchor" id="a664e48d7f2525b633daee76fa6e60053"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a664e48d7f2525b633daee76fa6e60053"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a664e48d7f2525b633daee76fa6e60053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40e06643c2aa96b8d1de37d71735651"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad40e06643c2aa96b8d1de37d71735651"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:ad40e06643c2aa96b8d1de37d71735651"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="separator:ad40e06643c2aa96b8d1de37d71735651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5747257be187c38c44f4868eda29abc"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad5747257be187c38c44f4868eda29abc"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:ad5747257be187c38c44f4868eda29abc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;rhs)</td></tr>
<tr class="separator:ad5747257be187c38c44f4868eda29abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdc0a2b5f2f21195f0ec770d1bb62c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7bdc0a2b5f2f21195f0ec770d1bb62c9"></a>
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </td></tr>
<tr class="memitem:a7bdc0a2b5f2f21195f0ec770d1bb62c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a7bdc0a2b5f2f21195f0ec770d1bb62c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt;<br />
class blaze::SparseSubmatrix&lt; MT, AF, SO &gt;</h3>

<p><a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> on a specific submatrix of a sparse matrix.</p>
<p>The <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html" title="View on a specific submatrix of a sparse matrix.The SparseSubmatrix template represents a view on a s...">SparseSubmatrix</a> template represents a view on a specific submatrix of a sparse matrix primitive. The type of the sparse matrix is specified via the first template parameter: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MT, <span class="keywordtype">bool</span> AF, <span class="keywordtype">bool</span> SO &gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a5e2da4f490c23ada35e43f0faac4a523">SparseSubmatrix</a>;</div>
</div><!-- fragment --><ul>
<li>MT: specifies the type of the sparse matrix primitive. <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html" title="View on a specific submatrix of a sparse matrix.The SparseSubmatrix template represents a view on a s...">SparseSubmatrix</a> can be used with every sparse matrix primitive, but does not work with any matrix expression type.</li>
<li>AF: the alignment flag specifies whether the submatrix is aligned (<em><a class="el" href="../../d2/de9/namespaceblaze.html#a30a412c45e10cff7eba4dacc999d55c7" title="Alignment flag for aligned subvectors and submatrices. ">blaze::aligned</a></em>) or unaligned (<em><a class="el" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5" title="Alignment flag for unaligned subvectors and submatrices. ">blaze::unaligned</a></em>). The default value is <em><a class="el" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5" title="Alignment flag for unaligned subvectors and submatrices. ">blaze::unaligned</a></em>.</li>
<li>SO: specifies the storage order (<a class="el" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices. ">blaze::rowMajor</a>, <a class="el" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583" title="Storage order flag for column-major matrices. ">blaze::columnMajor</a>) of the sparse matrix. This template parameter doesn't have to be explicitly defined, but is automatically derived from the first template parameter.</li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="sparse_submatrix_setup"></a>
Setup of Sparse Submatrices</h1>
<p>A view on a sparse submatrix can be created very conveniently via the <code><a class="el" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a" title="Creating a view on a specific submatrix of the given matrix. ">submatrix()</a></code> function:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::rowMajor&gt;</a>  SparseMatrixType;</div>
<div class="line"></div>
<div class="line">SparseMatrixType A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a sparse submatrix of size 8x16, starting in row 0 and column 4</span></div>
<div class="line"><a class="code" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix&lt;SparseMatrixType&gt;</a> sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 0UL, 4UL, 8UL, 16UL );</div>
</div><!-- fragment --><p>This view can be treated as any other sparse matrix, i.e. it can be assigned to, it can be copied from, and it can be used in arithmetic operations. The view can also be used on both sides of an assignment: The submatrix can either be used as an alias to grant write access to a specific submatrix of a sparse matrix primitive on the left-hand side of an assignment or to grant read-access to a specific submatrix of a sparse matrix primitive or expression on the right-hand side of an assignment. The following example demonstrates this in detail:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::rowMajor&gt;</a>  SparseMatrixType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a>  DenseMatrixType;</div>
<div class="line"></div>
<div class="line">SparseMatrixType A, B;</div>
<div class="line">DenseMatrixType C;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a sparse submatrix of size 8x4, starting in row 0 and column 2</span></div>
<div class="line"><a class="code" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix&lt;SparseMatrixType&gt;</a> sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 0UL, 2UL, 8UL, 4UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the submatrix of A to a 8x4 submatrix of B</span></div>
<div class="line">sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( B, 0UL, 0UL, 8UL, 4UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Copying the dense matrix C into another 8x4 submatrix of A</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 8UL, 2UL, 8UL, 4UL ) = C;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Assigning part of the result of a matrix addition to the first submatrix</span></div>
<div class="line">sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( B + C, 0UL, 0UL, 8UL, 4UL );</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_submatrix_element_access"></a>
Element access</h1>
<p>A sparse submatrix can be used like any other sparse matrix. For instance, the elements of the sparse submatrix can be directly accessed with the function call operator:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::rowMajor&gt;</a>  <a class="code" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>;</div>
<div class="line">MatrixType A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a 8x8 submatrix, starting from position (4,4)</span></div>
<div class="line"><a class="code" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix&lt;MatrixType&gt;</a> sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 4UL, 4UL, 8UL, 8UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the element (0,0) of the submatrix, which corresponds to</span></div>
<div class="line"><span class="comment">// the element at position (4,4) in matrix A</span></div>
<div class="line">sm(0,0) = 2.0;</div>
</div><!-- fragment --><p>Alternatively, the elements of a submatrix can be traversed via (const) iterators. Just as with matrices, in case of non-const submatrices, <code><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ac3ccc7294d1a9351333d3745cff2c09e" title="Returns an iterator to the first non-zero element of row/column i. ">begin()</a></code> and <code><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad9c5b86d48daf666bc7fe257a818f94e" title="Returns an iterator just past the last non-zero element of row/column i. ">end()</a></code> return an Iterator, which allows a manipulation of the non-zero values, in case of constant submatrices a ConstIterator is returned:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a>  <a class="code" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix&lt;MatrixType&gt;</a>            SubmatrixType;</div>
<div class="line"></div>
<div class="line">MatrixType A( 256UL, 512UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a reference to a specific submatrix of matrix A</span></div>
<div class="line">SubmatrixType sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 16UL, 16UL, 64UL, 128UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Traversing the elements of the 0th row via iterators to non-const elements</span></div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">SubmatrixType::Iterator</a> it=sm.begin(0); it!=sm.end(0); ++it ) {</div>
<div class="line">   it-&gt;value() = ...;  <span class="comment">// OK: Write access to the value of the non-zero element.</span></div>
<div class="line">   ... = it-&gt;value();  <span class="comment">// OK: Read access to the value of the non-zero element.</span></div>
<div class="line">   it-&gt;index() = ...;  <span class="comment">// Compilation error: The index of a non-zero element cannot be changed.</span></div>
<div class="line">   ... = it-&gt;index();  <span class="comment">// OK: Read access to the index of the sparse element.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Traversing the elements of the 1st row via iterators to const elements</span></div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">SubmatrixType::ConstIterator</a> it=sm.begin(1); it!=sm.end(1); ++it ) {</div>
<div class="line">   it-&gt;value() = ...;  <span class="comment">// Compilation error: Assignment to the value via a ConstIterator is invalid.</span></div>
<div class="line">   ... = it-&gt;value();  <span class="comment">// OK: Read access to the value of the non-zero element.</span></div>
<div class="line">   it-&gt;index() = ...;  <span class="comment">// Compilation error: The index of a non-zero element cannot be changed.</span></div>
<div class="line">   ... = it-&gt;index();  <span class="comment">// OK: Read access to the index of the sparse element.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_submatrix_element_insertion"></a>
Element Insertion</h1>
<p>Inserting/accessing elements in a sparse submatrix can be done by several alternative functions. The following example demonstrates all options:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::rowMajor&gt;</a>  <a class="code" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>;</div>
<div class="line">MatrixType A( 256UL, 512UL );  <span class="comment">// Non-initialized matrix of size 256x512</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix&lt;MatrixType&gt;</a>  SubmatrixType;</div>
<div class="line">SubmatrixType sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 10UL, 10UL, 16UL, 16UL );  <span class="comment">// View on a 16x16 submatrix of A</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// The function call operator provides access to all possible elements of the sparse submatrix,</span></div>
<div class="line"><span class="comment">// including the zero elements. In case the subscript operator is used to access an element</span></div>
<div class="line"><span class="comment">// that is currently not stored in the sparse submatrix, the element is inserted into the</span></div>
<div class="line"><span class="comment">// submatrix.</span></div>
<div class="line">sm(2,4) = 2.0;</div>
<div class="line"></div>
<div class="line"><span class="comment">// The second operation for inserting elements is the set() function. In case the element is</span></div>
<div class="line"><span class="comment">// not contained in the submatrix it is inserted into the submatrix, if it is already contained</span></div>
<div class="line"><span class="comment">// in the submatrix its value is modified.</span></div>
<div class="line">sm.set( 2UL, 5UL, -1.2 );</div>
<div class="line"></div>
<div class="line"><span class="comment">// An alternative for inserting elements into the submatrix is the \c insert() function. However,</span></div>
<div class="line"><span class="comment">// it inserts the element only in case the element is not already contained in the submatrix.</span></div>
<div class="line">sm.insert( 2UL, 6UL, 3.7 );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Just as in the case of sparse matrices, elements can also be inserted via the \c append()</span></div>
<div class="line"><span class="comment">// function. In case of submatrices, \c append() also requires that the appended element&#39;s</span></div>
<div class="line"><span class="comment">// index is strictly larger than the currently largest non-zero index in the according row</span></div>
<div class="line"><span class="comment">// or column of the submatrix and that the according row&#39;s or column&#39;s capacity is large enough</span></div>
<div class="line"><span class="comment">// to hold the new element. Note however that due to the nature of a submatrix, which may be an</span></div>
<div class="line"><span class="comment">// alias to the middle of a sparse matrix, the \c append() function does not work as efficiently</span></div>
<div class="line"><span class="comment">// for a submatrix as it does for a matrix.</span></div>
<div class="line">sm.reserve( 2UL, 10UL );</div>
<div class="line">sm.append( 2UL, 10UL, -2.1 );</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_submatrix_common_operations"></a>
Common Operations</h1>
<p>The current size of the matrix, i.e. the number of rows or columns can be obtained via the <code><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2ee5245021a866633c2ce607b9f45163" title="Returns the number of rows of the sparse submatrix. ">rows()</a></code> and <code><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2e448d68fc5d239262f9888a478642ab" title="Returns the number of columns of the sparse submatrix. ">columns()</a></code> functions, the current total capacity via the <code><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a3830cf8e42aed22e4932928d29e0ac44" title="Returns the maximum capacity of the sparse submatrix. ">capacity()</a></code> function, and the number of non-zero elements via the <code><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2534556460f30db297ca5fc6ad90aa7c" title="Returns the number of non-zero elements in the sparse submatrix. ">nonZeros()</a></code> function. However, since submatrices are views on a specific submatrix of a matrix, several operations are not possible on views, such as resizing and swapping:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a>  <a class="code" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix&lt;MatrixType&gt;</a>            SubmatrixType;</div>
<div class="line"></div>
<div class="line">MatrixType A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a view on the a 8x12 submatrix of matrix A</span></div>
<div class="line">SubmatrixType sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 0UL, 0UL, 8UL, 12UL );</div>
<div class="line"></div>
<div class="line">sm.rows();      <span class="comment">// Returns the number of rows of the submatrix</span></div>
<div class="line">sm.columns();   <span class="comment">// Returns the number of columns of the submatrix</span></div>
<div class="line">sm.capacity();  <span class="comment">// Returns the capacity of the submatrix</span></div>
<div class="line">sm.nonZeros();  <span class="comment">// Returns the number of non-zero elements contained in the submatrix</span></div>
<div class="line"></div>
<div class="line">sm.resize( 10UL, 8UL );  <span class="comment">// Compilation error: Cannot resize a submatrix of a matrix</span></div>
<div class="line"></div>
<div class="line">SubmatrixType sm2 = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 8UL, 0UL, 12UL, 8UL );</div>
<div class="line"><a class="code" href="../../d0/d90/group__diagonal__matrix.html#ga172895200063f120b6ffd241af12bbae">swap</a>( sm, sm2 );  <span class="comment">// Compilation error: Swap operation not allowed</span></div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_submatrix_arithmetic_operations"></a>
Arithmetic Operations</h1>
<p>The following example gives an impression of the use of <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html" title="View on a specific submatrix of a sparse matrix.The SparseSubmatrix template represents a view on a s...">SparseSubmatrix</a> within arithmetic operations. All operations (addition, subtraction, multiplication, scaling, ...) can be performed on all possible combinations of dense and sparse matrices with fitting element types:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::rowMajor&gt;</a>  SparseMatrixType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a>     DenseMatrixType;</div>
<div class="line">SparseMatrixType S1, S2, S3;</div>
<div class="line">DenseMatrixType D1, D2;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;double,8UL,blaze::columnVector&gt;</a>  DenseVectorType;</div>
<div class="line">DenseVectorType a, b;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> SparseSubmatrix&lt;SparseMatrixType&gt;  SubmatrixType;</div>
<div class="line">SubmatrixType sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( S1, 0UL, 0UL, 8UL, 8UL );  <span class="comment">// View on the 8x8 submatrix of matrix S1</span></div>
<div class="line">                                                         <span class="comment">// starting from row 0 and column 0</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( S1, 0UL, 8UL, 8UL, 8UL ) = S2;  <span class="comment">// Sparse matrix initialization of the 8x8 submatrix</span></div>
<div class="line">                                           <span class="comment">// starting in row 0 and column 8</span></div>
<div class="line">sm = D1;                                   <span class="comment">// Dense matrix initialization of the second 8x8 submatrix</span></div>
<div class="line"></div>
<div class="line">S3 = sm + S2;                                    <span class="comment">// Sparse matrix/sparse matrix addition</span></div>
<div class="line">D2 = D1  - <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( S1, 8UL, 0UL, 8UL, 8UL );  <span class="comment">// Dense matrix/sparse matrix subtraction</span></div>
<div class="line">S2 = sm * <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( S1, 8UL, 8UL, 8UL, 8UL );   <span class="comment">// Sparse matrix/sparse matrix multiplication</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( S1, 8UL, 0UL, 8UL, 8UL ) *= 2.0;      <span class="comment">// In-place scaling of a submatrix of S1</span></div>
<div class="line">S2 = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( S1, 8UL, 8UL, 8UL, 8UL ) * 2.0;  <span class="comment">// Scaling of the a submatrix of S1</span></div>
<div class="line">S2 = 2.0 * sm;                                   <span class="comment">// Scaling of the a submatrix of S1</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( S1, 0UL, 8UL, 8UL, 8UL ) += S2;  <span class="comment">// Addition assignment</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( S1, 8UL, 0UL, 8UL, 8UL ) -= D1;  <span class="comment">// Subtraction assignment</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( S1, 8UL, 8UL, 8UL, 8UL ) *= sm;  <span class="comment">// Multiplication assignment</span></div>
<div class="line"></div>
<div class="line">a = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( S1, 4UL, 4UL, 8UL, 8UL ) * b;  <span class="comment">// Sparse matrix/dense vector multiplication</span></div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_submatrix_aligned_submatrix"></a>
Aligned Submatrices</h1>
<p>Usually submatrices can be defined anywhere within a matrix. They may start at any position and may have an arbitrary extension (only restricted by the extension of the underlying matrix). However, in contrast to matrices themselves, which are always properly aligned in memory and therefore can provide maximum performance, this means that submatrices in general have to be considered to be unaligned. This can be made explicit by the <em><a class="el" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5" title="Alignment flag for unaligned subvectors and submatrices. ">blaze::unaligned</a></em> flag:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5">blaze::unaligned</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::rowMajor&gt;</a>  SparseMatrixType;</div>
<div class="line"></div>
<div class="line">SparseMatrixType A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Identical creations of an unaligned submatrix of size 8x8, starting in row 0 and column 0</span></div>
<div class="line"><a class="code" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix&lt;SparseMatrixType&gt;</a>           sm1 = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>           ( A, 0UL, 0UL, 8UL, 8UL );</div>
<div class="line"><a class="code" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix&lt;SparseMatrixType&gt;</a>           sm2 = submatrix&lt;unaligned&gt;( A, 0UL, 0UL, 8UL, 8UL );</div>
<div class="line"><a class="code" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix&lt;SparseMatrixType,unaligned&gt;</a> sm3 = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>           ( A, 0UL, 0UL, 8UL, 8UL );</div>
<div class="line"><a class="code" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix&lt;SparseMatrixType,unaligned&gt;</a> sm4 = submatrix&lt;unaligned&gt;( A, 0UL, 0UL, 8UL, 8UL );</div>
</div><!-- fragment --><p>All of these calls to the <code><a class="el" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a" title="Creating a view on a specific submatrix of the given matrix. ">submatrix()</a></code> function are identical. Whether the alignment flag is explicitly specified or not, it always returns an unaligned submatrix. Whereas this may provide full flexibility in the creation of submatrices, this might result in performance restrictions (even in case the specified submatrix could be aligned). However, it is also possible to create aligned submatrices. Aligned submatrices are identical to unaligned submatrices in all aspects, except that they may pose additional alignment restrictions and therefore have less flexibility during creation, but don't suffer from performance penalties and provide the same performance as the underlying matrix. Aligned submatrices are created by explicitly specifying the <em><a class="el" href="../../d2/de9/namespaceblaze.html#a30a412c45e10cff7eba4dacc999d55c7" title="Alignment flag for aligned subvectors and submatrices. ">blaze::aligned</a></em> flag:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a30a412c45e10cff7eba4dacc999d55c7">blaze::aligned</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating an aligned submatrix of size 8x8, starting in row 0 and column 0</span></div>
<div class="line"><a class="code" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix&lt;SparseMatrixType,aligned&gt;</a> sv = submatrix&lt;aligned&gt;( A, 0UL, 0UL, 8UL, 8UL );</div>
</div><!-- fragment --><p>In contrast to dense submatrices, which pose several additional alignment restrictions based on the used element type, sparse submatrices at this time don't pose any additional restrictions. Therefore aligned and unaligned sparse submatrices are truly fully identical. Note however that this is not true for dense submatrices (see the <a class="el" href="../../d1/dc0/classblaze_1_1DenseSubmatrix.html" title="View on a specific submatrix of a dense matrix.The DenseSubmatrix template represents a view on a spe...">DenseSubmatrix</a> class description)!</p>
<p><br />
 </p>
<h1><a class="anchor" id="sparse_submatrix_on_sparse_submatrix"></a>
Submatrix on Submatrix</h1>
<p>It is also possible to create a submatrix view on another submatrix. In this context it is important to remember that the type returned by the <code><a class="el" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a" title="Creating a view on a specific submatrix of the given matrix. ">submatrix()</a></code> function is the same type as the type of the given submatrix, since the view on a submatrix is just another view on the underlying sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::rowMajor&gt;</a>  <a class="code" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix&lt;MatrixType&gt;</a>               SubmatrixType;</div>
<div class="line"></div>
<div class="line">MatrixType S1;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a submatrix view on the sparse matrix S1</span></div>
<div class="line">SubmatrixType sm1 = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( S1, 4UL, 4UL, 8UL, 16UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a submatrix view on the sparse submatrix sm1</span></div>
<div class="line">SubmatrixType sm2 = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( sm1, 1UL, 1UL, 4UL, 8UL );</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_submatrix_on_symmetric_matrices"></a>
Submatrix on Symmetric Matrices</h1>
<p>Submatrices can also be created on symmetric matrices (see the <a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html" title="Matrix adapter for symmetric  matrices. ">SymmetricMatrix</a> class template):</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">blaze::SymmetricMatrix</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> SymmetricMatrix&lt; CompressedMatrix&lt;int&gt; &gt;    SymmetricCompressedType;</div>
<div class="line"><span class="keyword">typedef</span> SparseSubmatrix&lt; SymmetricCompressedType &gt;  SubmatrixType;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setup of a 16x16 symmetric matrix</span></div>
<div class="line">SymmetricCompressedType A( 16UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a sparse submatrix of size 8x12, starting in row 2 and column 4</span></div>
<div class="line">SubmatrixType sm = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 2UL, 4UL, 8UL, 12UL );</div>
</div><!-- fragment --><p>It is important to note, however, that (compound) assignments to such submatrices have a special restriction: The symmetry of the underlying symmetric matrix must not be broken! Since the modification of element <img class="formulaInl" alt="$ a_{ij} $" src="../../form_11.png"/> of a symmetric matrix also modifies the element <img class="formulaInl" alt="$ a_{ji} $" src="../../form_12.png"/>, the matrix to be assigned must be structured such that the symmetry of the symmetric matrix is preserved. Otherwise a <em>std::invalid_argument</em> exception is thrown:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html">blaze::SymmetricMatrix</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setup of two default 4x4 symmetric matrices</span></div>
<div class="line">SymmetricMatrix&lt; CompressedMatrix&lt;int&gt; &gt; A1( 4 ), A2( 4 );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setup of the 3x2 compressed matrix</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//       ( 0 9 )</span></div>
<div class="line"><span class="comment">//   B = ( 9 8 )</span></div>
<div class="line"><span class="comment">//       ( 0 7 )</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">CompressedMatrix&lt;int&gt; B( 3UL, 2UL );</div>
<div class="line">B(0,0) = 1;</div>
<div class="line">B(0,1) = 2;</div>
<div class="line">B(1,0) = 3;</div>
<div class="line">B(1,1) = 4;</div>
<div class="line">B(2,1) = 5;</div>
<div class="line">B(2,2) = 6;</div>
<div class="line"></div>
<div class="line"><span class="comment">// OK: Assigning B to a submatrix of A1 such that the symmetry can be preserved</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//        ( 0 0 1 2 )</span></div>
<div class="line"><span class="comment">//   A1 = ( 0 0 3 4 )</span></div>
<div class="line"><span class="comment">//        ( 1 3 5 6 )</span></div>
<div class="line"><span class="comment">//        ( 2 4 6 0 )</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A1, 0UL, 2UL, 3UL, 2UL ) = B;  <span class="comment">// OK</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Error: Assigning B to a submatrix of A2 such that the symmetry cannot be preserved!</span></div>
<div class="line"><span class="comment">//   The elements marked with X cannot be assigned unambiguously!</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//        ( 0 1 2 0 )</span></div>
<div class="line"><span class="comment">//   A2 = ( 1 3 X 0 )</span></div>
<div class="line"><span class="comment">//        ( 2 X 6 0 )</span></div>
<div class="line"><span class="comment">//        ( 0 0 0 0 )</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A2, 0UL, 1UL, 3UL, 2UL ) = B;  <span class="comment">// Assignment throws an exception!</span></div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5e2da4f490c23ada35e43f0faac4a523"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#af1ded03b2e6218c66c3e13e4b8caee0e">Operand</a>&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constructor for <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html" title="View on a specific submatrix of a sparse matrix.The SparseSubmatrix template represents a view on a s...">SparseSubmatrix</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The sparse matrix containing the submatrix. </td></tr>
    <tr><td class="paramname">row</td><td>The index of the first row of the submatrix in the given sparse matrix. </td></tr>
    <tr><td class="paramname">column</td><td>The index of the first column of the submatrix in the given sparse matrix. </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows of the submatrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns of the submatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid submatrix specification.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the submatrix is not properly specified (i.e. if the specified submatrix is not contained in the given sparse matrix) a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa3169db385ed6dd05ae3594a915bcf8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a1657e3c7575e0ad072036dce7a8bf0bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a087c32f6b256c04457e88129aa06d3c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a553ac461dc0b491cd44be7e96f1b5317">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appending an element to the specified row/column of the sparse submatrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to be appended. </td></tr>
    <tr><td class="paramname">check</td><td><em>true</em> if the new value should be checked for default values, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function provides a very efficient way to fill a sparse submatrix with elements. It appends a new element to the end of the specified row/column without any additional memory allocation. Therefore it is strictly necessary to keep the following preconditions in mind:</p>
<ul>
<li>the index of the new element must be strictly larger than the largest index of non-zero elements in the specified row/column of the sparse submatrix</li>
<li>the current number of non-zero elements in the submatrix must be smaller than the capacity of the matrix</li>
</ul>
<p>Ignoring these preconditions might result in undefined behavior! The optional <em>check</em> parameter specifies whether the new value should be tested for a default value. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the new value is a default value (for instance 0 in case of an integral element type) the value is not appended. Per default the values are not tested.</p>
<p>In combination with the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a9513fb5d34843df50953c3cc860d9d12" title="Setting the minimum capacity of the sparse submatrix. ">reserve()</a> and the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#afccee02e131f1fa0f8d1be1c6f3d83d7" title="Finalizing the element insertion of a row/column. ">finalize()</a> function, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a087c32f6b256c04457e88129aa06d3c8" title="Appending an element to the specified row/column of the sparse submatrix. ">append()</a> provides the most efficient way to add new elements to a sparse submatrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a>  <a class="code" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix&lt;MatrixType&gt;</a>        SubmatrixType;</div>
<div class="line"></div>
<div class="line">MatrixType A( 42, 54 );</div>
<div class="line">SubmatrixType B = <a class="code" href="../../d0/d48/group__views.html#gad9059fed5550a8c5f1b9befa3ac9a38a">submatrix</a>( A, 10, 10, 4, 3 );</div>
<div class="line"></div>
<div class="line">B.reserve( 3 );         <span class="comment">// Reserving enough capacity for 3 non-zero elements</span></div>
<div class="line">B.append( 0, 1, 1.0 );  <span class="comment">// Appending the value 1 in row 0 with column index 1</span></div>
<div class="line">B.finalize( 0 );        <span class="comment">// Finalizing row 0</span></div>
<div class="line">B.append( 1, 1, 2.0 );  <span class="comment">// Appending the value 2 in row 1 with column index 1</span></div>
<div class="line">B.finalize( 1 );        <span class="comment">// Finalizing row 1</span></div>
<div class="line">B.finalize( 2 );        <span class="comment">// Finalizing the empty row 2 to prepare row 3</span></div>
<div class="line">B.append( 3, 0, 3.0 );  <span class="comment">// Appending the value 3 in row 3 with column index 0</span></div>
<div class="line">B.finalize( 3 );        <span class="comment">// Finalizing row 3</span></div>
</div><!-- fragment --><p><b>Note:</b> Although <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a087c32f6b256c04457e88129aa06d3c8" title="Appending an element to the specified row/column of the sparse submatrix. ">append()</a> does not allocate new memory, it still invalidates all iterators returned by the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad9c5b86d48daf666bc7fe257a818f94e" title="Returns an iterator just past the last non-zero element of row/column i. ">end()</a> functions! </p>

</div>
</div>
<a class="anchor" id="a6b611bb991b39d9cf45ab0ebfe9d2d95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a05f1f524e0974dfa1f9c225e8fff042c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a51f982272b9bf61393eaed8c0eae864f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ac3ccc7294d1a9351333d3745cff2c09e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first non-zero element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first non-zero element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first non-zero element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="af217989027f8fd47dcc2529421a58be7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first non-zero element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first non-zero element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first non-zero element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a0f5d1be05f7f89ed26cb85dc4ffd2e63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::canAlias </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the submatrix can alias with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this submatrix, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address can alias with the submatrix. In contrast to the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a07a67f6e1885718d95f4c62c4976f8db" title="Returns whether the submatrix is aliased with the given address alias. ">isAliased()</a> function this function is allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="ae15c045cd6646176f960420f7e3bb656"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::canSMPAssign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the submatrix can be used in SMP assignments. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the submatrix can be used in SMP assignments, <em>false</em> if not.</dd></dl>
<p>This function returns whether the submatrix can be used in SMP assignments. In contrast to the <em>smpAssignable</em> member enumeration, which is based solely on compile time information, this function additionally provides runtime information (as for instance the current number of rows and/or columns of the matrix). </p>

</div>
</div>
<a class="anchor" id="a3830cf8e42aed22e4932928d29e0ac44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the sparse submatrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the sparse submatrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a859d36d95a65e516bfe3a765538bb527"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current capacity of the specified row/column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current capacity of row/column <em>i</em>.</dd></dl>
<p>This function returns the current capacity of the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the capacity of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the capacity of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="af25336e80e7d4381e2cc934441768977"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first non-zero element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first non-zero element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first non-zero element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a5bc1ca52d85b66f3f9bbe8fd53cad756"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last non-zero element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last non-zero element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last non-zero element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a2e448d68fc5d239262f9888a478642ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns of the sparse submatrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of columns of the sparse submatrix. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9c5b86d48daf666bc7fe257a818f94e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last non-zero element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last non-zero element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last non-zero element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="ac75bed0de6e456ffedc69c1f00cc0705"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last non-zero element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last non-zero element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last non-zero element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last non-zero element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last non-zero element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a5d9507f66208fb7a66f7b4fb97719cc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing an element from the sparse submatrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the element to be erased. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the element to be erased. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function erases an element from the sparse submatrix. </p>

</div>
</div>
<a class="anchor" id="a20f86342d13c6696c92cc226b8ae1a92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing an element from the sparse submatrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index of the element to be erased. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">pos</td><td>Iterator to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element after the erased element.</dd></dl>
<p>This function erases an element from the sparse submatrix. In case the storage order is set to <em>rowMajor</em> the function erases an element from row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function erases an element from column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="ad6f71eba9414bb580cd40dd6afb16fe3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing a range of elements from the sparse submatrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index of the element to be erased. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to first element to be erased. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator just past the last element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element after the erased element.</dd></dl>
<p>This function erases a range of element from the sparse submatrix. In case the storage order is set to <em>rowMajor</em> the function erases a range of elements element from row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function erases a range of elements from column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="afccee02e131f1fa0f8d1be1c6f3d83d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalizing the element insertion of a row/column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column to be finalized <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function is part of the low-level interface to efficiently fill a submatrix with elements. After completion of row/column <em>i</em> via the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a087c32f6b256c04457e88129aa06d3c8" title="Appending an element to the specified row/column of the sparse submatrix. ">append()</a> function, this function can be called to finalize row/column <em>i</em> and prepare the next row/column for insertion process via <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a087c32f6b256c04457e88129aa06d3c8" title="Appending an element to the specified row/column of the sparse submatrix. ">append()</a>.</p>
<p><b>Note:</b> Although <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#afccee02e131f1fa0f8d1be1c6f3d83d7" title="Finalizing the element insertion of a row/column. ">finalize()</a> does not allocate new memory, it still invalidates all iterators returned by the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad9c5b86d48daf666bc7fe257a818f94e" title="Returns an iterator just past the last non-zero element of row/column i. ">end()</a> functions! </p>

</div>
</div>
<a class="anchor" id="a3af55d228199f73e594cad285c51aba2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for a specific submatrix element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element in case the index is found, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad9c5b86d48daf666bc7fe257a818f94e" title="Returns an iterator just past the last non-zero element of row/column i. ">end()</a> iterator otherwise.</dd></dl>
<p>This function can be used to check whether a specific element is contained in the sparse submatrix. It specifically searches for the element with row index <em>i</em> and column index <em>j</em>. In case the element is found, the function returns an row/column iterator to the element. Otherwise an iterator just past the last non-zero element of row <em>i</em> or column <em>j</em> (the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad9c5b86d48daf666bc7fe257a818f94e" title="Returns an iterator just past the last non-zero element of row/column i. ">end()</a> iterator) is returned. Note that the returned sparse submatrix iterator is subject to invalidation due to inserting operations via the function call operator or the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a49406ff8da9d228d4c6f667bafca7ef3" title="Inserting an element into the sparse submatrix. ">insert()</a> function! </p>

</div>
</div>
<a class="anchor" id="a9ca29d4eb845515e81dbec535da3f84f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for a specific submatrix element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element in case the index is found, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad9c5b86d48daf666bc7fe257a818f94e" title="Returns an iterator just past the last non-zero element of row/column i. ">end()</a> iterator otherwise.</dd></dl>
<p>This function can be used to check whether a specific element is contained in the sparse submatrix. It specifically searches for the element with row index <em>i</em> and column index <em>j</em>. In case the element is found, the function returns an row/column iterator to the element. Otherwise an iterator just past the last non-zero element of row <em>i</em> or column <em>j</em> (the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad9c5b86d48daf666bc7fe257a818f94e" title="Returns an iterator just past the last non-zero element of row/column i. ">end()</a> iterator) is returned. Note that the returned sparse submatrix iterator is subject to invalidation due to inserting operations via the function call operator or the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a49406ff8da9d228d4c6f667bafca7ef3" title="Inserting an element into the sparse submatrix. ">insert()</a> function! </p>

</div>
</div>
<a class="anchor" id="a25eb15ae1607d0d125c741fc82b170a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::hasOverlap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking whether there exists an overlap in the context of a symmetric matrix. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case an overlap exists, <em>false</em> if not.</dd></dl>
<p>This function checks if in the context of a symmetric matrix the submatrix has an overlap with its counterpart. In case an overlap exists, the function return <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a49406ff8da9d228d4c6f667bafca7ef3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a553ac461dc0b491cd44be7e96f1b5317">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserting an element into the sparse submatrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the newly inserted element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid sparse submatrix access index.</td></tr>
  </table>
  </dd>
</dl>
<p>This function inserts a new element into the sparse submatrix. However, duplicate elements are not allowed. In case the sparse submatrix already contains an element with row index <em>i</em> and column index <em>j</em>, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a07a67f6e1885718d95f4c62c4976f8db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the submatrix is aliased with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this submatrix, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address is aliased with the submatrix. In contrast to the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a0f5d1be05f7f89ed26cb85dc4ffd2e63" title="Returns whether the submatrix can alias with the given address alias. ">canAlias()</a> function this function is not allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="a288d4acddc6f5dbfd674c1b9afb05bca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::lowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index not less then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index not less then the given index, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad9c5b86d48daf666bc7fe257a818f94e" title="Returns an iterator just past the last non-zero element of row/column i. ">end()</a> iterator otherwise.</dd></dl>
<p>In case of a row-major submatrix, this function returns a row iterator to the first element with an index not less then the given column index. In case of a column-major submatrix, the function returns a column iterator to the first element with an index not less then the given row index. In combination with the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a1371fb8908776cda8efa4892d4cc7a21" title="Returns an iterator to the first index greater then the given index. ">upperBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned submatrix iterator is subject to invalidation due to inserting operations via the function call operator or the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a49406ff8da9d228d4c6f667bafca7ef3" title="Inserting an element into the sparse submatrix. ">insert()</a> function! </p>

</div>
</div>
<a class="anchor" id="ad8e8a7db94471e2b7f9fab1352610a12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::lowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index not less then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index not less then the given index, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad9c5b86d48daf666bc7fe257a818f94e" title="Returns an iterator just past the last non-zero element of row/column i. ">end()</a> iterator otherwise.</dd></dl>
<p>In case of a row-major submatrix, this function returns a row iterator to the first element with an index not less then the given column index. In case of a column-major submatrix, the function returns a column iterator to the first element with an index not less then the given row index. In combination with the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a1371fb8908776cda8efa4892d4cc7a21" title="Returns an iterator to the first index greater then the given index. ">upperBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned submatrix iterator is subject to invalidation due to inserting operations via the function call operator or the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a49406ff8da9d228d4c6f667bafca7ef3" title="Inserting an element into the sparse submatrix. ">insert()</a> function! </p>

</div>
</div>
<a class="anchor" id="a2534556460f30db297ca5fc6ad90aa7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the sparse submatrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the sparse submatrix. </dd></dl>

</div>
</div>
<a class="anchor" id="abecebc96a4aa86ec4c3006a8f689419b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the specified row/column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements of row/column <em>i</em>.</dd></dl>
<p>This function returns the current number of non-zero elements in the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the number of non-zero elements in row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the number of non-zero elements in column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a3f0c34471e288f409d53a2660a26ddfd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a73ab2d5ad6e142226599f059d621d2eb">Reference</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2D-access to the sparse submatrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f4f1951840e28a972d660d12fcf49a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad569e64dcdbc66ad1ab22f78d70f803e">ConstReference</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2D-access to the sparse submatrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="a74cc9b3a65e6ea3083370d6cb5099201"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt;MT,AF,SO&gt;&amp; <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication of a matrix ( <img class="formulaInl" alt="$ A*=B $" src="../../form_57.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the sparse submatrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to matrix adaptor.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower triangular, upper triangular, or symmetric matrix and the assignment would violate its lower, upper, or symmetry property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ad0b3d9e7cc35da329506addf8514333e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt;MT,AF,SO&gt; &gt;::Type&amp; <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication between a sparse submatrix and a scalar value ( <img class="formulaInl" alt="$ A*=s $" src="../../form_58.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the sparse submatrix.</dd></dl>
<p>Via this operator it is possible to scale the sparse submatrix. Note however that the function is subject to three restrictions. First, this operator cannot be used for submatrices on lower or upper unitriangular matrices. The attempt to scale such a submatrix results in a compilation error! Second, this operator can only be used for numeric data types. <a class="el" href="../../d7/d97/structblaze_1_1And.html" title="Compile time logical and evaluation.The And class template performs at compile time a logical and (&#39;&&&#3...">And</a> third, the elements of the sparse row must support the multiplication assignment operator for the given scalar built-in data type. </p>

</div>
</div>
<a class="anchor" id="a984b8b018a1a5a49bebafdf5c8c1f37d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt;MT,AF,SO&gt;&amp; <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator for the addition of a matrix ( <img class="formulaInl" alt="$ A+=B $" src="../../form_55.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix to be added to the submatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the sparse submatrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to matrix adaptor.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower triangular, upper triangular, or symmetric matrix and the assignment would violate its lower, upper, or symmetry property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a11b041b8886050ae4862697108b6de1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt;MT,AF,SO&gt;&amp; <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator for the subtraction of a matrix ( <img class="formulaInl" alt="$ A-=B $" src="../../form_56.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix to be subtracted from the submatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the sparse submatrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to matrix adaptor.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower triangular, upper triangular, or symmetric matrix and the assignment would violate its lower, upper, or symmetry property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="addccb10f997a7ddbcefeeb3415696551"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt;MT,AF,SO&gt; &gt;::Type&amp; <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator for the division of a sparse submatrix by a scalar value ( <img class="formulaInl" alt="$ A/=s $" src="../../form_59.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the sparse submatrix.</dd></dl>
<p>Via this operator it is possible to scale the sparse submatrix. Note however that the function is subject to three restrictions. First, this operator cannot be used for submatrices on lower or upper unitriangular matrices. The attempt to scale such a submatrix results in a compilation error! Second, this operator can only be used for numeric data types. <a class="el" href="../../d7/d97/structblaze_1_1And.html" title="Compile time logical and evaluation.The And class template performs at compile time a logical and (&#39;&&&#3...">And</a> third, the elements of the sparse submatrix must either support the multiplication assignment operator for the given floating point data type or the division assignment operator for the given integral data type.</p>
<p><b>Note:</b> A division by zero is only checked by an user assert. </p>

</div>
</div>
<a class="anchor" id="af2efa2eb18305ecb556893ae0ca9dee4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt; &amp; <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator for <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html" title="View on a specific submatrix of a sparse matrix.The SparseSubmatrix template represents a view on a s...">SparseSubmatrix</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Sparse submatrix to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned submatrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d2/d6e/structblaze_1_1Submatrix.html" title="Base class for all submatrices.The Submatrix class serves as a tag for all submatrices (i...">Submatrix</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to matrix adaptor.</td></tr>
  </table>
  </dd>
</dl>
<p>The sparse submatrix is initialized as a copy of the given sparse submatrix. In case the current sizes of the two submatrices don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower triangular, upper triangular, or symmetric matrix and the assignment would violate its lower, upper, or symmetry property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ab26ec6e5c9effcd5b98f99fdd8174de2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt;MT,AF,SO&gt;&amp; <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for different matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned submatrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to matrix adaptor.</td></tr>
  </table>
  </dd>
</dl>
<p>The sparse submatrix is initialized as a copy of the given matrix. In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower triangular, upper triangular, or symmetric matrix and the assignment would violate its lower, upper, or symmetry property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="af6a540a2c4c893ac8d4842bbbfd19a61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>&amp; <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">blaze::Matrix</a>&lt; <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt; , SO &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for non-constant matrices. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference of the actual type of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a71becdce9e44bcba62ee6458c6f5a6fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>&amp; <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">blaze::Matrix</a>&lt; <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt; , SO &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for constant matrices. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant reference of the actual type of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a5350356f08685ecc2d0336d9ad9a57f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">IsAdaptor</a>&lt;MT2&gt; &gt;, bool &gt;::Type <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT3, SO3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying matrix of type <em>MT</em> would be violated by an assignment of the given matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="acc78e2ba5fcbfa9d5648d5d0d80946e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 , bool SO3&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">IsSymmetric</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT3, SO3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying symmetric matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The symmetric matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying symmetric matrix of type <em>MT</em> would be violated by an assignment of the given row-major matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="ac8a5ee7f8c1136b37c39b4698b311173"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The lower matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying lower triangular matrix of type <em>MT</em> would be violated by an assignment of the given row-major dense matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a9b99ef8b5490556c89bfa39c54378283"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The lower matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying lower triangular matrix of type <em>MT</em> would be violated by an assignment of the given column-major dense matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="aadd10bf13e9f3c17cf9ce53219e2fb77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The lower matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying lower triangular matrix of type <em>MT</em> would be violated by an assignment of the given row-major sparse matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a0ee18f45de724791715223bab4f4ae4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The lower matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying lower triangular matrix of type <em>MT</em> would be violated by an assignment of the given column-major sparse matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a25cab4eaa84bf6d2ad927578742b8304"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The upper matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying upper triangular matrix of type <em>MT</em> would be violated by an assignment of the given row-major dense matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a33223a9266cbcd3e7bdbef6b6bbb98ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The upper matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying upper triangular matrix of type <em>MT</em> would be violated by an assignment of the given column-major dense matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="abc36d4321b88c2f55ff7cc6eee0504cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The upper matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying upper triangular matrix of type <em>MT</em> would be violated by an assignment of the given row-major sparse matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="ac063e557defc24fa3843905ee960bb32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The upper matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying upper triangular matrix of type <em>MT</em> would be violated by an assignment of the given column-major sparse matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a664e48d7f2525b633daee76fa6e60053"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt;, bool &gt;::Type <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying diagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The diagonal matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying diagonal matrix of type <em>MT</em> would be violated by an assignment of the given row-major dense matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="ad40e06643c2aa96b8d1de37d71735651"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt;, bool &gt;::Type <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT3, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying diagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The diagonal matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying diagonal matrix of type <em>MT</em> would be violated by an assignment of the given column-major dense matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="ad5747257be187c38c44f4868eda29abc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt;, bool &gt;::Type <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying diagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The diagonal matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying diagonal matrix of type <em>MT</em> would be violated by an assignment of the given row-major sparse matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a7bdc0a2b5f2f21195f0ec770d1bb62c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename MT3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt;, bool &gt;::Type <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT3, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying diagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The diagonal matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying diagonal matrix of type <em>MT</em> would be violated by an assignment of the given column-major sparse matrix <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a9513fb5d34843df50953c3cc860d9d12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>nonzeros</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setting the minimum capacity of the sparse submatrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nonzeros</td><td>The new minimum capacity of the sparse submatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function increases the capacity of the sparse submatrix to at least <em>nonzeros</em> elements. The current values of the submatrix elements and the individual capacities of the submatrix rows are preserved. </p>

</div>
</div>
<a class="anchor" id="a8e7378ae6a6175cb89f33d93935ec8eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>nonzeros</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setting the minimum capacity of a specific row/column of the sparse submatrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index of the new element <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/> or <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
    <tr><td class="paramname">nonzeros</td><td>The new minimum capacity of the specified row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function increases the capacity of row/column <em>i</em> of the sparse submatrix to at least <em>nonzeros</em> elements, but not beyond the current number of columns/rows, respectively. The current values of the sparse submatrix and all other individual row/column capacities are preserved. In case the storage order is set to <em>rowMajor</em>, the function reserves capacity for row <em>i</em> and the index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. In case the storage order is set to <em>columnMajor</em>, the function reserves capacity for column <em>i</em> and the index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </p>

</div>
</div>
<a class="anchor" id="a6050c0c43bc5e311bf29c72fa67af7e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to the default initial values. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a44358e4bb9119b19b657fb4bf6183345"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the specified row/column to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets the values in the specified row/column to their default value. In case the storage order is set to <em>rowMajor</em> the function resets the values in row <em>i</em>, in case the storage order is set to <em>columnMajor</em> the function resets the values in column <em>i</em>. Note that the capacity of the row/column remains unchanged. </p>

</div>
</div>
<a class="anchor" id="a2ee5245021a866633c2ce607b9f45163"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of rows of the sparse submatrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of rows of the sparse submatrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bad2369326af8aab38afcb929b60011"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool AF = unaligned, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt;MT,AF,SO&gt;&amp; <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scaling of the sparse submatrix by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_63.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value for the submatrix scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the sparse submatrix.</dd></dl>
<p>This function scales all elements of the submatrix by the given scalar value <em>scalar</em>. Note that the function cannot be used to scale a submatrix on a lower or upper unitriangular matrix. The attempt to scale such a submatrix results in a compile time error! </p>

</div>
</div>
<a class="anchor" id="acf09d283c5eef27446a1e8c0eba1e817"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a553ac461dc0b491cd44be7e96f1b5317">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setting an element of the sparse submatrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the set element.</dd></dl>
<p>This function sets the value of an element of the sparse submatrix. In case the sparse matrix already contains an element with row index <em>i</em> and column index <em>j</em> its value is modified, else a new element with the given <em>value</em> is inserted. </p>

</div>
</div>
<a class="anchor" id="a9f8a12d49a52f676b66f18996ecad378"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a2bd489acd891c681cfe13f0aea8844e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a9abd1d530487699f53e891c65c57672f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt; &amp; <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transposing the submatrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the transposed submatrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Invalid transpose of a non-quadratic submatrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This function transposes the sparse submatrix in-place. Note that this function can only be used for quadratic submatrices, i.e. if the number of rows is equal to the number of columns. The attempt to transpose a non-quadratic submatrix results in a <em>std::runtime_error</em> exception. </p>

</div>
</div>
<a class="anchor" id="aad5e33a8933463d0e6d3c70383c40572"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::trim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removing all excessive capacity from all rows/columns. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>The <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#aad5e33a8933463d0e6d3c70383c40572" title="Removing all excessive capacity from all rows/columns. ">trim()</a> function can be used to reverse the effect of all row/column-specific <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a9513fb5d34843df50953c3cc860d9d12" title="Setting the minimum capacity of the sparse submatrix. ">reserve()</a> calls. The function removes all excessive capacity from all rows (in case of a rowMajor matrix) or columns (in case of a columnMajor matrix). Note that this function does not remove the overall capacity but only reduces the capacity per row/column. </p>

</div>
</div>
<a class="anchor" id="aac06300bf8ce9fdf4c0205f80b7f2068"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removing all excessive capacity of a specific row/column of the sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column to be trimmed ( <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/> or <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function can be used to reverse the effect of a row/column-specific <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a9513fb5d34843df50953c3cc860d9d12" title="Setting the minimum capacity of the sparse submatrix. ">reserve()</a> call. It removes all excessive capacity from the specified row (in case of a rowMajor matrix) or column (in case of a columnMajor matrix). The excessive capacity is assigned to the subsequent row/column. </p>

</div>
</div>
<a class="anchor" id="a1371fb8908776cda8efa4892d4cc7a21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a2964f30bc0bdd80a52b6242cd7839390">Iterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::upperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index greater then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index greater then the given index, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad9c5b86d48daf666bc7fe257a818f94e" title="Returns an iterator just past the last non-zero element of row/column i. ">end()</a> iterator otherwise.</dd></dl>
<p>In case of a row-major submatrix, this function returns a row iterator to the first element with an index greater then the given column index. In case of a column-major submatrix, the function returns a column iterator to the first element with an index greater then the given row index. In combination with the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a1371fb8908776cda8efa4892d4cc7a21" title="Returns an iterator to the first index greater then the given index. ">upperBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned submatrix iterator is subject to invalidation due to inserting operations via the function call operator or the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a49406ff8da9d228d4c6f667bafca7ef3" title="Inserting an element into the sparse submatrix. ">insert()</a> function! </p>

</div>
</div>
<a class="anchor" id="ae12ea65bec868bb59bc29f22f6481378"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool AF, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">SparseSubmatrix</a>&lt; MT, AF, SO &gt;::<a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a98b6573b1a8d23b804dbe31cc47fdb13">ConstIterator</a> <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html">blaze::SparseSubmatrix</a>&lt; MT, AF, SO &gt;::upperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index greater then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>The column index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index greater then the given index, <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#ad9c5b86d48daf666bc7fe257a818f94e" title="Returns an iterator just past the last non-zero element of row/column i. ">end()</a> iterator otherwise.</dd></dl>
<p>In case of a row-major submatrix, this function returns a row iterator to the first element with an index greater then the given column index. In case of a column-major submatrix, the function returns a column iterator to the first element with an index greater then the given row index. In combination with the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a1371fb8908776cda8efa4892d4cc7a21" title="Returns an iterator to the first index greater then the given index. ">upperBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned submatrix iterator is subject to invalidation due to inserting operations via the function call operator or the <a class="el" href="../../dc/dff/classblaze_1_1SparseSubmatrix.html#a49406ff8da9d228d4c6f667bafca7ef3" title="Inserting an element into the sparse submatrix. ">insert()</a> function! </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>blaze/math/views/<a class="el" href="../../d2/d24/views_2Forward_8h_source.html">Forward.h</a></li>
<li>blaze/math/views/<a class="el" href="../../db/d5a/views_2SparseSubmatrix_8h_source.html">SparseSubmatrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:55:26 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
