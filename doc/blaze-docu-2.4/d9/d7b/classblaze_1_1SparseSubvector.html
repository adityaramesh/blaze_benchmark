<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>blaze::SparseSubvector&lt; VT, AF, TF &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="../../d9/d6a/classblaze_1_1SparseSubvector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::SparseSubvector&lt; VT, AF, TF &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../d0/d48/group__views.html">Views</a> &raquo; <a class="el" href="../../d8/de4/group__sparse__subvector.html">Sparse Subvector</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> on a specific subvector of a sparse vector.The <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html" title="View on a specific subvector of a sparse vector.The SparseSubvector template represents a view on a s...">SparseSubvector</a> template represents a view on a specific subvector of a sparse vector primitive. The type of the sparse vector is specified via the first template parameter:  
 <a href="../../d9/d7b/classblaze_1_1SparseSubvector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d6/dd8/views_2SparseSubvector_8h_source.html">SparseSubvector.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">blaze::SparseVector&lt; SparseSubvector&lt; VT, AF, TF &gt;, TF &gt;</a>, and <a class="el" href="../../d6/d66/structblaze_1_1Subvector.html">blaze::Subvector</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc0/classblaze_1_1SparseSubvector_1_1SubvectorElement.html">SubvectorElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for a specific element of the sparse subvector.  <a href="../../dc/dc0/classblaze_1_1SparseSubvector_1_1SubvectorElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d6c/classblaze_1_1SparseSubvector_1_1SubvectorIterator.html">SubvectorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the elements of the sparse subvector.  <a href="../../d8/d6c/classblaze_1_1SparseSubvector_1_1SubvectorIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ga84786732e35f3664d2ec2ff5cd747a59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga84786732e35f3664d2ec2ff5cd747a59"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>smpAssignable</b> = VT::smpAssignable
 }</td></tr>
<tr class="memdesc:ga84786732e35f3664d2ec2ff5cd747a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the expression template assignment strategy. <br /></td></tr>
<tr class="separator:ga84786732e35f3664d2ec2ff5cd747a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6855f325357ef08996d6250ca90c9484"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6855f325357ef08996d6250ca90c9484"></a>
typedef <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a6855f325357ef08996d6250ca90c9484">This</a></td></tr>
<tr class="memdesc:a6855f325357ef08996d6250ca90c9484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html" title="View on a specific subvector of a sparse vector.The SparseSubvector template represents a view on a s...">SparseSubvector</a> instance. <br /></td></tr>
<tr class="separator:a6855f325357ef08996d6250ca90c9484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994ccd3f37ff10738e03885d6ab5c55a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a994ccd3f37ff10738e03885d6ab5c55a"></a>
typedef <a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html">SubvectorTrait</a>&lt; VT &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a994ccd3f37ff10738e03885d6ab5c55a">ResultType</a></td></tr>
<tr class="memdesc:a994ccd3f37ff10738e03885d6ab5c55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br /></td></tr>
<tr class="separator:a994ccd3f37ff10738e03885d6ab5c55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487c0032efa164ea06ec587343c1e878"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a487c0032efa164ea06ec587343c1e878"></a>
typedef <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html#a02b3d3c589c780c2abaa5275b79b88ba">ResultType::TransposeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a487c0032efa164ea06ec587343c1e878">TransposeType</a></td></tr>
<tr class="memdesc:a487c0032efa164ea06ec587343c1e878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br /></td></tr>
<tr class="separator:a487c0032efa164ea06ec587343c1e878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69745dee26e3b78dd0b8fb50447eda4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69745dee26e3b78dd0b8fb50447eda4c"></a>
typedef VT::ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a69745dee26e3b78dd0b8fb50447eda4c">ElementType</a></td></tr>
<tr class="memdesc:a69745dee26e3b78dd0b8fb50447eda4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the subvector elements. <br /></td></tr>
<tr class="separator:a69745dee26e3b78dd0b8fb50447eda4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b39991f659d0a30d20c1c15eb10c32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57b39991f659d0a30d20c1c15eb10c32"></a>
typedef VT::ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a57b39991f659d0a30d20c1c15eb10c32">ReturnType</a></td></tr>
<tr class="memdesc:a57b39991f659d0a30d20c1c15eb10c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br /></td></tr>
<tr class="separator:a57b39991f659d0a30d20c1c15eb10c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3212dc8348f5c34be138fae1e61c0066"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3212dc8348f5c34be138fae1e61c0066"></a>
typedef const <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a3212dc8348f5c34be138fae1e61c0066">CompositeType</a></td></tr>
<tr class="memdesc:a3212dc8348f5c34be138fae1e61c0066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br /></td></tr>
<tr class="separator:a3212dc8348f5c34be138fae1e61c0066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fd6b9142c404a4a9b648114f1ddab7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70fd6b9142c404a4a9b648114f1ddab7"></a>
typedef VT::ConstReference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a70fd6b9142c404a4a9b648114f1ddab7">ConstReference</a></td></tr>
<tr class="memdesc:a70fd6b9142c404a4a9b648114f1ddab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant subvector value. <br /></td></tr>
<tr class="separator:a70fd6b9142c404a4a9b648114f1ddab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0903ae0ae90ead7ad1a9bb44990bd18f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0903ae0ae90ead7ad1a9bb44990bd18f"></a>
typedef <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; useConst, <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a70fd6b9142c404a4a9b648114f1ddab7">ConstReference</a>, typename VT::Reference &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a0903ae0ae90ead7ad1a9bb44990bd18f">Reference</a></td></tr>
<tr class="memdesc:a0903ae0ae90ead7ad1a9bb44990bd18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant subvector value. <br /></td></tr>
<tr class="separator:a0903ae0ae90ead7ad1a9bb44990bd18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760387b79b2503d6901ed08678ed06a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a760387b79b2503d6901ed08678ed06a5"></a>
typedef <a class="el" href="../../d8/d6c/classblaze_1_1SparseSubvector_1_1SubvectorIterator.html">SubvectorIterator</a>&lt; const VT, typename VT::ConstIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a></td></tr>
<tr class="memdesc:a760387b79b2503d6901ed08678ed06a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br /></td></tr>
<tr class="separator:a760387b79b2503d6901ed08678ed06a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfe734661072b52dc939ff58a5c8f77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dfe734661072b52dc939ff58a5c8f77"></a>
typedef <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; useConst, <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a>, <a class="el" href="../../d8/d6c/classblaze_1_1SparseSubvector_1_1SubvectorIterator.html">SubvectorIterator</a>&lt; VT, typename VT::Iterator &gt; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a></td></tr>
<tr class="memdesc:a2dfe734661072b52dc939ff58a5c8f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br /></td></tr>
<tr class="separator:a2dfe734661072b52dc939ff58a5c8f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe7ddefcf2554b0bced1ad1b4b53e24"></a>
typedef <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a></td></tr>
<tr class="memdesc:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the vector. <br /></td></tr>
<tr class="separator:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acd936a3aba37c77f5b262503b2707464"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:acd936a3aba37c77f5b262503b2707464"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#acd936a3aba37c77f5b262503b2707464">operator=</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:acd936a3aba37c77f5b262503b2707464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for dense vectors.  <a href="#acd936a3aba37c77f5b262503b2707464">More...</a><br /></td></tr>
<tr class="separator:acd936a3aba37c77f5b262503b2707464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016991abe9448ea44e6d60dd8f6996d6"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a016991abe9448ea44e6d60dd8f6996d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a016991abe9448ea44e6d60dd8f6996d6">operator=</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a016991abe9448ea44e6d60dd8f6996d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for different sparse vectors.  <a href="#a016991abe9448ea44e6d60dd8f6996d6">More...</a><br /></td></tr>
<tr class="separator:a016991abe9448ea44e6d60dd8f6996d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0b3e6a1e9ad464c3224cf663127f1b"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:adc0b3e6a1e9ad464c3224cf663127f1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#adc0b3e6a1e9ad464c3224cf663127f1b">operator+=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:adc0b3e6a1e9ad464c3224cf663127f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator for the addition of a vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_66.png"/>).  <a href="#adc0b3e6a1e9ad464c3224cf663127f1b">More...</a><br /></td></tr>
<tr class="separator:adc0b3e6a1e9ad464c3224cf663127f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662dc288644e3f892d1f24ee49ad416c"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a662dc288644e3f892d1f24ee49ad416c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a662dc288644e3f892d1f24ee49ad416c">operator-=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a662dc288644e3f892d1f24ee49ad416c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator for the subtraction of a vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_67.png"/>).  <a href="#a662dc288644e3f892d1f24ee49ad416c">More...</a><br /></td></tr>
<tr class="separator:a662dc288644e3f892d1f24ee49ad416c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7df0752d0e8b5424ab0501168922eeb"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ac7df0752d0e8b5424ab0501168922eeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ac7df0752d0e8b5424ab0501168922eeb">operator*=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac7df0752d0e8b5424ab0501168922eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}*=\vec{b} $" src="../../form_68.png"/>).  <a href="#ac7df0752d0e8b5424ab0501168922eeb">More...</a><br /></td></tr>
<tr class="separator:ac7df0752d0e8b5424ab0501168922eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4347073f5d68011ee3bfafad874c6324"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a4347073f5d68011ee3bfafad874c6324"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a4347073f5d68011ee3bfafad874c6324">operator*=</a> (Other rhs)</td></tr>
<tr class="memdesc:a4347073f5d68011ee3bfafad874c6324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication between a sparse subvector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_69.png"/>).  <a href="#a4347073f5d68011ee3bfafad874c6324">More...</a><br /></td></tr>
<tr class="separator:a4347073f5d68011ee3bfafad874c6324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73afeec0667b67b3734b7a3338e0e2a"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ac73afeec0667b67b3734b7a3338e0e2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ac73afeec0667b67b3734b7a3338e0e2a">operator/=</a> (Other rhs)</td></tr>
<tr class="memdesc:ac73afeec0667b67b3734b7a3338e0e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator for the division of a sparse subvector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_70.png"/>).  <a href="#ac73afeec0667b67b3734b7a3338e0e2a">More...</a><br /></td></tr>
<tr class="separator:ac73afeec0667b67b3734b7a3338e0e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac914eb158938d6706e6d79fabf1836c0"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ac914eb158938d6706e6d79fabf1836c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ac914eb158938d6706e6d79fabf1836c0">scale</a> (const Other &amp;scalar)</td></tr>
<tr class="memdesc:ac914eb158938d6706e6d79fabf1836c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of the sparse subvector by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_72.png"/>).  <a href="#ac914eb158938d6706e6d79fabf1836c0">More...</a><br /></td></tr>
<tr class="separator:ac914eb158938d6706e6d79fabf1836c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be3095780509ea4b0c421bdb15920a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a1be3095780509ea4b0c421bdb15920a0">operator~</a> ()</td></tr>
<tr class="memdesc:a1be3095780509ea4b0c421bdb15920a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for non-constant vectors.  <a href="#a1be3095780509ea4b0c421bdb15920a0">More...</a><br /></td></tr>
<tr class="separator:a1be3095780509ea4b0c421bdb15920a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37bee20b660eacfcb7a942dc9cdbe19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#ae37bee20b660eacfcb7a942dc9cdbe19">operator~</a> () const</td></tr>
<tr class="memdesc:ae37bee20b660eacfcb7a942dc9cdbe19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for constant vectors.  <a href="#ae37bee20b660eacfcb7a942dc9cdbe19">More...</a><br /></td></tr>
<tr class="separator:ae37bee20b660eacfcb7a942dc9cdbe19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:aa1eac4598c99f25e628ca254ca1fdbe7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#aa1eac4598c99f25e628ca254ca1fdbe7">SparseSubvector</a> (<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ac4da70494ad4be7f7ac090d61616713e">Operand</a> vector, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:aa1eac4598c99f25e628ca254ca1fdbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor for <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html" title="View on a specific subvector of a sparse vector.The SparseSubvector template represents a view on a s...">SparseSubvector</a>.  <a href="#aa1eac4598c99f25e628ca254ca1fdbe7">More...</a><br /></td></tr>
<tr class="separator:aa1eac4598c99f25e628ca254ca1fdbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access functions</div></td></tr>
<tr class="memitem:aa18b8c1bea3c9869c054105a5a6c5fb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a0903ae0ae90ead7ad1a9bb44990bd18f">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#aa18b8c1bea3c9869c054105a5a6c5fb2">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:aa18b8c1bea3c9869c054105a5a6c5fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the subvector elements.  <a href="#aa18b8c1bea3c9869c054105a5a6c5fb2">More...</a><br /></td></tr>
<tr class="separator:aa18b8c1bea3c9869c054105a5a6c5fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa040362125c7483931df604386dd763f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a70fd6b9142c404a4a9b648114f1ddab7">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#aa040362125c7483931df604386dd763f">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:aa040362125c7483931df604386dd763f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the subvector elements.  <a href="#aa040362125c7483931df604386dd763f">More...</a><br /></td></tr>
<tr class="separator:aa040362125c7483931df604386dd763f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcc4a0f29390134b377f7c93f7bf518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#aabcc4a0f29390134b377f7c93f7bf518">begin</a> ()</td></tr>
<tr class="memdesc:aabcc4a0f29390134b377f7c93f7bf518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the subvector.  <a href="#aabcc4a0f29390134b377f7c93f7bf518">More...</a><br /></td></tr>
<tr class="separator:aabcc4a0f29390134b377f7c93f7bf518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08b5983c392a2463832515e159c29d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ac08b5983c392a2463832515e159c29d7">begin</a> () const </td></tr>
<tr class="memdesc:ac08b5983c392a2463832515e159c29d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the subvector.  <a href="#ac08b5983c392a2463832515e159c29d7">More...</a><br /></td></tr>
<tr class="separator:ac08b5983c392a2463832515e159c29d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea6a16d7540099fd09b2b719db5b38c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#afea6a16d7540099fd09b2b719db5b38c">cbegin</a> () const </td></tr>
<tr class="memdesc:afea6a16d7540099fd09b2b719db5b38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the subvector.  <a href="#afea6a16d7540099fd09b2b719db5b38c">More...</a><br /></td></tr>
<tr class="separator:afea6a16d7540099fd09b2b719db5b38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635a335fd90466c548ab984d651090df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a635a335fd90466c548ab984d651090df">end</a> ()</td></tr>
<tr class="memdesc:a635a335fd90466c548ab984d651090df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the subvector.  <a href="#a635a335fd90466c548ab984d651090df">More...</a><br /></td></tr>
<tr class="separator:a635a335fd90466c548ab984d651090df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7efe87973adbf69c811a558bae9bf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#acc7efe87973adbf69c811a558bae9bf1">end</a> () const </td></tr>
<tr class="memdesc:acc7efe87973adbf69c811a558bae9bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the subvector.  <a href="#acc7efe87973adbf69c811a558bae9bf1">More...</a><br /></td></tr>
<tr class="separator:acc7efe87973adbf69c811a558bae9bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace45b3a5d811443f195c494fcd4fc81a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ace45b3a5d811443f195c494fcd4fc81a">cend</a> () const </td></tr>
<tr class="memdesc:ace45b3a5d811443f195c494fcd4fc81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the subvector.  <a href="#ace45b3a5d811443f195c494fcd4fc81a">More...</a><br /></td></tr>
<tr class="separator:ace45b3a5d811443f195c494fcd4fc81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment operators</div></td></tr>
<tr class="memitem:a9a8a2f8cf64e89b74fa4b2197973753c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a9a8a2f8cf64e89b74fa4b2197973753c">operator=</a> (const <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a> &amp;rhs)</td></tr>
<tr class="memdesc:a9a8a2f8cf64e89b74fa4b2197973753c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html" title="View on a specific subvector of a sparse vector.The SparseSubvector template represents a view on a s...">SparseSubvector</a>.  <a href="#a9a8a2f8cf64e89b74fa4b2197973753c">More...</a><br /></td></tr>
<tr class="separator:a9a8a2f8cf64e89b74fa4b2197973753c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1683db6ee946248113eedd694da8c21"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae1683db6ee946248113eedd694da8c21"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ae1683db6ee946248113eedd694da8c21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:ae1683db6ee946248113eedd694da8c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599a250ec82fa71116af4e747edfde5c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a599a250ec82fa71116af4e747edfde5c"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a599a250ec82fa71116af4e747edfde5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a599a250ec82fa71116af4e747edfde5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef181e1976bb1031a40874e13627e2d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ef181e1976bb1031a40874e13627e2d"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a8ef181e1976bb1031a40874e13627e2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a8ef181e1976bb1031a40874e13627e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc694a9490c39c88b9122ff531b46970"><td class="memTemplParams" colspan="2"><a class="anchor" id="adc694a9490c39c88b9122ff531b46970"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:adc694a9490c39c88b9122ff531b46970"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:adc694a9490c39c88b9122ff531b46970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be10b01277fa4f65fae494cabafe64a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2be10b01277fa4f65fae494cabafe64a"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a2be10b01277fa4f65fae494cabafe64a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a2be10b01277fa4f65fae494cabafe64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275e08721fc64687119ff7742995ff2a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a275e08721fc64687119ff7742995ff2a"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a275e08721fc64687119ff7742995ff2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (Other rhs)</td></tr>
<tr class="separator:a275e08721fc64687119ff7742995ff2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae462282442664246ecbff7d4b700bea2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae462282442664246ecbff7d4b700bea2"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ae462282442664246ecbff7d4b700bea2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (Other rhs)</td></tr>
<tr class="separator:ae462282442664246ecbff7d4b700bea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility functions</div></td></tr>
<tr class="memitem:a68d113f4cf17b9a74a71821f41801487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a68d113f4cf17b9a74a71821f41801487">size</a> () const </td></tr>
<tr class="memdesc:a68d113f4cf17b9a74a71821f41801487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size/dimension of the sparse subvector.  <a href="#a68d113f4cf17b9a74a71821f41801487">More...</a><br /></td></tr>
<tr class="separator:a68d113f4cf17b9a74a71821f41801487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae671c3757f2b5d250cacdc3a54bff4f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ae671c3757f2b5d250cacdc3a54bff4f8">capacity</a> () const </td></tr>
<tr class="memdesc:ae671c3757f2b5d250cacdc3a54bff4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the sparse subvector.  <a href="#ae671c3757f2b5d250cacdc3a54bff4f8">More...</a><br /></td></tr>
<tr class="separator:ae671c3757f2b5d250cacdc3a54bff4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6085963be3def4cda89f3241bff79ef5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a6085963be3def4cda89f3241bff79ef5">nonZeros</a> () const </td></tr>
<tr class="memdesc:a6085963be3def4cda89f3241bff79ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the subvector.  <a href="#a6085963be3def4cda89f3241bff79ef5">More...</a><br /></td></tr>
<tr class="separator:a6085963be3def4cda89f3241bff79ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fef7ce5b5d726bee41477b6f1c12829"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a5fef7ce5b5d726bee41477b6f1c12829">reset</a> ()</td></tr>
<tr class="memdesc:a5fef7ce5b5d726bee41477b6f1c12829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to the default initial values.  <a href="#a5fef7ce5b5d726bee41477b6f1c12829">More...</a><br /></td></tr>
<tr class="separator:a5fef7ce5b5d726bee41477b6f1c12829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97ef016826a9f7c8020b3ff596ce16c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ad97ef016826a9f7c8020b3ff596ce16c">set</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a69745dee26e3b78dd0b8fb50447eda4c">ElementType</a> &amp;value)</td></tr>
<tr class="memdesc:ad97ef016826a9f7c8020b3ff596ce16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an element of the sparse subvector.  <a href="#ad97ef016826a9f7c8020b3ff596ce16c">More...</a><br /></td></tr>
<tr class="separator:ad97ef016826a9f7c8020b3ff596ce16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11774735d9ba0fcb7bec841a5943617"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ac11774735d9ba0fcb7bec841a5943617">insert</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a69745dee26e3b78dd0b8fb50447eda4c">ElementType</a> &amp;value)</td></tr>
<tr class="memdesc:ac11774735d9ba0fcb7bec841a5943617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserting an element into the sparse subvector.  <a href="#ac11774735d9ba0fcb7bec841a5943617">More...</a><br /></td></tr>
<tr class="separator:ac11774735d9ba0fcb7bec841a5943617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4370eaaabc09dcc77e4022adee0de20a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a4370eaaabc09dcc77e4022adee0de20a">erase</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:a4370eaaabc09dcc77e4022adee0de20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing an element from the sparse subvector.  <a href="#a4370eaaabc09dcc77e4022adee0de20a">More...</a><br /></td></tr>
<tr class="separator:a4370eaaabc09dcc77e4022adee0de20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2640d7bd25dfbf1072340f98ac149e68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2640d7bd25dfbf1072340f98ac149e68">erase</a> (<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a> pos)</td></tr>
<tr class="memdesc:a2640d7bd25dfbf1072340f98ac149e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing an element from the sparse subvector.  <a href="#a2640d7bd25dfbf1072340f98ac149e68">More...</a><br /></td></tr>
<tr class="separator:a2640d7bd25dfbf1072340f98ac149e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656b708f4c9e019c07b2812b6f76a83c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a656b708f4c9e019c07b2812b6f76a83c">erase</a> (<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a> first, <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a> last)</td></tr>
<tr class="memdesc:a656b708f4c9e019c07b2812b6f76a83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing a range of elements from the sparse subvector.  <a href="#a656b708f4c9e019c07b2812b6f76a83c">More...</a><br /></td></tr>
<tr class="separator:a656b708f4c9e019c07b2812b6f76a83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4348513a2b89c5d33c6eb9d9a28b3e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#af4348513a2b89c5d33c6eb9d9a28b3e1">reserve</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:af4348513a2b89c5d33c6eb9d9a28b3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the minimum capacity of the sparse subvector.  <a href="#af4348513a2b89c5d33c6eb9d9a28b3e1">More...</a><br /></td></tr>
<tr class="separator:af4348513a2b89c5d33c6eb9d9a28b3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32da7a15aa1bf8cd45d15306b5ea64bf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a32da7a15aa1bf8cd45d15306b5ea64bf"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a32da7a15aa1bf8cd45d15306b5ea64bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scale</b> (const Other &amp;scalar)</td></tr>
<tr class="separator:a32da7a15aa1bf8cd45d15306b5ea64bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Lookup functions</div></td></tr>
<tr class="memitem:ae8a48db28c4e7f70a5a9d44e3b22ef99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ae8a48db28c4e7f70a5a9d44e3b22ef99">find</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:ae8a48db28c4e7f70a5a9d44e3b22ef99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a specific subvector element.  <a href="#ae8a48db28c4e7f70a5a9d44e3b22ef99">More...</a><br /></td></tr>
<tr class="separator:ae8a48db28c4e7f70a5a9d44e3b22ef99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840006a0b2e7dd2310a60a57f17e841f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a840006a0b2e7dd2310a60a57f17e841f">find</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:a840006a0b2e7dd2310a60a57f17e841f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a specific subvector element.  <a href="#a840006a0b2e7dd2310a60a57f17e841f">More...</a><br /></td></tr>
<tr class="separator:a840006a0b2e7dd2310a60a57f17e841f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccdb9dc09c312dbc01ae2f5cdaeb1c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a6ccdb9dc09c312dbc01ae2f5cdaeb1c7">lowerBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:a6ccdb9dc09c312dbc01ae2f5cdaeb1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index not less then the given index.  <a href="#a6ccdb9dc09c312dbc01ae2f5cdaeb1c7">More...</a><br /></td></tr>
<tr class="separator:a6ccdb9dc09c312dbc01ae2f5cdaeb1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15199752dd10f92a1f9da643e3c0581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#af15199752dd10f92a1f9da643e3c0581">lowerBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:af15199752dd10f92a1f9da643e3c0581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index not less then the given index.  <a href="#af15199752dd10f92a1f9da643e3c0581">More...</a><br /></td></tr>
<tr class="separator:af15199752dd10f92a1f9da643e3c0581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b68272b52f5f6351cdbb821efa49c67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a9b68272b52f5f6351cdbb821efa49c67">upperBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:a9b68272b52f5f6351cdbb821efa49c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index greater then the given index.  <a href="#a9b68272b52f5f6351cdbb821efa49c67">More...</a><br /></td></tr>
<tr class="separator:a9b68272b52f5f6351cdbb821efa49c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff247b8d017f4480b8359390d3971cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a9ff247b8d017f4480b8359390d3971cc">upperBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:a9ff247b8d017f4480b8359390d3971cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index greater then the given index.  <a href="#a9ff247b8d017f4480b8359390d3971cc">More...</a><br /></td></tr>
<tr class="separator:a9ff247b8d017f4480b8359390d3971cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low-level utility functions</div></td></tr>
<tr class="memitem:a515029ccb18f911c73d50e4d4f7ab720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a515029ccb18f911c73d50e4d4f7ab720">append</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a69745dee26e3b78dd0b8fb50447eda4c">ElementType</a> &amp;value, bool check=false)</td></tr>
<tr class="memdesc:a515029ccb18f911c73d50e4d4f7ab720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appending an element to the sparse subvector.  <a href="#a515029ccb18f911c73d50e4d4f7ab720">More...</a><br /></td></tr>
<tr class="separator:a515029ccb18f911c73d50e4d4f7ab720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression template evaluation functions</div></td></tr>
<tr class="memitem:a519144805f01714379a706776394819b"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a519144805f01714379a706776394819b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a519144805f01714379a706776394819b">canAlias</a> (const Other *alias) const </td></tr>
<tr class="memdesc:a519144805f01714379a706776394819b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the sparse subvector can alias with the given address <em>alias</em>.  <a href="#a519144805f01714379a706776394819b">More...</a><br /></td></tr>
<tr class="separator:a519144805f01714379a706776394819b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875426d8b52a18ee22cb93a4d7d2071d"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a875426d8b52a18ee22cb93a4d7d2071d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a875426d8b52a18ee22cb93a4d7d2071d">isAliased</a> (const Other *alias) const </td></tr>
<tr class="memdesc:a875426d8b52a18ee22cb93a4d7d2071d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the sparse subvector is aliased with the given address <em>alias</em>.  <a href="#a875426d8b52a18ee22cb93a4d7d2071d">More...</a><br /></td></tr>
<tr class="separator:a875426d8b52a18ee22cb93a4d7d2071d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5337ab9e872eff5b2358b2054bdf392"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ae5337ab9e872eff5b2358b2054bdf392">canSMPAssign</a> () const </td></tr>
<tr class="memdesc:ae5337ab9e872eff5b2358b2054bdf392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the subvector can be used in SMP assignments.  <a href="#ae5337ab9e872eff5b2358b2054bdf392">More...</a><br /></td></tr>
<tr class="separator:ae5337ab9e872eff5b2358b2054bdf392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3eca07583fcd8391e860ea9be8c642"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a2a3eca07583fcd8391e860ea9be8c642"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2a3eca07583fcd8391e860ea9be8c642">assign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2a3eca07583fcd8391e860ea9be8c642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a dense vector.  <a href="#a2a3eca07583fcd8391e860ea9be8c642">More...</a><br /></td></tr>
<tr class="separator:a2a3eca07583fcd8391e860ea9be8c642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af463421bb8fabe2ab6c1ba7ca7dcae2b"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:af463421bb8fabe2ab6c1ba7ca7dcae2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#af463421bb8fabe2ab6c1ba7ca7dcae2b">assign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af463421bb8fabe2ab6c1ba7ca7dcae2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a sparse vector.  <a href="#af463421bb8fabe2ab6c1ba7ca7dcae2b">More...</a><br /></td></tr>
<tr class="separator:af463421bb8fabe2ab6c1ba7ca7dcae2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4699c0e5427e211f6987832ce077a45a"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a4699c0e5427e211f6987832ce077a45a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a4699c0e5427e211f6987832ce077a45a">addAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4699c0e5427e211f6987832ce077a45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a dense vector.  <a href="#a4699c0e5427e211f6987832ce077a45a">More...</a><br /></td></tr>
<tr class="separator:a4699c0e5427e211f6987832ce077a45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fee3ee7836b33a27ad9b5eadca9cea"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ab9fee3ee7836b33a27ad9b5eadca9cea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ab9fee3ee7836b33a27ad9b5eadca9cea">addAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab9fee3ee7836b33a27ad9b5eadca9cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a sparse vector.  <a href="#ab9fee3ee7836b33a27ad9b5eadca9cea">More...</a><br /></td></tr>
<tr class="separator:ab9fee3ee7836b33a27ad9b5eadca9cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5d45f3b7949a4e9f97f223668a831d"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a5c5d45f3b7949a4e9f97f223668a831d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a5c5d45f3b7949a4e9f97f223668a831d">subAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5c5d45f3b7949a4e9f97f223668a831d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a dense vector.  <a href="#a5c5d45f3b7949a4e9f97f223668a831d">More...</a><br /></td></tr>
<tr class="separator:a5c5d45f3b7949a4e9f97f223668a831d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe53367561655522a5827c7185a10617"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:abe53367561655522a5827c7185a10617"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#abe53367561655522a5827c7185a10617">subAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:abe53367561655522a5827c7185a10617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a sparse vector.  <a href="#abe53367561655522a5827c7185a10617">More...</a><br /></td></tr>
<tr class="separator:abe53367561655522a5827c7185a10617"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:gad45404533dd8a1a215df040e42195781"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>useConst</b> = IsConst&lt;VT&gt;::value
 }</td></tr>
<tr class="memdesc:gad45404533dd8a1a215df040e42195781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the non-const reference and iterator types.  <a href="../../d8/de4/group__sparse__subvector.html#gad45404533dd8a1a215df040e42195781">More...</a><br /></td></tr>
<tr class="separator:gad45404533dd8a1a215df040e42195781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4da70494ad4be7f7ac090d61616713e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4da70494ad4be7f7ac090d61616713e"></a>
typedef <a class="el" href="../../d7/d0c/structblaze_1_1If.html">If</a>&lt; <a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html">IsExpression</a>&lt; VT &gt;, VT, VT &amp; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ac4da70494ad4be7f7ac090d61616713e">Operand</a></td></tr>
<tr class="memdesc:ac4da70494ad4be7f7ac090d61616713e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite data type of the sparse vector expression. <br /></td></tr>
<tr class="separator:ac4da70494ad4be7f7ac090d61616713e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:aefb3d621cac5f8e694a4ab1586e7ed27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefb3d621cac5f8e694a4ab1586e7ed27"></a>
<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ac4da70494ad4be7f7ac090d61616713e">Operand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#aefb3d621cac5f8e694a4ab1586e7ed27">vector_</a></td></tr>
<tr class="memdesc:aefb3d621cac5f8e694a4ab1586e7ed27"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sparse vector containing the subvector. <br /></td></tr>
<tr class="separator:aefb3d621cac5f8e694a4ab1586e7ed27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fcaed239a427d47f0b8d240134d2b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9fcaed239a427d47f0b8d240134d2b7"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#af9fcaed239a427d47f0b8d240134d2b7">offset_</a></td></tr>
<tr class="memdesc:af9fcaed239a427d47f0b8d240134d2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The offset of the subvector within the sparse vector. <br /></td></tr>
<tr class="separator:af9fcaed239a427d47f0b8d240134d2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349a720db23564b2dea235dea1c91e9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a349a720db23564b2dea235dea1c91e9d"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a349a720db23564b2dea235dea1c91e9d">size_</a></td></tr>
<tr class="memdesc:a349a720db23564b2dea235dea1c91e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the subvector. <br /></td></tr>
<tr class="separator:a349a720db23564b2dea235dea1c91e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt;<br />
class blaze::SparseSubvector&lt; VT, AF, TF &gt;</h3>

<p><a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> on a specific subvector of a sparse vector.</p>
<p>The <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html" title="View on a specific subvector of a sparse vector.The SparseSubvector template represents a view on a s...">SparseSubvector</a> template represents a view on a specific subvector of a sparse vector primitive. The type of the sparse vector is specified via the first template parameter: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> VT, <span class="keywordtype">bool</span> AF, <span class="keywordtype">bool</span> TF &gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#aa1eac4598c99f25e628ca254ca1fdbe7">SparseSubvector</a>;</div>
</div><!-- fragment --><ul>
<li>VT: specifies the type of the sparse vector primitive. <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html" title="View on a specific subvector of a sparse vector.The SparseSubvector template represents a view on a s...">SparseSubvector</a> can be used with every sparse vector primitive or view, but does not work with any vector expression type.</li>
<li>AF: the alignment flag specifies whether the subvector is aligned (<em><a class="el" href="../../d2/de9/namespaceblaze.html#a30a412c45e10cff7eba4dacc999d55c7" title="Alignment flag for aligned subvectors and submatrices. ">blaze::aligned</a></em>) or unaligned (<em><a class="el" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5" title="Alignment flag for unaligned subvectors and submatrices. ">blaze::unaligned</a></em>). The default value is <em><a class="el" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5" title="Alignment flag for unaligned subvectors and submatrices. ">blaze::unaligned</a></em>.</li>
<li>TF: specifies whether the vector is a row vector (<em><a class="el" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors. ">blaze::rowVector</a></em>) or a column vector (<em><a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors. ">blaze::columnVector</a></em>). This template parameter doesn't have to be explicitly defined, but is automatically derived from the first template parameter.</li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="sparse_subvector_setup"></a>
Setup of Sparse Subvectors</h1>
<p>A view on a sparse subvector can be created very conveniently via the <code><a class="el" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c" title="Creating a view on a specific subvector of the given vector. ">subvector()</a></code> function:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::rowVector&gt;</a>  SparseVectorType;</div>
<div class="line"></div>
<div class="line">SparseVectorType x;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a subvector from index 8 with a size of 16 (i.e. in the range [8..23])</span></div>
<div class="line"><a class="code" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector&lt;SparseVectorType&gt;</a> sv = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( x, 8UL, 16UL );</div>
</div><!-- fragment --><p>This view can be treated as any other sparse vector, i.e. it can be assigned to, it can be copied from, and it can be used in arithmetic operations. The view can also be used on both sides of an assignment: The subvector can either be used as an alias to grant write access to a specific subvector of a sparse vector primitive on the left-hand side of an assignment or to grant read-access to a specific subvector of a sparse vector primitive or expression on the right-hand side of an assignment. The following example demonstrates this in detail:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,blaze::rowVector&gt;</a>     DenseVectorType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::rowVector&gt;</a>  SparseVectorType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::rowMajor&gt;</a>   SparseMatrixType;</div>
<div class="line"></div>
<div class="line">DenseVectorType  x;</div>
<div class="line">SparseVectorType y;</div>
<div class="line">SparseMatrixType A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a subvector from index 0UL with a size of 10 (i.e. in the range [0..9])</span></div>
<div class="line"><a class="code" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector&lt;SparseVectorType&gt;</a> sv = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( y, 0UL, 10UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the first ten elements of y to the 2nd row of matrix A</span></div>
<div class="line">sv = <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 2UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the second ten elements of y to x</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( y, 10UL, 10UL ) = x;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the 3rd row of A to a subvector of y</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 3UL ) = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( y, 3UL, 10UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting y to a subvector of the result of the addition between x and the 1st row of A</span></div>
<div class="line">y = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( x + <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 1UL ), 2UL, 5UL )</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_subvector_element_access"></a>
Element access</h1>
<p>A sparse subvector can be used like any other sparse vector. For instance, the elements of the sparse subvector can be directly accessed with the subscript operator.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::rowVector&gt;</a>  <a class="code" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>;</div>
<div class="line">VectorType v;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating an 8-dimensional subvector, starting from index 4</span></div>
<div class="line"><a class="code" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector&lt;VectorType&gt;</a> sv = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( v, 4UL, 8UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the 1st element of the subvector, which corresponds to</span></div>
<div class="line"><span class="comment">// the element at index 5 in vector v</span></div>
<div class="line">sv[1] = 2.0;</div>
</div><!-- fragment --><p>The numbering of the subvector elements is</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; 1 &amp; 2 &amp; \cdots &amp; N-1 \\ \end{array}\right),\]" src="../../form_20.png"/>
</p>
<p>where N is the specified size of the subvector. Alternatively, the elements of a subvector can be traversed via iterators. Just as with vectors, in case of non-const subvectors, <code><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#aabcc4a0f29390134b377f7c93f7bf518" title="Returns an iterator to the first element of the subvector. ">begin()</a></code> and <code><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a635a335fd90466c548ab984d651090df" title="Returns an iterator just past the last element of the subvector. ">end()</a></code> return an Iterator, which allows a manipulation of the non-zero values, in case of constant subvectors a ConstIterator is returned:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;int,blaze::rowVector&gt;</a>  <a class="code" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector&lt;VectorType&gt;</a>             SubvectorType;</div>
<div class="line"></div>
<div class="line">VectorType v( 256UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a reference to a specific subvector of vector v</span></div>
<div class="line">SubvectorType sv = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( v, 16UL, 64UL );</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">SubvectorType::Iterator</a> it=sv.begin(); it!=sv.end(); ++it ) {</div>
<div class="line">   it-&gt;value() = ...;  <span class="comment">// OK: Write access to the value of the non-zero element.</span></div>
<div class="line">   ... = it-&gt;value();  <span class="comment">// OK: Read access to the value of the non-zero element.</span></div>
<div class="line">   it-&gt;index() = ...;  <span class="comment">// Compilation error: The index of a non-zero element cannot be changed.</span></div>
<div class="line">   ... = it-&gt;index();  <span class="comment">// OK: Read access to the index of the sparse element.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">SubvectorType::ConstIterator</a> it=sv.begin(); it!=sv.end(); ++it ) {</div>
<div class="line">   it-&gt;value() = ...;  <span class="comment">// Compilation error: Assignment to the value via a ConstIterator is invalid.</span></div>
<div class="line">   ... = it-&gt;value();  <span class="comment">// OK: Read access to the value of the non-zero element.</span></div>
<div class="line">   it-&gt;index() = ...;  <span class="comment">// Compilation error: The index of a non-zero element cannot be changed.</span></div>
<div class="line">   ... = it-&gt;index();  <span class="comment">// OK: Read access to the index of the sparse element.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_subvector_element_insertion"></a>
Element Insertion</h1>
<p>Inserting/accessing elements in a sparse subvector can be done by several alternative functions. The following example demonstrates all options:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::rowVector&gt;</a>  <a class="code" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>;</div>
<div class="line">VectorType v( 256UL );  <span class="comment">// Non-initialized vector of size 256</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector&lt;VectorType&gt;</a>  SubvectorType;</div>
<div class="line">SubvectorType sv( <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( v, 10UL, 60UL ) );  <span class="comment">// View on the range [10..69] of v</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// The subscript operator provides access to all possible elements of the sparse subvector,</span></div>
<div class="line"><span class="comment">// including the zero elements. In case the subscript operator is used to access an element</span></div>
<div class="line"><span class="comment">// that is currently not stored in the sparse subvector, the element is inserted into the</span></div>
<div class="line"><span class="comment">// subvector.</span></div>
<div class="line">sv[42] = 2.0;</div>
<div class="line"></div>
<div class="line"><span class="comment">// The second operation for inserting elements is the set() function. In case the element is</span></div>
<div class="line"><span class="comment">// not contained in the subvector it is inserted into the subvector, if it is already contained</span></div>
<div class="line"><span class="comment">// in the subvector its value is modified.</span></div>
<div class="line">sv.set( 45UL, -1.2 );</div>
<div class="line"></div>
<div class="line"><span class="comment">// An alternative for inserting elements into the subvector is the insert() function. However,</span></div>
<div class="line"><span class="comment">// it inserts the element only in case the element is not already contained in the subvector.</span></div>
<div class="line">sv.insert( 50UL, 3.7 );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Just as in case of vectors, elements can also be inserted via the append() function. In</span></div>
<div class="line"><span class="comment">// case of subvectors, append() also requires that the appended element&#39;s index is strictly</span></div>
<div class="line"><span class="comment">// larger than the currently largest non-zero index of the subvector and that the subvector&#39;s</span></div>
<div class="line"><span class="comment">// capacity is large enough to hold the new element. Note however that due to the nature of</span></div>
<div class="line"><span class="comment">// a subvector, which may be an alias to the middle of a sparse vector, the append() function</span></div>
<div class="line"><span class="comment">// does not work as efficiently for a subvector as it does for a vector.</span></div>
<div class="line">sv.reserve( 10UL );</div>
<div class="line">sv.append( 51UL, -2.1 );</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_subvector_common_operations"></a>
Common Operations</h1>
<p>The current number of subvector elements can be obtained via the <code><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a68d113f4cf17b9a74a71821f41801487" title="Returns the size/dimension of the sparse subvector. ">size()</a></code> function, the current capacity via the <code><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ae671c3757f2b5d250cacdc3a54bff4f8" title="Returns the maximum capacity of the sparse subvector. ">capacity()</a></code> function, and the number of non-zero elements via the <code><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a6085963be3def4cda89f3241bff79ef5" title="Returns the number of non-zero elements in the subvector. ">nonZeros()</a></code> function. However, since subvector are views on a specific subvector of a vector, several operations are not possible on views, such as resizing and swapping:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;int,blaze::rowVector&gt;</a>  <a class="code" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector&lt;VectorType&gt;</a>             SubvectorType;</div>
<div class="line"></div>
<div class="line">VectorType v( 42UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a view on the range [5..15] of vector v</span></div>
<div class="line">SubvectorType sv = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( v, 5UL, 10UL );</div>
<div class="line"></div>
<div class="line">sv.size();          <span class="comment">// Returns the number of elements in the subvector</span></div>
<div class="line">sv.capacity();      <span class="comment">// Returns the capacity of the subvector</span></div>
<div class="line">sv.nonZeros();      <span class="comment">// Returns the number of non-zero elements contained in the subvector</span></div>
<div class="line"></div>
<div class="line">sv.resize( 84UL );  <span class="comment">// Compilation error: Cannot resize a subvector of a vector</span></div>
<div class="line"></div>
<div class="line">SubvectorType sv2 = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( v, 15UL, 10UL );</div>
<div class="line"><a class="code" href="../../d0/d90/group__diagonal__matrix.html#ga172895200063f120b6ffd241af12bbae">swap</a>( sv, sv2 );   <span class="comment">// Compilation error: Swap operation not allowed</span></div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_subvector_arithmetic_operations"></a>
Arithmetic Operations</h1>
<p>The following example gives an impression of the use of <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html" title="View on a specific subvector of a sparse vector.The SparseSubvector template represents a view on a s...">SparseSubvector</a> within arithmetic operations. All operations (addition, subtraction, multiplication, scaling, ...) can be performed on all possible combinations of dense and sparse vectors with fitting element types:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::rowVector&gt;</a>  SparseVectorType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,blaze::rowVector&gt;</a>     DenseVectorType;</div>
<div class="line">SparseVectorType s1, s2, s3;</div>
<div class="line">DenseVectorType d1, d2;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::rowMajor&gt;</a>  SparseMatrixType;</div>
<div class="line">SparseMatrixType A;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector&lt;SparseVectorType&gt;</a>  SubvectorType;</div>
<div class="line">SubvectorType sv( <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( s1, 0UL, 10UL ) );  <span class="comment">// View on the range [0..9] of vector s1</span></div>
<div class="line"></div>
<div class="line">sv = s2;                           <span class="comment">// Sparse vector initialization of the range [0..9]</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( s1, 10UL, 10UL ) = d1;  <span class="comment">// Dense vector initialization of the range [10..19]</span></div>
<div class="line"></div>
<div class="line">s3 = sv + s2;                           <span class="comment">// Sparse vector/sparse vector addition</span></div>
<div class="line">d2 = d1 + <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( s1, 10UL, 10UL );  <span class="comment">// Dense vector/sparse vector addition</span></div>
<div class="line">s2 = sv * <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( s1, 20UL, 10UL );  <span class="comment">// Component-wise vector multiplication</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( s1, 3UL, 4UL ) *= 2.0;      <span class="comment">// In-place scaling of the range [3..6]</span></div>
<div class="line">s2 = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( s1, 7UL, 3UL ) * 2.0;  <span class="comment">// Scaling of the range [7..9]</span></div>
<div class="line">s2 = 2.0 * <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( s1, 7UL, 3UL );  <span class="comment">// Scaling of the range [7..9]</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( s1, 0UL , 10UL ) += s2;  <span class="comment">// Addition assignment</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( s1, 10UL, 10UL ) -= d2;  <span class="comment">// Subtraction assignment</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( s1, 20UL, 10UL ) *= sv;  <span class="comment">// Multiplication assignment</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> scalar = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( s1, 5UL, 10UL ) * <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( d1 );  <span class="comment">// Scalar/dot/inner product between two vectors</span></div>
<div class="line"></div>
<div class="line">A = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( d1 ) * <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( s1, 4UL, 16UL );  <span class="comment">// Outer product between two vectors</span></div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_subvector_aligned_subvector"></a>
Aligned Subvectors</h1>
<p>Usually subvectors can be defined anywhere within a vector. They may start at any position and may have an arbitrary size (only restricted by the size of the underlying vector). However, in contrast to vectors themselves, which are always properly aligned in memory and therefore can provide maximum performance, this means that subvectors in general have to be considered to be unaligned. This can be made explicit by the <em><a class="el" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5" title="Alignment flag for unaligned subvectors and submatrices. ">blaze::unaligned</a></em> flag:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5">blaze::unaligned</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::rowVector&gt;</a>  SparseVectorType;</div>
<div class="line"></div>
<div class="line">SparseVectorType x;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Identical creations of an unaligned subvector in the range [8..23]</span></div>
<div class="line"><a class="code" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector&lt;SparseVectorType&gt;</a>           sv1 = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>           ( x, 8UL, 16UL );</div>
<div class="line"><a class="code" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector&lt;SparseVectorType&gt;</a>           sv2 = subvector&lt;unaligned&gt;( x, 8UL, 16UL );</div>
<div class="line"><a class="code" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector&lt;SparseVectorType,unaligned&gt;</a> sv3 = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>           ( x, 8UL, 16UL );</div>
<div class="line"><a class="code" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector&lt;SparseVectorType,unaligned&gt;</a> sv4 = subvector&lt;unaligned&gt;( x, 8UL, 16UL );</div>
</div><!-- fragment --><p>All of these calls to the <code><a class="el" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c" title="Creating a view on a specific subvector of the given vector. ">subvector()</a></code> function are identical. Whether the alignment flag is explicitly specified or not, it always returns an unaligned subvector. Whereas this may provide full flexibility in the creation of subvectors, this might result in performance restrictions (even in case the specified subvector could be aligned). However, it is also possible to create aligned subvectors. Aligned subvectors are identical to unaligned subvectors in all aspects, except that they may pose additional alignment restrictions and therefore have less flexibility during creation. These restrictions may limit their application, but due to that they don't suffer from performance penalties and provide the same performance as the underlying vector. Aligned subvectors are created by explicitly specifying the <em><a class="el" href="../../d2/de9/namespaceblaze.html#a30a412c45e10cff7eba4dacc999d55c7" title="Alignment flag for aligned subvectors and submatrices. ">blaze::aligned</a></em> flag:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a30a412c45e10cff7eba4dacc999d55c7">blaze::aligned</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating an aligned subvector in the range [8..23]</span></div>
<div class="line"><a class="code" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector&lt;SparseVectorType,aligned&gt;</a> sv = subvector&lt;aligned&gt;( x, 8UL, 16UL );</div>
</div><!-- fragment --><p>In contrast to dense subvectors, which pose several additional alignment restrictions based on the used element type, sparse subvectors at this time don't pose any additional restrictions. Therefore aligned and unaligned sparse subvectors are truly fully identical. Note however that this is not true for dense subvectors (see the <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html" title="View on a specific subvector of a dense vector.The DenseSubvector template represents a view on a spe...">DenseSubvector</a> class description)!</p>
<p><br />
 </p>
<h1><a class="anchor" id="sparse_subvector_on_sparse_subvector"></a>
Subvectors on Subvectors</h1>
<p>It is also possible to create a subvector view on another subvector. In this context it is important to remember that the type returned by the <code><a class="el" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c" title="Creating a view on a specific subvector of the given vector. ">subvector()</a></code> function is the same type as the type of the given subvector, since the view on a subvector is just another view on the underlying sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::rowVector&gt;</a>  <a class="code" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector&lt;VectorType&gt;</a>                SubvectorType;</div>
<div class="line"></div>
<div class="line">VectorType s1;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a subvector view on the sparse vector s1</span></div>
<div class="line">SubvectorType sv1 = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( s1, 5UL, 10UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a subvector view on the sparse subvector sv1</span></div>
<div class="line">SubvectorType sv2 = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( sv1, 1UL, 5UL );</div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa1eac4598c99f25e628ca254ca1fdbe7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ac4da70494ad4be7f7ac090d61616713e">Operand</a>&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constructor for <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html" title="View on a specific subvector of a sparse vector.The SparseSubvector template represents a view on a s...">SparseSubvector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>The sparse vector containing the subvector. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the first element of the subvector. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the subvector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid subvector specification.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the subvector is not properly specified (i.e. if the specified first index is larger than the size of the given vector or the subvector is specified beyond the size of the vector) a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4699c0e5427e211f6987832ce077a45a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ab9fee3ee7836b33a27ad9b5eadca9cea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a515029ccb18f911c73d50e4d4f7ab720"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a69745dee26e3b78dd0b8fb50447eda4c">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appending an element to the sparse subvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to be appended. </td></tr>
    <tr><td class="paramname">check</td><td><em>true</em> if the new value should be checked for default values, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function provides a very efficient way to fill a sparse subvector with elements. It appends a new element to the end of the sparse subvector without any memory allocation. Therefore it is strictly necessary to keep the following preconditions in mind:</p>
<ul>
<li>the index of the new element must be strictly larger than the largest index of non-zero elements in the sparse subvector</li>
<li>the current number of non-zero elements must be smaller than the capacity of the subvector</li>
</ul>
<p>Ignoring these preconditions might result in undefined behavior! The optional <em>check</em> parameter specifies whether the new value should be tested for a default value. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the new value is a default value (for instance 0 in case of an integral element type) the value is not appended. Per default the values are not tested.</p>
<p><b>Note:</b> Although <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a515029ccb18f911c73d50e4d4f7ab720" title="Appending an element to the sparse subvector. ">append()</a> does not allocate new memory, it still invalidates all iterators returned by the <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a635a335fd90466c548ab984d651090df" title="Returns an iterator just past the last element of the subvector. ">end()</a> functions! </p>

</div>
</div>
<a class="anchor" id="a2a3eca07583fcd8391e860ea9be8c642"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="af463421bb8fabe2ab6c1ba7ca7dcae2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="aabcc4a0f29390134b377f7c93f7bf518"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the subvector.</dd></dl>
<p>This function returns an iterator to the first element of the subvector. </p>

</div>
</div>
<a class="anchor" id="ac08b5983c392a2463832515e159c29d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the subvector.</dd></dl>
<p>This function returns an iterator to the first element of the subvector. </p>

</div>
</div>
<a class="anchor" id="a519144805f01714379a706776394819b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::canAlias </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the sparse subvector can alias with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this sparse subvector, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address can alias with the sparse subvector. In contrast to the <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a875426d8b52a18ee22cb93a4d7d2071d" title="Returns whether the sparse subvector is aliased with the given address alias. ">isAliased()</a> function this function is allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="ae5337ab9e872eff5b2358b2054bdf392"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::canSMPAssign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the subvector can be used in SMP assignments. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the subvector can be used in SMP assignments, <em>false</em> if not.</dd></dl>
<p>This function returns whether the subvector can be used in SMP assignments. In contrast to the <em>smpAssignable</em> member enumeration, which is based solely on compile time information, this function additionally provides runtime information (as for instance the current size of the vector). </p>

</div>
</div>
<a class="anchor" id="ae671c3757f2b5d250cacdc3a54bff4f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the sparse subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the sparse subvector. </dd></dl>

</div>
</div>
<a class="anchor" id="afea6a16d7540099fd09b2b719db5b38c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the subvector.</dd></dl>
<p>This function returns an iterator to the first element of the subvector. </p>

</div>
</div>
<a class="anchor" id="ace45b3a5d811443f195c494fcd4fc81a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the subvector.</dd></dl>
<p>This function returns an iterator just past the last element of the subvector. </p>

</div>
</div>
<a class="anchor" id="a635a335fd90466c548ab984d651090df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the subvector.</dd></dl>
<p>This function returns an iterator just past the last element of the subvector. </p>

</div>
</div>
<a class="anchor" id="acc7efe87973adbf69c811a558bae9bf1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the subvector.</dd></dl>
<p>This function returns an iterator just past the last element of the subvector. </p>

</div>
</div>
<a class="anchor" id="a4370eaaabc09dcc77e4022adee0de20a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing an element from the sparse subvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the element to be erased. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function erases an element from the sparse subvector. </p>

</div>
</div>
<a class="anchor" id="a2640d7bd25dfbf1072340f98ac149e68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing an element from the sparse subvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function erases an element from the sparse subvector. </p>

</div>
</div>
<a class="anchor" id="a656b708f4c9e019c07b2812b6f76a83c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing a range of elements from the sparse subvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to first element to be erased. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator just past the last element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element after the erased element.</dd></dl>
<p>This function erases a range of elements from the sparse subvector. </p>

</div>
</div>
<a class="anchor" id="ae8a48db28c4e7f70a5a9d44e3b22ef99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for a specific subvector element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element in case the index is found, <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a635a335fd90466c548ab984d651090df" title="Returns an iterator just past the last element of the subvector. ">end()</a> iterator otherwise.</dd></dl>
<p>This function can be used to check whether a specific element is contained in the sparse subvector. It specifically searches for the element with index <em>index</em>. In case the element is found, the function returns an iterator to the element. Otherwise an iterator just past the last non-zero element of the sparse subvector (the <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a635a335fd90466c548ab984d651090df" title="Returns an iterator just past the last element of the subvector. ">end()</a> iterator) is returned. Note that the returned sparse subvector iterator is subject to invalidation due to inserting operations via the subscript operator or the <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ac11774735d9ba0fcb7bec841a5943617" title="Inserting an element into the sparse subvector. ">insert()</a> function! </p>

</div>
</div>
<a class="anchor" id="a840006a0b2e7dd2310a60a57f17e841f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for a specific subvector element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element in case the index is found, <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a635a335fd90466c548ab984d651090df" title="Returns an iterator just past the last element of the subvector. ">end()</a> iterator otherwise.</dd></dl>
<p>This function can be used to check whether a specific element is contained in the sparse subvector. It specifically searches for the element with index <em>index</em>. In case the element is found, the function returns an iterator to the element. Otherwise an iterator just past the last non-zero element of the sparse subvector (the <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a635a335fd90466c548ab984d651090df" title="Returns an iterator just past the last element of the subvector. ">end()</a> iterator) is returned. Note that the returned sparse subvector iterator is subject to invalidation due to inserting operations via the subscript operator or the <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ac11774735d9ba0fcb7bec841a5943617" title="Inserting an element into the sparse subvector. ">insert()</a> function! </p>

</div>
</div>
<a class="anchor" id="ac11774735d9ba0fcb7bec841a5943617"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a69745dee26e3b78dd0b8fb50447eda4c">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserting an element into the sparse subvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the inserted value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid sparse subvector access index.</td></tr>
  </table>
  </dd>
</dl>
<p>This function inserts a new element into the sparse subvector. However, duplicate elements are not allowed. In case the sparse subvector already contains an element at index <em>index</em>, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a875426d8b52a18ee22cb93a4d7d2071d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the sparse subvector is aliased with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this sparse subvector, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address is aliased with the sparse subvector. In contrast to the <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a519144805f01714379a706776394819b" title="Returns whether the sparse subvector can alias with the given address alias. ">canAlias()</a> function this function is not allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="a6ccdb9dc09c312dbc01ae2f5cdaeb1c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::lowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index not less then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index not less then the given index, <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a635a335fd90466c548ab984d651090df" title="Returns an iterator just past the last element of the subvector. ">end()</a> iterator otherwise.</dd></dl>
<p>This function returns an iterator to the first element with an index not less then the given index. In combination with the <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a9b68272b52f5f6351cdbb821efa49c67" title="Returns an iterator to the first index greater then the given index. ">upperBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned sparse subvector iterator is subject to invalidation due to inserting operations via the subscript operator or the <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ac11774735d9ba0fcb7bec841a5943617" title="Inserting an element into the sparse subvector. ">insert()</a> function! </p>

</div>
</div>
<a class="anchor" id="af15199752dd10f92a1f9da643e3c0581"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::lowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index not less then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index not less then the given index, <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a635a335fd90466c548ab984d651090df" title="Returns an iterator just past the last element of the subvector. ">end()</a> iterator otherwise.</dd></dl>
<p>This function returns an iterator to the first element with an index not less then the given index. In combination with the <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a9b68272b52f5f6351cdbb821efa49c67" title="Returns an iterator to the first index greater then the given index. ">upperBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned sparse subvector iterator is subject to invalidation due to inserting operations via the subscript operator or the <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ac11774735d9ba0fcb7bec841a5943617" title="Inserting an element into the sparse subvector. ">insert()</a> function! </p>

</div>
</div>
<a class="anchor" id="a6085963be3def4cda89f3241bff79ef5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the subvector.</dd></dl>
<p>Note that the number of non-zero elements is always smaller than the size of the subvector. </p>

</div>
</div>
<a class="anchor" id="ac7df0752d0e8b5424ab0501168922eeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt;VT,AF,TF&gt;&amp; <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}*=\vec{b} $" src="../../form_68.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be multiplied with the sparse subvector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a4347073f5d68011ee3bfafad874c6324"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt;VT,AF,TF&gt; &gt;::Type&amp; <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication between a sparse subvector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_69.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector.</dd></dl>
<p>This operator can only be used for built-in data types. Additionally, the elements of the sparse subvector must support the multiplication assignment operator for the given scalar built-in data type. </p>

</div>
</div>
<a class="anchor" id="adc0b3e6a1e9ad464c3224cf663127f1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt;VT,AF,TF&gt;&amp; <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator for the addition of a vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_66.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be added to the sparse subvector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a662dc288644e3f892d1f24ee49ad416c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt;VT,AF,TF&gt;&amp; <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator for the subtraction of a vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_67.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be subtracted from the sparse subvector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ac73afeec0667b67b3734b7a3338e0e2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt;VT,AF,TF&gt; &gt;::Type&amp; <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator for the division of a sparse subvector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_70.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector.</dd></dl>
<p>This operator can only be used for built-in data types. Additionally, the elements of the sparse subvector must either support the multiplication assignment operator for the given floating point data type or the division assignment operator for the given integral data type. </p>

</div>
</div>
<a class="anchor" id="a9a8a2f8cf64e89b74fa4b2197973753c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &amp; <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator for <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html" title="View on a specific subvector of a sparse vector.The SparseSubvector template represents a view on a s...">SparseSubvector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Sparse subvector to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d6/d66/structblaze_1_1Subvector.html" title="Base class for all subvectors.The Subvector class serves as a tag for all subvectors (i...">Subvector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two subvectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="acd936a3aba37c77f5b262503b2707464"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt;VT,AF,TF&gt;&amp; <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for dense vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Dense vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a016991abe9448ea44e6d60dd8f6996d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt;VT,AF,TF&gt;&amp; <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for different sparse vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Sparse vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="aa18b8c1bea3c9869c054105a5a6c5fb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a0903ae0ae90ead7ad1a9bb44990bd18f">Reference</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the subvector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of subvector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="aa040362125c7483931df604386dd763f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a70fd6b9142c404a4a9b648114f1ddab7">ConstReference</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the subvector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of subvector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="a1be3095780509ea4b0c421bdb15920a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; , TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for non-constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ae37bee20b660eacfcb7a942dc9cdbe19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; , TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="af4348513a2b89c5d33c6eb9d9a28b3e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setting the minimum capacity of the sparse subvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The new minimum capacity of the sparse subvector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function increases the capacity of the sparse subvector to at least <em>n</em> elements. The current values of the subvector elements are preserved. </p>

</div>
</div>
<a class="anchor" id="a5fef7ce5b5d726bee41477b6f1c12829"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to the default initial values. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="ac914eb158938d6706e6d79fabf1836c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt;VT,AF,TF&gt;&amp; <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scaling of the sparse subvector by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_72.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value for the subvector scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the sparse subvector. </dd></dl>

</div>
</div>
<a class="anchor" id="ad97ef016826a9f7c8020b3ff596ce16c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a69745dee26e3b78dd0b8fb50447eda4c">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setting an element of the sparse subvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the set value.</dd></dl>
<p>This function sets the value of an element of the sparse subvector. In case the sparse subvector already contains an element with index <em>index</em> its value is modified, else a new element with the given <em>value</em> is inserted. </p>

</div>
</div>
<a class="anchor" id="a68d113f4cf17b9a74a71821f41801487"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size/dimension of the sparse subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the sparse subvector. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c5d45f3b7949a4e9f97f223668a831d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="abe53367561655522a5827c7185a10617"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a9b68272b52f5f6351cdbb821efa49c67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a2dfe734661072b52dc939ff58a5c8f77">Iterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::upperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index greater then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index greater then the given index, <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a635a335fd90466c548ab984d651090df" title="Returns an iterator just past the last element of the subvector. ">end()</a> iterator otherwise.</dd></dl>
<p>This function returns an iterator to the first element with an index greater then the given index. In combination with the <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a9b68272b52f5f6351cdbb821efa49c67" title="Returns an iterator to the first index greater then the given index. ">upperBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned sparse subvector iterator is subject to invalidation due to inserting operations via the subscript operator or the <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ac11774735d9ba0fcb7bec841a5943617" title="Inserting an element into the sparse subvector. ">insert()</a> function! </p>

</div>
</div>
<a class="anchor" id="a9ff247b8d017f4480b8359390d3971cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a760387b79b2503d6901ed08678ed06a5">ConstIterator</a> <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector</a>&lt; VT, AF, TF &gt;::upperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index greater then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index greater then the given index, <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a635a335fd90466c548ab984d651090df" title="Returns an iterator just past the last element of the subvector. ">end()</a> iterator otherwise.</dd></dl>
<p>This function returns an iterator to the first element with an index greater then the given index. In combination with the <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#a9b68272b52f5f6351cdbb821efa49c67" title="Returns an iterator to the first index greater then the given index. ">upperBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned sparse subvector iterator is subject to invalidation due to inserting operations via the subscript operator or the <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html#ac11774735d9ba0fcb7bec841a5943617" title="Inserting an element into the sparse subvector. ">insert()</a> function! </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>blaze/math/views/<a class="el" href="../../d2/d24/views_2Forward_8h_source.html">Forward.h</a></li>
<li>blaze/math/views/<a class="el" href="../../d6/dd8/views_2SparseSubvector_8h_source.html">SparseSubvector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:55:26 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
