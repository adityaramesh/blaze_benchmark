<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>blaze::SparseRow&lt; MT, SO, SF &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="../../d6/d29/classblaze_1_1SparseRow-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::SparseRow&lt; MT, SO, SF &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../d0/d48/group__views.html">Views</a> &raquo; <a class="el" href="../../d3/d09/group__sparse__row.html">SparseRow</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Reference to a specific row of a sparse matrix.The <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html" title="Reference to a specific row of a sparse matrix.The SparseRow template represents a reference to a spe...">SparseRow</a> template represents a reference to a specific row of a sparse matrix primitive. The type of the sparse matrix is specified via the first template parameter:  
 <a href="../../d9/dd4/classblaze_1_1SparseRow.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d6/df1/views_2SparseRow_8h_source.html">SparseRow.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">blaze::SparseVector&lt; SparseRow&lt; MT, SO, SF &gt;, true &gt;</a>, and <a class="el" href="../../d3/db7/structblaze_1_1Row.html">blaze::Row</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:gaee2638c6f0aa2c27a06e93567a13ce2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee2638c6f0aa2c27a06e93567a13ce2e"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>smpAssignable</b> = 0
 }</td></tr>
<tr class="memdesc:gaee2638c6f0aa2c27a06e93567a13ce2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the expression template assignment strategy. <br /></td></tr>
<tr class="separator:gaee2638c6f0aa2c27a06e93567a13ce2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ed883cbc36d8a9a2a650b52292ff0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80ed883cbc36d8a9a2a650b52292ff0b"></a>
typedef <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a80ed883cbc36d8a9a2a650b52292ff0b">This</a></td></tr>
<tr class="memdesc:a80ed883cbc36d8a9a2a650b52292ff0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html" title="Reference to a specific row of a sparse matrix.The SparseRow template represents a reference to a spe...">SparseRow</a> instance. <br /></td></tr>
<tr class="separator:a80ed883cbc36d8a9a2a650b52292ff0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea24e3748ad1255886e64d735d2d635"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ea24e3748ad1255886e64d735d2d635"></a>
typedef <a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html">RowTrait</a>&lt; MT &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a3ea24e3748ad1255886e64d735d2d635">ResultType</a></td></tr>
<tr class="memdesc:a3ea24e3748ad1255886e64d735d2d635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br /></td></tr>
<tr class="separator:a3ea24e3748ad1255886e64d735d2d635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa838588f2987d3540c62b03c4bb0f976"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa838588f2987d3540c62b03c4bb0f976"></a>
typedef <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html#a02b3d3c589c780c2abaa5275b79b88ba">ResultType::TransposeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#aa838588f2987d3540c62b03c4bb0f976">TransposeType</a></td></tr>
<tr class="memdesc:aa838588f2987d3540c62b03c4bb0f976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br /></td></tr>
<tr class="separator:aa838588f2987d3540c62b03c4bb0f976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94645f6ae87c9a1b2b01f72965fc9179"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94645f6ae87c9a1b2b01f72965fc9179"></a>
typedef MT::ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a94645f6ae87c9a1b2b01f72965fc9179">ElementType</a></td></tr>
<tr class="memdesc:a94645f6ae87c9a1b2b01f72965fc9179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the row elements. <br /></td></tr>
<tr class="separator:a94645f6ae87c9a1b2b01f72965fc9179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033aff7672d6a74438be9a0d2bab0fb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a033aff7672d6a74438be9a0d2bab0fb8"></a>
typedef MT::ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a033aff7672d6a74438be9a0d2bab0fb8">ReturnType</a></td></tr>
<tr class="memdesc:a033aff7672d6a74438be9a0d2bab0fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br /></td></tr>
<tr class="separator:a033aff7672d6a74438be9a0d2bab0fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f38aef1d99d776e2295eaf8c79fd04b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f38aef1d99d776e2295eaf8c79fd04b"></a>
typedef const <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a0f38aef1d99d776e2295eaf8c79fd04b">CompositeType</a></td></tr>
<tr class="memdesc:a0f38aef1d99d776e2295eaf8c79fd04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br /></td></tr>
<tr class="separator:a0f38aef1d99d776e2295eaf8c79fd04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2981b8bead50b7e612fc330412cd12ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2981b8bead50b7e612fc330412cd12ad"></a>
typedef MT::ConstReference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a2981b8bead50b7e612fc330412cd12ad">ConstReference</a></td></tr>
<tr class="memdesc:a2981b8bead50b7e612fc330412cd12ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant row value. <br /></td></tr>
<tr class="separator:a2981b8bead50b7e612fc330412cd12ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0b90a1116c26b13bde52e8332d1352"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada0b90a1116c26b13bde52e8332d1352"></a>
typedef <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; useConst, <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a2981b8bead50b7e612fc330412cd12ad">ConstReference</a>, typename MT::Reference &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ada0b90a1116c26b13bde52e8332d1352">Reference</a></td></tr>
<tr class="memdesc:ada0b90a1116c26b13bde52e8332d1352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant row value. <br /></td></tr>
<tr class="separator:ada0b90a1116c26b13bde52e8332d1352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8a1376af1b28e14c1be98116d21f59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf8a1376af1b28e14c1be98116d21f59"></a>
typedef MT::ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a></td></tr>
<tr class="memdesc:abf8a1376af1b28e14c1be98116d21f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br /></td></tr>
<tr class="separator:abf8a1376af1b28e14c1be98116d21f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855be5cfd4bf369737ce63b2f1ba9580"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a855be5cfd4bf369737ce63b2f1ba9580"></a>
typedef <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; useConst, <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a>, typename MT::Iterator &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a></td></tr>
<tr class="memdesc:a855be5cfd4bf369737ce63b2f1ba9580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br /></td></tr>
<tr class="separator:a855be5cfd4bf369737ce63b2f1ba9580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe7ddefcf2554b0bced1ad1b4b53e24"></a>
typedef <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a></td></tr>
<tr class="memdesc:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the vector. <br /></td></tr>
<tr class="separator:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4960d3119013e108340bb53fd9053be5"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a4960d3119013e108340bb53fd9053be5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a4960d3119013e108340bb53fd9053be5">operator=</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4960d3119013e108340bb53fd9053be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for dense vectors.  <a href="#a4960d3119013e108340bb53fd9053be5">More...</a><br /></td></tr>
<tr class="separator:a4960d3119013e108340bb53fd9053be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aeeafa54105a633a5d9172cd4cd625c"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a8aeeafa54105a633a5d9172cd4cd625c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a8aeeafa54105a633a5d9172cd4cd625c">operator=</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8aeeafa54105a633a5d9172cd4cd625c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for sparse vectors.  <a href="#a8aeeafa54105a633a5d9172cd4cd625c">More...</a><br /></td></tr>
<tr class="separator:a8aeeafa54105a633a5d9172cd4cd625c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d1b580de66a4638ebbe836c3b2359c"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a18d1b580de66a4638ebbe836c3b2359c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a18d1b580de66a4638ebbe836c3b2359c">operator+=</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a18d1b580de66a4638ebbe836c3b2359c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator for the addition of a dense vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_66.png"/>).  <a href="#a18d1b580de66a4638ebbe836c3b2359c">More...</a><br /></td></tr>
<tr class="separator:a18d1b580de66a4638ebbe836c3b2359c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9edeed3f0bf56cbb0c6152aae27f5e"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a4a9edeed3f0bf56cbb0c6152aae27f5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a4a9edeed3f0bf56cbb0c6152aae27f5e">operator+=</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4a9edeed3f0bf56cbb0c6152aae27f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator for the addition of a sparse vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_66.png"/>).  <a href="#a4a9edeed3f0bf56cbb0c6152aae27f5e">More...</a><br /></td></tr>
<tr class="separator:a4a9edeed3f0bf56cbb0c6152aae27f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2f319ac3df11ba247adeba5bab1f58"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a8d2f319ac3df11ba247adeba5bab1f58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a8d2f319ac3df11ba247adeba5bab1f58">operator-=</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8d2f319ac3df11ba247adeba5bab1f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator for the subtraction of a dense vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_67.png"/>).  <a href="#a8d2f319ac3df11ba247adeba5bab1f58">More...</a><br /></td></tr>
<tr class="separator:a8d2f319ac3df11ba247adeba5bab1f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac607b18ec82c731d4c54fb5117aad2ba"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ac607b18ec82c731d4c54fb5117aad2ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ac607b18ec82c731d4c54fb5117aad2ba">operator-=</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac607b18ec82c731d4c54fb5117aad2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator for the subtraction of a sparse vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_67.png"/>).  <a href="#ac607b18ec82c731d4c54fb5117aad2ba">More...</a><br /></td></tr>
<tr class="separator:ac607b18ec82c731d4c54fb5117aad2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a1f1f58a7011924fce7a35bc480abc"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a01a1f1f58a7011924fce7a35bc480abc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a01a1f1f58a7011924fce7a35bc480abc">operator*=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a01a1f1f58a7011924fce7a35bc480abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}*=\vec{b} $" src="../../form_68.png"/>).  <a href="#a01a1f1f58a7011924fce7a35bc480abc">More...</a><br /></td></tr>
<tr class="separator:a01a1f1f58a7011924fce7a35bc480abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f8a4d62e4f5e400b2d3851f070f5e1"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a24f8a4d62e4f5e400b2d3851f070f5e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a24f8a4d62e4f5e400b2d3851f070f5e1">operator*=</a> (Other rhs)</td></tr>
<tr class="memdesc:a24f8a4d62e4f5e400b2d3851f070f5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication between a sparse row and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_69.png"/>).  <a href="#a24f8a4d62e4f5e400b2d3851f070f5e1">More...</a><br /></td></tr>
<tr class="separator:a24f8a4d62e4f5e400b2d3851f070f5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad712e9a1ac15a7e89a1201ba46a09b61"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ad712e9a1ac15a7e89a1201ba46a09b61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ad712e9a1ac15a7e89a1201ba46a09b61">operator/=</a> (Other rhs)</td></tr>
<tr class="memdesc:ad712e9a1ac15a7e89a1201ba46a09b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator for the division of a sparse row by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_70.png"/>).  <a href="#ad712e9a1ac15a7e89a1201ba46a09b61">More...</a><br /></td></tr>
<tr class="separator:ad712e9a1ac15a7e89a1201ba46a09b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6815acac58e1d7559efce06d8a0eca3b"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a6815acac58e1d7559efce06d8a0eca3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a6815acac58e1d7559efce06d8a0eca3b">scale</a> (const Other &amp;scalar)</td></tr>
<tr class="memdesc:a6815acac58e1d7559efce06d8a0eca3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of the sparse row by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_72.png"/>).  <a href="#a6815acac58e1d7559efce06d8a0eca3b">More...</a><br /></td></tr>
<tr class="separator:a6815acac58e1d7559efce06d8a0eca3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5ff6db7bc31a0d177a0cc84f85dc63"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a5e5ff6db7bc31a0d177a0cc84f85dc63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../df/df0/structblaze_1_1IsRestricted.html">IsRestricted</a>&lt; MT2 &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a5e5ff6db7bc31a0d177a0cc84f85dc63">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5e5ff6db7bc31a0d177a0cc84f85dc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying matrix.  <a href="#a5e5ff6db7bc31a0d177a0cc84f85dc63">More...</a><br /></td></tr>
<tr class="separator:a5e5ff6db7bc31a0d177a0cc84f85dc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049993b58265a49311ed50db14a83995"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a049993b58265a49311ed50db14a83995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a049993b58265a49311ed50db14a83995">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a049993b58265a49311ed50db14a83995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying lower triangular matrix.  <a href="#a049993b58265a49311ed50db14a83995">More...</a><br /></td></tr>
<tr class="separator:a049993b58265a49311ed50db14a83995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c5e84278fb0c55c40272d96767b7b6"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a20c5e84278fb0c55c40272d96767b7b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a20c5e84278fb0c55c40272d96767b7b6">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a20c5e84278fb0c55c40272d96767b7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying lower triangular matrix.  <a href="#a20c5e84278fb0c55c40272d96767b7b6">More...</a><br /></td></tr>
<tr class="separator:a20c5e84278fb0c55c40272d96767b7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0d929929c10f37805a6215dc90a11e"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:afd0d929929c10f37805a6215dc90a11e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#afd0d929929c10f37805a6215dc90a11e">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:afd0d929929c10f37805a6215dc90a11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying upper triangular matrix.  <a href="#afd0d929929c10f37805a6215dc90a11e">More...</a><br /></td></tr>
<tr class="separator:afd0d929929c10f37805a6215dc90a11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700b5db65099caffc7a9dfaf6b575e31"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a700b5db65099caffc7a9dfaf6b575e31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a700b5db65099caffc7a9dfaf6b575e31">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a700b5db65099caffc7a9dfaf6b575e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying upper triangular matrix.  <a href="#a700b5db65099caffc7a9dfaf6b575e31">More...</a><br /></td></tr>
<tr class="separator:a700b5db65099caffc7a9dfaf6b575e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383af6896f752bc635f045dafc777f75"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a383af6896f752bc635f045dafc777f75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a383af6896f752bc635f045dafc777f75">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a383af6896f752bc635f045dafc777f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying diagonal matrix.  <a href="#a383af6896f752bc635f045dafc777f75">More...</a><br /></td></tr>
<tr class="separator:a383af6896f752bc635f045dafc777f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d009c35b2304419aa91d2acdda345f"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:ad6d009c35b2304419aa91d2acdda345f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ad6d009c35b2304419aa91d2acdda345f">preservesInvariant</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad6d009c35b2304419aa91d2acdda345f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying diagonal matrix.  <a href="#ad6d009c35b2304419aa91d2acdda345f">More...</a><br /></td></tr>
<tr class="separator:ad6d009c35b2304419aa91d2acdda345f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be3095780509ea4b0c421bdb15920a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a1be3095780509ea4b0c421bdb15920a0">operator~</a> ()</td></tr>
<tr class="memdesc:a1be3095780509ea4b0c421bdb15920a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for non-constant vectors.  <a href="#a1be3095780509ea4b0c421bdb15920a0">More...</a><br /></td></tr>
<tr class="separator:a1be3095780509ea4b0c421bdb15920a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37bee20b660eacfcb7a942dc9cdbe19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#ae37bee20b660eacfcb7a942dc9cdbe19">operator~</a> () const</td></tr>
<tr class="memdesc:ae37bee20b660eacfcb7a942dc9cdbe19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for constant vectors.  <a href="#ae37bee20b660eacfcb7a942dc9cdbe19">More...</a><br /></td></tr>
<tr class="separator:ae37bee20b660eacfcb7a942dc9cdbe19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a278082b932a3b4117dc7abd7499dec45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a278082b932a3b4117dc7abd7499dec45">SparseRow</a> (MT &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:a278082b932a3b4117dc7abd7499dec45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor for <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html" title="Reference to a specific row of a sparse matrix.The SparseRow template represents a reference to a spe...">SparseRow</a>.  <a href="#a278082b932a3b4117dc7abd7499dec45">More...</a><br /></td></tr>
<tr class="separator:a278082b932a3b4117dc7abd7499dec45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access functions</div></td></tr>
<tr class="memitem:ac264c873ceb03e1066d61c63eb42984f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ada0b90a1116c26b13bde52e8332d1352">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ac264c873ceb03e1066d61c63eb42984f">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:ac264c873ceb03e1066d61c63eb42984f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the row elements.  <a href="#ac264c873ceb03e1066d61c63eb42984f">More...</a><br /></td></tr>
<tr class="separator:ac264c873ceb03e1066d61c63eb42984f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbf22bbf305c6228b0875075936ab50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a2981b8bead50b7e612fc330412cd12ad">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#aacbf22bbf305c6228b0875075936ab50">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:aacbf22bbf305c6228b0875075936ab50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the row elements.  <a href="#aacbf22bbf305c6228b0875075936ab50">More...</a><br /></td></tr>
<tr class="separator:aacbf22bbf305c6228b0875075936ab50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5ada35b09be130edbbec039ac23fd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a1b5ada35b09be130edbbec039ac23fd6">begin</a> ()</td></tr>
<tr class="memdesc:a1b5ada35b09be130edbbec039ac23fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the row.  <a href="#a1b5ada35b09be130edbbec039ac23fd6">More...</a><br /></td></tr>
<tr class="separator:a1b5ada35b09be130edbbec039ac23fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cd63d0435e9d5a1b9af59781ba2e67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ab3cd63d0435e9d5a1b9af59781ba2e67">begin</a> () const </td></tr>
<tr class="memdesc:ab3cd63d0435e9d5a1b9af59781ba2e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the row.  <a href="#ab3cd63d0435e9d5a1b9af59781ba2e67">More...</a><br /></td></tr>
<tr class="separator:ab3cd63d0435e9d5a1b9af59781ba2e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45979781efa69dcf19cc3a9fbcd699f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ad45979781efa69dcf19cc3a9fbcd699f">cbegin</a> () const </td></tr>
<tr class="memdesc:ad45979781efa69dcf19cc3a9fbcd699f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the row.  <a href="#ad45979781efa69dcf19cc3a9fbcd699f">More...</a><br /></td></tr>
<tr class="separator:ad45979781efa69dcf19cc3a9fbcd699f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15560c010b58be3cbef01840e592a95b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a15560c010b58be3cbef01840e592a95b">end</a> ()</td></tr>
<tr class="memdesc:a15560c010b58be3cbef01840e592a95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the row.  <a href="#a15560c010b58be3cbef01840e592a95b">More...</a><br /></td></tr>
<tr class="separator:a15560c010b58be3cbef01840e592a95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5736bfec036aca2c6c8a87621d68d271"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a5736bfec036aca2c6c8a87621d68d271">end</a> () const </td></tr>
<tr class="memdesc:a5736bfec036aca2c6c8a87621d68d271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the row.  <a href="#a5736bfec036aca2c6c8a87621d68d271">More...</a><br /></td></tr>
<tr class="separator:a5736bfec036aca2c6c8a87621d68d271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c5dded3df366a0a8c7f48c48406094"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a13c5dded3df366a0a8c7f48c48406094">cend</a> () const </td></tr>
<tr class="memdesc:a13c5dded3df366a0a8c7f48c48406094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the row.  <a href="#a13c5dded3df366a0a8c7f48c48406094">More...</a><br /></td></tr>
<tr class="separator:a13c5dded3df366a0a8c7f48c48406094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment operators</div></td></tr>
<tr class="memitem:a07514b8ae2b597a5c3ef27814bfbaa3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a07514b8ae2b597a5c3ef27814bfbaa3c">operator=</a> (const <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a> &amp;rhs)</td></tr>
<tr class="memdesc:a07514b8ae2b597a5c3ef27814bfbaa3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html" title="Reference to a specific row of a sparse matrix.The SparseRow template represents a reference to a spe...">SparseRow</a>.  <a href="#a07514b8ae2b597a5c3ef27814bfbaa3c">More...</a><br /></td></tr>
<tr class="separator:a07514b8ae2b597a5c3ef27814bfbaa3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae09622da735ee13d84628a58e8b67d9"><td class="memTemplParams" colspan="2"><a class="anchor" id="aae09622da735ee13d84628a58e8b67d9"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:aae09622da735ee13d84628a58e8b67d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="separator:aae09622da735ee13d84628a58e8b67d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621140d531094fb79b354e41b5db6113"><td class="memTemplParams" colspan="2"><a class="anchor" id="a621140d531094fb79b354e41b5db6113"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a621140d531094fb79b354e41b5db6113"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a621140d531094fb79b354e41b5db6113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3774fc911fbf1f4381d930c87d3a125e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3774fc911fbf1f4381d930c87d3a125e"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a3774fc911fbf1f4381d930c87d3a125e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a3774fc911fbf1f4381d930c87d3a125e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc14d52ce50774a4ddda0c7fd2ebb087"><td class="memTemplParams" colspan="2"><a class="anchor" id="adc14d52ce50774a4ddda0c7fd2ebb087"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:adc14d52ce50774a4ddda0c7fd2ebb087"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="separator:adc14d52ce50774a4ddda0c7fd2ebb087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcbd2eac6f5155a73939084f8eb0562"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7bcbd2eac6f5155a73939084f8eb0562"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a7bcbd2eac6f5155a73939084f8eb0562"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a7bcbd2eac6f5155a73939084f8eb0562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef687e29799c51c2a93abcb8630446c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="aef687e29799c51c2a93abcb8630446c4"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:aef687e29799c51c2a93abcb8630446c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="separator:aef687e29799c51c2a93abcb8630446c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47348ac047df620a4442a32b9845256"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab47348ac047df620a4442a32b9845256"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ab47348ac047df620a4442a32b9845256"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="separator:ab47348ac047df620a4442a32b9845256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88dff5ad264e5b175b3516dc7844666"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac88dff5ad264e5b175b3516dc7844666"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ac88dff5ad264e5b175b3516dc7844666"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (Other rhs)</td></tr>
<tr class="separator:ac88dff5ad264e5b175b3516dc7844666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe30b02626c19e00f1260f47ef1eb1e"><td class="memTemplParams" colspan="2"><a class="anchor" id="adbe30b02626c19e00f1260f47ef1eb1e"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:adbe30b02626c19e00f1260f47ef1eb1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (Other rhs)</td></tr>
<tr class="separator:adbe30b02626c19e00f1260f47ef1eb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Lookup functions</div></td></tr>
<tr class="memitem:ad13fb7b2399bc9c88ac13ed6ffbd2c0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ad13fb7b2399bc9c88ac13ed6ffbd2c0b">find</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:ad13fb7b2399bc9c88ac13ed6ffbd2c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a specific row element.  <a href="#ad13fb7b2399bc9c88ac13ed6ffbd2c0b">More...</a><br /></td></tr>
<tr class="separator:ad13fb7b2399bc9c88ac13ed6ffbd2c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893e9a9cabddc996a2bf283294e11619"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a893e9a9cabddc996a2bf283294e11619">find</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:a893e9a9cabddc996a2bf283294e11619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a specific row element.  <a href="#a893e9a9cabddc996a2bf283294e11619">More...</a><br /></td></tr>
<tr class="separator:a893e9a9cabddc996a2bf283294e11619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada63662900ab5f33a39e59c5b4d28a79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ada63662900ab5f33a39e59c5b4d28a79">lowerBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:ada63662900ab5f33a39e59c5b4d28a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index not less then the given index.  <a href="#ada63662900ab5f33a39e59c5b4d28a79">More...</a><br /></td></tr>
<tr class="separator:ada63662900ab5f33a39e59c5b4d28a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1488fb3725104797585d02516434e3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#aa1488fb3725104797585d02516434e3f">lowerBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:aa1488fb3725104797585d02516434e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index not less then the given index.  <a href="#aa1488fb3725104797585d02516434e3f">More...</a><br /></td></tr>
<tr class="separator:aa1488fb3725104797585d02516434e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31d668e4fb050c04a63f2e1085529a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ab31d668e4fb050c04a63f2e1085529a7">upperBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:ab31d668e4fb050c04a63f2e1085529a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index greater then the given index.  <a href="#ab31d668e4fb050c04a63f2e1085529a7">More...</a><br /></td></tr>
<tr class="separator:ab31d668e4fb050c04a63f2e1085529a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20c93247b5ff94faa350290ab8c41a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#af20c93247b5ff94faa350290ab8c41a9">upperBound</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:af20c93247b5ff94faa350290ab8c41a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first index greater then the given index.  <a href="#af20c93247b5ff94faa350290ab8c41a9">More...</a><br /></td></tr>
<tr class="separator:af20c93247b5ff94faa350290ab8c41a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low-level utility functions</div></td></tr>
<tr class="memitem:ab5c8cbe436ada3fbab7eafe8dab00abd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ab5c8cbe436ada3fbab7eafe8dab00abd">append</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a94645f6ae87c9a1b2b01f72965fc9179">ElementType</a> &amp;value, bool check=false)</td></tr>
<tr class="memdesc:ab5c8cbe436ada3fbab7eafe8dab00abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appending an element to the sparse row.  <a href="#ab5c8cbe436ada3fbab7eafe8dab00abd">More...</a><br /></td></tr>
<tr class="separator:ab5c8cbe436ada3fbab7eafe8dab00abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression template evaluation functions</div></td></tr>
<tr class="memitem:a6357cc8791f573792612f80348da4c34"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a6357cc8791f573792612f80348da4c34"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a6357cc8791f573792612f80348da4c34">canAlias</a> (const Other *alias) const </td></tr>
<tr class="memdesc:a6357cc8791f573792612f80348da4c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the sparse row can alias with the given address <em>alias</em>.  <a href="#a6357cc8791f573792612f80348da4c34">More...</a><br /></td></tr>
<tr class="separator:a6357cc8791f573792612f80348da4c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0501a407054288e8835b9e7c536e5c91"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a0501a407054288e8835b9e7c536e5c91"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a0501a407054288e8835b9e7c536e5c91">isAliased</a> (const Other *alias) const </td></tr>
<tr class="memdesc:a0501a407054288e8835b9e7c536e5c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the sparse row is aliased with the given address <em>alias</em>.  <a href="#a0501a407054288e8835b9e7c536e5c91">More...</a><br /></td></tr>
<tr class="separator:a0501a407054288e8835b9e7c536e5c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9929770984fb863fdec3f08d1ae54a6"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:aa9929770984fb863fdec3f08d1ae54a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#aa9929770984fb863fdec3f08d1ae54a6">assign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa9929770984fb863fdec3f08d1ae54a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a dense vector.  <a href="#aa9929770984fb863fdec3f08d1ae54a6">More...</a><br /></td></tr>
<tr class="separator:aa9929770984fb863fdec3f08d1ae54a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6833a6e889a5a78438e38169307327ce"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a6833a6e889a5a78438e38169307327ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a6833a6e889a5a78438e38169307327ce">assign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6833a6e889a5a78438e38169307327ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a sparse vector.  <a href="#a6833a6e889a5a78438e38169307327ce">More...</a><br /></td></tr>
<tr class="separator:a6833a6e889a5a78438e38169307327ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92be24f091a202c9cbe921c6a3fc7a4b"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a92be24f091a202c9cbe921c6a3fc7a4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a92be24f091a202c9cbe921c6a3fc7a4b">addAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a92be24f091a202c9cbe921c6a3fc7a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a dense vector.  <a href="#a92be24f091a202c9cbe921c6a3fc7a4b">More...</a><br /></td></tr>
<tr class="separator:a92be24f091a202c9cbe921c6a3fc7a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579312a7fed41795b0aa01e6bf75f5e3"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a579312a7fed41795b0aa01e6bf75f5e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a579312a7fed41795b0aa01e6bf75f5e3">addAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a579312a7fed41795b0aa01e6bf75f5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a sparse vector.  <a href="#a579312a7fed41795b0aa01e6bf75f5e3">More...</a><br /></td></tr>
<tr class="separator:a579312a7fed41795b0aa01e6bf75f5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2184ba1e963abc90a6378085f57d2978"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a2184ba1e963abc90a6378085f57d2978"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a2184ba1e963abc90a6378085f57d2978">subAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2184ba1e963abc90a6378085f57d2978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a dense vector.  <a href="#a2184ba1e963abc90a6378085f57d2978">More...</a><br /></td></tr>
<tr class="separator:a2184ba1e963abc90a6378085f57d2978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe67561d9cb5100afcb3b0808ac13e7c"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:abe67561d9cb5100afcb3b0808ac13e7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abe67561d9cb5100afcb3b0808ac13e7c">subAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="memdesc:abe67561d9cb5100afcb3b0808ac13e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a sparse vector.  <a href="#abe67561d9cb5100afcb3b0808ac13e7c">More...</a><br /></td></tr>
<tr class="separator:abe67561d9cb5100afcb3b0808ac13e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ga7532cc4491693d89db98fd6da5dffd8b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>useConst</b> = IsConst&lt;MT&gt;::value
 }</td></tr>
<tr class="memdesc:ga7532cc4491693d89db98fd6da5dffd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the non-const reference and iterator types.  <a href="../../d3/d09/group__sparse__row.html#ga7532cc4491693d89db98fd6da5dffd8b">More...</a><br /></td></tr>
<tr class="separator:ga7532cc4491693d89db98fd6da5dffd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77de3cc362e0153d8e37d68efb6023c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa77de3cc362e0153d8e37d68efb6023c"></a>
typedef <a class="el" href="../../d7/d0c/structblaze_1_1If.html">If</a>&lt; <a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html">IsExpression</a>&lt; MT &gt;, MT, MT &amp; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#aa77de3cc362e0153d8e37d68efb6023c">Operand</a></td></tr>
<tr class="memdesc:aa77de3cc362e0153d8e37d68efb6023c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite data type of the dense matrix expression. <br /></td></tr>
<tr class="separator:aa77de3cc362e0153d8e37d68efb6023c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:abcb386d670f3f829dff78685f5fd03b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcb386d670f3f829dff78685f5fd03b3"></a>
<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#aa77de3cc362e0153d8e37d68efb6023c">Operand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abcb386d670f3f829dff78685f5fd03b3">matrix_</a></td></tr>
<tr class="memdesc:abcb386d670f3f829dff78685f5fd03b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sparse matrix containing the row. <br /></td></tr>
<tr class="separator:abcb386d670f3f829dff78685f5fd03b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17c86ce1d6819eff66f85cf9a2b6c0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad17c86ce1d6819eff66f85cf9a2b6c0e"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ad17c86ce1d6819eff66f85cf9a2b6c0e">row_</a></td></tr>
<tr class="memdesc:ad17c86ce1d6819eff66f85cf9a2b6c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the row in the matrix. <br /></td></tr>
<tr class="separator:ad17c86ce1d6819eff66f85cf9a2b6c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Utility functions</h2></td></tr>
<tr class="memitem:af2915a7ea6bb89a82973d700241b2464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#af2915a7ea6bb89a82973d700241b2464">size</a> () const </td></tr>
<tr class="memdesc:af2915a7ea6bb89a82973d700241b2464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size/dimension of the sparse row.  <a href="#af2915a7ea6bb89a82973d700241b2464">More...</a><br /></td></tr>
<tr class="separator:af2915a7ea6bb89a82973d700241b2464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f59e4b62e95f5eab24254fff451b4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a29f59e4b62e95f5eab24254fff451b4c">capacity</a> () const </td></tr>
<tr class="memdesc:a29f59e4b62e95f5eab24254fff451b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the sparse row.  <a href="#a29f59e4b62e95f5eab24254fff451b4c">More...</a><br /></td></tr>
<tr class="separator:a29f59e4b62e95f5eab24254fff451b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff65669e2c909c9e7f8be14e8adf45b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a0ff65669e2c909c9e7f8be14e8adf45b">nonZeros</a> () const </td></tr>
<tr class="memdesc:a0ff65669e2c909c9e7f8be14e8adf45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the row.  <a href="#a0ff65669e2c909c9e7f8be14e8adf45b">More...</a><br /></td></tr>
<tr class="separator:a0ff65669e2c909c9e7f8be14e8adf45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25f4993c4d5d1fa4d008cce92516f5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ae25f4993c4d5d1fa4d008cce92516f5d">reset</a> ()</td></tr>
<tr class="memdesc:ae25f4993c4d5d1fa4d008cce92516f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to the default initial values.  <a href="#ae25f4993c4d5d1fa4d008cce92516f5d">More...</a><br /></td></tr>
<tr class="separator:ae25f4993c4d5d1fa4d008cce92516f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f683e8ed211310f8ac4d85893e1458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a45f683e8ed211310f8ac4d85893e1458">set</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a94645f6ae87c9a1b2b01f72965fc9179">ElementType</a> &amp;value)</td></tr>
<tr class="memdesc:a45f683e8ed211310f8ac4d85893e1458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting an element of the sparse row.  <a href="#a45f683e8ed211310f8ac4d85893e1458">More...</a><br /></td></tr>
<tr class="separator:a45f683e8ed211310f8ac4d85893e1458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556413e0fb8b43f5d632828b83919eb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a556413e0fb8b43f5d632828b83919eb9">insert</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a94645f6ae87c9a1b2b01f72965fc9179">ElementType</a> &amp;value)</td></tr>
<tr class="memdesc:a556413e0fb8b43f5d632828b83919eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserting an element into the sparse row.  <a href="#a556413e0fb8b43f5d632828b83919eb9">More...</a><br /></td></tr>
<tr class="separator:a556413e0fb8b43f5d632828b83919eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee11ad9f92921a90892bbba803cccda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#aaee11ad9f92921a90892bbba803cccda">erase</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:aaee11ad9f92921a90892bbba803cccda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing an element from the sparse row.  <a href="#aaee11ad9f92921a90892bbba803cccda">More...</a><br /></td></tr>
<tr class="separator:aaee11ad9f92921a90892bbba803cccda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99aa80959967ae5918baf6b4e5ee58f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ab99aa80959967ae5918baf6b4e5ee58f">erase</a> (<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a> pos)</td></tr>
<tr class="memdesc:ab99aa80959967ae5918baf6b4e5ee58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing an element from the sparse row.  <a href="#ab99aa80959967ae5918baf6b4e5ee58f">More...</a><br /></td></tr>
<tr class="separator:ab99aa80959967ae5918baf6b4e5ee58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94ac3969712d8712c5fe5d2421c550e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ac94ac3969712d8712c5fe5d2421c550e">erase</a> (<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a> first, <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a> last)</td></tr>
<tr class="memdesc:ac94ac3969712d8712c5fe5d2421c550e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasing a range of elements from the sparse row.  <a href="#ac94ac3969712d8712c5fe5d2421c550e">More...</a><br /></td></tr>
<tr class="separator:ac94ac3969712d8712c5fe5d2421c550e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620b146674c9f924e6108b1624a23a4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a620b146674c9f924e6108b1624a23a4a">reserve</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:a620b146674c9f924e6108b1624a23a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the minimum capacity of the sparse row.  <a href="#a620b146674c9f924e6108b1624a23a4a">More...</a><br /></td></tr>
<tr class="separator:a620b146674c9f924e6108b1624a23a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844994aa07ace5428b36802355a8d773"><td class="memTemplParams" colspan="2"><a class="anchor" id="a844994aa07ace5428b36802355a8d773"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a844994aa07ace5428b36802355a8d773"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scale</b> (const Other &amp;scalar)</td></tr>
<tr class="separator:a844994aa07ace5428b36802355a8d773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2426963de27757c0d5882b1fe3bb3cd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a2426963de27757c0d5882b1fe3bb3cd6">extendCapacity</a> () const </td></tr>
<tr class="memdesc:a2426963de27757c0d5882b1fe3bb3cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculating a new sparse row capacity.  <a href="#a2426963de27757c0d5882b1fe3bb3cd6">More...</a><br /></td></tr>
<tr class="separator:a2426963de27757c0d5882b1fe3bb3cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5ff6db7bc31a0d177a0cc84f85dc63"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5e5ff6db7bc31a0d177a0cc84f85dc63"></a>
template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a5e5ff6db7bc31a0d177a0cc84f85dc63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../df/df0/structblaze_1_1IsRestricted.html">IsRestricted</a>&lt; MT2 &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a5e5ff6db7bc31a0d177a0cc84f85dc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049993b58265a49311ed50db14a83995"><td class="memTemplParams" colspan="2"><a class="anchor" id="a049993b58265a49311ed50db14a83995"></a>
template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a049993b58265a49311ed50db14a83995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a049993b58265a49311ed50db14a83995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c5e84278fb0c55c40272d96767b7b6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a20c5e84278fb0c55c40272d96767b7b6"></a>
template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a20c5e84278fb0c55c40272d96767b7b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a20c5e84278fb0c55c40272d96767b7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0d929929c10f37805a6215dc90a11e"><td class="memTemplParams" colspan="2"><a class="anchor" id="afd0d929929c10f37805a6215dc90a11e"></a>
template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:afd0d929929c10f37805a6215dc90a11e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="separator:afd0d929929c10f37805a6215dc90a11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700b5db65099caffc7a9dfaf6b575e31"><td class="memTemplParams" colspan="2"><a class="anchor" id="a700b5db65099caffc7a9dfaf6b575e31"></a>
template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a700b5db65099caffc7a9dfaf6b575e31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a700b5db65099caffc7a9dfaf6b575e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383af6896f752bc635f045dafc777f75"><td class="memTemplParams" colspan="2"><a class="anchor" id="a383af6896f752bc635f045dafc777f75"></a>
template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a383af6896f752bc635f045dafc777f75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="separator:a383af6896f752bc635f045dafc777f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d009c35b2304419aa91d2acdda345f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad6d009c35b2304419aa91d2acdda345f"></a>
template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:ad6d009c35b2304419aa91d2acdda345f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;rhs)</td></tr>
<tr class="separator:ad6d009c35b2304419aa91d2acdda345f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt;<br />
class blaze::SparseRow&lt; MT, SO, SF &gt;</h3>

<p>Reference to a specific row of a sparse matrix.</p>
<p>The <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html" title="Reference to a specific row of a sparse matrix.The SparseRow template represents a reference to a spe...">SparseRow</a> template represents a reference to a specific row of a sparse matrix primitive. The type of the sparse matrix is specified via the first template parameter: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MT, <span class="keywordtype">bool</span> SO &gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="../../d9/dd4/classblaze_1_1SparseRow.html#a278082b932a3b4117dc7abd7499dec45">SparseRow</a>;</div>
</div><!-- fragment --><ul>
<li>MT: specifies the type of the sparse matrix primitive. <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html" title="Reference to a specific row of a sparse matrix.The SparseRow template represents a reference to a spe...">SparseRow</a> can be used with every sparse matrix primitive, but does not work with any matrix expression type.</li>
<li>SO: specifies the storage order (<a class="el" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices. ">blaze::rowMajor</a>, <a class="el" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583" title="Storage order flag for column-major matrices. ">blaze::columnMajor</a>) of the sparse matrix. This template parameter doesn't have to be explicitly defined, but is automatically derived from the first template parameter.</li>
<li>SF: specifies whether the given matrix is a symmetric matrix or not. Also this parameter doesn't have to be explicitly defined, but is automatically derived from the first template parameter.</li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="sparse_row_setup"></a>
Setup of Sparse Rows</h1>
<p>A reference to a sparse row can be created very conveniently via the <code><a class="el" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9" title="Creating a view on a specific row of the given matrix. ">row()</a></code> function. This reference can be treated as any other row vector, i.e. it can be assigned to, it can be copied from, and it can be used in arithmetic operations. The reference can also be used on both sides of an assignment: The row can either be used as an alias to grant write access to a specific row of a matrix primitive on the left-hand side of an assignment or to grant read-access to a specific row of a matrix primitive or expression on the right-hand side of an assignment. The following example demonstrates this in detail:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,blaze::rowVector&gt;</a>     DenseVectorType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::rowVector&gt;</a>  SparseVectorType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::rowMajor&gt;</a>   SparseMatrixType;</div>
<div class="line"></div>
<div class="line">DenseVectorType  x;</div>
<div class="line">SparseVectorType y;</div>
<div class="line">SparseMatrixType A, B;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the 2nd row of matrix A to x</span></div>
<div class="line"><a class="code" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow&lt;SparseMatrixType&gt;</a> row2 = <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 2UL );</div>
<div class="line">row2 = x;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the 3rd row of matrix B to y</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( B, 3UL ) = y;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting x to the 1st row of matrix B</span></div>
<div class="line">x = <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( B, 1UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting y to the 4th row of the result of the matrix multiplication</span></div>
<div class="line">y = <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A * B, 4UL );</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_row_element_access"></a>
Element access</h1>
<p>A sparse row can be used like any other row vector. For instance, the elements of the sparse row can be directly accessed with the subscript operator.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::rowMajor&gt;</a>  MatrixType;</div>
<div class="line">MatrixType A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a view on the 4th row of matrix A</span></div>
<div class="line"><a class="code" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow&lt;MatrixType&gt;</a> row4 = <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 4UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the 1st element of the sparse row, which corresponds</span></div>
<div class="line"><span class="comment">// to the 1st element in the 4th row of matrix A</span></div>
<div class="line">row4[1] = 2.0;</div>
</div><!-- fragment --><p>The numbering of the row elements is</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; 1 &amp; 2 &amp; \cdots &amp; N-1 \\ \end{array}\right),\]" src="../../form_20.png"/>
</p>
<p>where N is the number of columns of the referenced matrix. Alternatively, the elements of a row can be traversed via iterators. Just as with vectors, in case of non-const rows, <code><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a1b5ada35b09be130edbbec039ac23fd6" title="Returns an iterator to the first element of the row. ">begin()</a></code> and <code><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a15560c010b58be3cbef01840e592a95b" title="Returns an iterator just past the last element of the row. ">end()</a></code> return an Iterator, which allows a manipulation of the non-zero values, in case of constant rows a ConstIterator is returned:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a>  MatrixType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow&lt;MatrixType&gt;</a>                  RowType;</div>
<div class="line"></div>
<div class="line">MatrixType A( 128UL, 256UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a reference to the 31st row of matrix A</span></div>
<div class="line">RowType row31 = <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 31UL );</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">RowType::Iterator</a> it=row31.begin(); it!=row31.end(); ++it ) {</div>
<div class="line">   it-&gt;value() = ...;  <span class="comment">// OK: Write access to the value of the non-zero element.</span></div>
<div class="line">   ... = it-&gt;value();  <span class="comment">// OK: Read access to the value of the non-zero element.</span></div>
<div class="line">   it-&gt;index() = ...;  <span class="comment">// Compilation error: The index of a non-zero element cannot be changed.</span></div>
<div class="line">   ... = it-&gt;index();  <span class="comment">// OK: Read access to the index of the sparse element.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">RowType::ConstIterator</a> it=row31.begin(); it!=row31.end(); ++it ) {</div>
<div class="line">   it-&gt;value() = ...;  <span class="comment">// Compilation error: Assignment to the value via a ConstIterator is invalid.</span></div>
<div class="line">   ... = it-&gt;value();  <span class="comment">// OK: Read access to the value of the non-zero element.</span></div>
<div class="line">   it-&gt;index() = ...;  <span class="comment">// Compilation error: The index of a non-zero element cannot be changed.</span></div>
<div class="line">   ... = it-&gt;index();  <span class="comment">// OK: Read access to the index of the sparse element.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_row_element_insertion"></a>
Element Insertion</h1>
<p>Inserting/accessing elements in a sparse row can be done by several alternative functions. The following example demonstrates all options:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::rowMajor&gt;</a>  MatrixType;</div>
<div class="line">MatrixType A( 10UL, 100UL );  <span class="comment">// Non-initialized 10x100 matrix</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow&lt;MatrixType&gt;</a>  RowType;</div>
<div class="line">RowType row0( <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 0UL ) );  <span class="comment">// Reference to the 0th row of A</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// The subscript operator provides access to all possible elements of the sparse row,</span></div>
<div class="line"><span class="comment">// including the zero elements. In case the subscript operator is used to access an element</span></div>
<div class="line"><span class="comment">// that is currently not stored in the sparse row, the element is inserted into the row.</span></div>
<div class="line">row0[42] = 2.0;</div>
<div class="line"></div>
<div class="line"><span class="comment">// The second operation for inserting elements is the set() function. In case the element</span></div>
<div class="line"><span class="comment">// is not contained in the row it is inserted into the row, if it is already contained in</span></div>
<div class="line"><span class="comment">// the row its value is modified.</span></div>
<div class="line">row0.set( 45UL, -1.2 );</div>
<div class="line"></div>
<div class="line"><span class="comment">// An alternative for inserting elements into the row is the insert() function. However,</span></div>
<div class="line"><span class="comment">// it inserts the element only in case the element is not already contained in the row.</span></div>
<div class="line">row0.insert( 50UL, 3.7 );</div>
<div class="line"></div>
<div class="line"><span class="comment">// A very efficient way to add new elements to a sparse row is the append() function.</span></div>
<div class="line"><span class="comment">// Note that append() requires that the appended element&#39;s index is strictly larger than</span></div>
<div class="line"><span class="comment">// the currently largest non-zero index of the row and that the row&#39;s capacity is large</span></div>
<div class="line"><span class="comment">// enough to hold the new element.</span></div>
<div class="line">row0.reserve( 10UL );</div>
<div class="line">row0.append( 51UL, -2.1 );</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_row_common_operations"></a>
Common Operations</h1>
<p>The current number of row elements can be obtained via the <code><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#af2915a7ea6bb89a82973d700241b2464" title="Returns the current size/dimension of the sparse row. ">size()</a></code> function, the current capacity via the <code><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a29f59e4b62e95f5eab24254fff451b4c" title="Returns the maximum capacity of the sparse row. ">capacity()</a></code> function, and the number of non-zero elements via the <code><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a0ff65669e2c909c9e7f8be14e8adf45b" title="Returns the number of non-zero elements in the row. ">nonZeros()</a></code> function. However, since rows are references to specific rows of a matrix, several operations are not possible on views, such as resizing and swapping:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::rowMajor&gt;</a>  MatrixType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow&lt;MatrixType&gt;</a>                  RowType;</div>
<div class="line"></div>
<div class="line">MatrixType A( 42UL, 42UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a reference to the 2nd row of matrix A</span></div>
<div class="line">RowType row2 = <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 2UL );</div>
<div class="line"></div>
<div class="line">row2.size();          <span class="comment">// Returns the number of elements in the row</span></div>
<div class="line">row2.capacity();      <span class="comment">// Returns the capacity of the row</span></div>
<div class="line">row2.nonZeros();      <span class="comment">// Returns the number of non-zero elements contained in the row</span></div>
<div class="line"></div>
<div class="line">row2.resize( 84UL );  <span class="comment">// Compilation error: Cannot resize a single row of a matrix</span></div>
<div class="line"></div>
<div class="line">RowType row3 = <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 3UL );</div>
<div class="line"><a class="code" href="../../d0/d90/group__diagonal__matrix.html#ga172895200063f120b6ffd241af12bbae">swap</a>( row2, row3 );   <span class="comment">// Compilation error: Swap operation not allowed</span></div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_row_arithmetic_operations"></a>
Arithmetic Operations</h1>
<p>The following example gives an impression of the use of <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html" title="Reference to a specific row of a sparse matrix.The SparseRow template represents a reference to a spe...">SparseRow</a> within arithmetic operations. All operations (addition, subtraction, multiplication, scaling, ...) can be performed on all possible combinations of dense and sparse vectors with fitting element types:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::rowVector&gt;</a> a( 2UL ), b;</div>
<div class="line">a[1] = 2.0;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,blaze::rowVector&gt;</a> c( 2UL, 3.0 );</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::rowMajor&gt;</a>  MatrixType;</div>
<div class="line">MatrixType A( 3UL, 2UL );  <span class="comment">// Non-initialized 3x2 matrix</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow&lt;MatrixType&gt;</a>  RowType;</div>
<div class="line">RowType row0( <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 0UL ) );  <span class="comment">// Reference to the 0th row of A</span></div>
<div class="line"></div>
<div class="line">row0[0] = 0.0;        <span class="comment">// Manual initialization of the 0th row of A</span></div>
<div class="line">row0[1] = 0.0;</div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 1UL ) = a;    <span class="comment">// Sparse vector initialization of the 1st row of A</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 2UL ) = c;    <span class="comment">// Dense vector initialization of the 2nd row of A</span></div>
<div class="line"></div>
<div class="line">b = row0 + a;              <span class="comment">// Sparse vector/sparse vector addition</span></div>
<div class="line">b = c + <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 1UL );     <span class="comment">// Dense vector/sparse vector addition</span></div>
<div class="line">b = row0 * <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 2UL );  <span class="comment">// Component-wise vector multiplication</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 1UL ) *= 2.0;     <span class="comment">// In-place scaling of the 1st row</span></div>
<div class="line">b = <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 1UL ) * 2.0;  <span class="comment">// Scaling of the 1st row</span></div>
<div class="line">b = 2.0 * <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 1UL );  <span class="comment">// Scaling of the 1st row</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 2UL ) += a;              <span class="comment">// Addition assignment</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 2UL ) -= c;              <span class="comment">// Subtraction assignment</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 2UL ) *= <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 0UL );  <span class="comment">// Multiplication assignment</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> scalar = <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 1UL ) * <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( c );  <span class="comment">// Scalar/dot/inner product between two vectors</span></div>
<div class="line"></div>
<div class="line">A = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( c ) * <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 1UL );  <span class="comment">// Outer product between two vectors</span></div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="sparse_row_on_column_major_matrix"></a>
Sparse Row on a Column-Major Matrix</h1>
<p>It is especially noteworthy that row views can be created for both row-major and column-major matrices. Whereas the interface of a row-major matrix only allows to traverse a row directly and the interface of a column-major matrix only allows to traverse a column, via views it is also possible to traverse a row of a column-major matrix. For instance:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;int,blaze::columnMajor&gt;</a>  MatrixType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow&lt;MatrixType&gt;</a>                     RowType;</div>
<div class="line"></div>
<div class="line">MatrixType A( 64UL, 32UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a reference to the 1st row of a column-major matrix A</span></div>
<div class="line">RowType row1 = <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 1UL );</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">RowType::Iterator</a> it=row1.begin(); it!=row1.end(); ++it ) {</div>
<div class="line">   <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>However, please note that creating a row view on a matrix stored in a column-major fashion can result in a considerable performance decrease in comparison to a row view on a matrix with row-major storage format. This is due to the non-contiguous storage of the matrix elements. Therefore care has to be taken in the choice of the most suitable storage order:</p>
<div class="fragment"><div class="line"><span class="comment">// Setup of two column-major matrices</span></div>
<div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::columnMajor&gt;</a> A( 128UL, 128UL );</div>
<div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,blaze::columnMajor&gt;</a> B( 128UL, 128UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// The computation of the 15th row of the multiplication between A and B ...</span></div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::rowVector&gt;</a> x = <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A * B, 15UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// ... is essentially the same as the following computation, which multiplies</span></div>
<div class="line"><span class="comment">// the 15th row of the column-major matrix A with B.</span></div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::rowVector&gt;</a> x = <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 15UL ) * B;</div>
</div><!-- fragment --><p>Although Blaze performs the resulting vector/matrix multiplication as efficiently as possible using a row-major storage order for matrix A would result in a more efficient evaluation. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a278082b932a3b4117dc7abd7499dec45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a> </td>
          <td>(</td>
          <td class="paramtype">MT &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constructor for <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html" title="Reference to a specific row of a sparse matrix.The SparseRow template represents a reference to a spe...">SparseRow</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix containing the row. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid row access index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a92be24f091a202c9cbe921c6a3fc7a4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a579312a7fed41795b0aa01e6bf75f5e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ab5c8cbe436ada3fbab7eafe8dab00abd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a94645f6ae87c9a1b2b01f72965fc9179">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appending an element to the sparse row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the new element. The index must be smaller than the number of matrix columns. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to be appended. </td></tr>
    <tr><td class="paramname">check</td><td><em>true</em> if the new value should be checked for default values, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function provides a very efficient way to fill a sparse row with elements. It appends a new element to the end of the sparse row without any memory allocation. Therefore it is strictly necessary to keep the following preconditions in mind:</p>
<ul>
<li>the index of the new element must be strictly larger than the largest index of non-zero elements in the sparse row</li>
<li>the current number of non-zero elements must be smaller than the capacity of the row</li>
</ul>
<p>Ignoring these preconditions might result in undefined behavior! The optional <em>check</em> parameter specifies whether the new value should be tested for a default value. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the new value is a default value (for instance 0 in case of an integral element type) the value is not appended. Per default the values are not tested.</p>
<p><b>Note:</b> Although <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ab5c8cbe436ada3fbab7eafe8dab00abd" title="Appending an element to the sparse row. ">append()</a> does not allocate new memory, it still invalidates all iterators returned by the <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a15560c010b58be3cbef01840e592a95b" title="Returns an iterator just past the last element of the row. ">end()</a> functions! </p>

</div>
</div>
<a class="anchor" id="aa9929770984fb863fdec3f08d1ae54a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a6833a6e889a5a78438e38169307327ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a1b5ada35b09be130edbbec039ac23fd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the row. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the row.</dd></dl>
<p>This function returns an iterator to the first element of the row. </p>

</div>
</div>
<a class="anchor" id="ab3cd63d0435e9d5a1b9af59781ba2e67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the row. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the row.</dd></dl>
<p>This function returns an iterator to the first element of the row. </p>

</div>
</div>
<a class="anchor" id="a6357cc8791f573792612f80348da4c34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::canAlias </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the sparse row can alias with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this sparse row, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address can alias with the sparse row. In contrast to the <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a0501a407054288e8835b9e7c536e5c91" title="Returns whether the sparse row is aliased with the given address alias. ">isAliased()</a> function this function is allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="a29f59e4b62e95f5eab24254fff451b4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the sparse row. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the sparse row. </dd></dl>

</div>
</div>
<a class="anchor" id="ad45979781efa69dcf19cc3a9fbcd699f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the row. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the row.</dd></dl>
<p>This function returns an iterator to the first element of the row. </p>

</div>
</div>
<a class="anchor" id="a13c5dded3df366a0a8c7f48c48406094"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the row. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the row.</dd></dl>
<p>This function returns an iterator just past the last element of the row. </p>

</div>
</div>
<a class="anchor" id="a15560c010b58be3cbef01840e592a95b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the row. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the row.</dd></dl>
<p>This function returns an iterator just past the last element of the row. </p>

</div>
</div>
<a class="anchor" id="a5736bfec036aca2c6c8a87621d68d271"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the row. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the row.</dd></dl>
<p>This function returns an iterator just past the last element of the row. </p>

</div>
</div>
<a class="anchor" id="aaee11ad9f92921a90892bbba803cccda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing an element from the sparse row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the element to be erased. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function erases an element from the sparse row. </p>

</div>
</div>
<a class="anchor" id="ab99aa80959967ae5918baf6b4e5ee58f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing an element from the sparse row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function erases an element from the sparse row. </p>

</div>
</div>
<a class="anchor" id="ac94ac3969712d8712c5fe5d2421c550e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasing a range of elements from the sparse row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to first element to be erased. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator just past the last element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element after the erased element.</dd></dl>
<p>This function erases a range of elements from the sparse row. </p>

</div>
</div>
<a class="anchor" id="a2426963de27757c0d5882b1fe3bb3cd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::extendCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculating a new sparse row capacity. </p>
<dl class="section return"><dt>Returns</dt><dd>The new sparse row capacity.</dd></dl>
<p>This function calculates a new row capacity based on the current capacity of the sparse row. Note that the new capacity is restricted to the interval <img class="formulaInl" alt="$[7..size]$" src="../../form_131.png"/>. </p>

</div>
</div>
<a class="anchor" id="ad13fb7b2399bc9c88ac13ed6ffbd2c0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for a specific row element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element in case the index is found, <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a15560c010b58be3cbef01840e592a95b" title="Returns an iterator just past the last element of the row. ">end()</a> iterator otherwise.</dd></dl>
<p>This function can be used to check whether a specific element is contained in the sparse row. It specifically searches for the element with index <em>index</em>. In case the element is found, the function returns an iterator to the element. Otherwise an iterator just past the last non-zero element of the sparse row (the <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a15560c010b58be3cbef01840e592a95b" title="Returns an iterator just past the last element of the row. ">end()</a> iterator) is returned. Note that the returned sparse row iterator is subject to invalidation due to inserting operations via the subscript operator or the <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a556413e0fb8b43f5d632828b83919eb9" title="Inserting an element into the sparse row. ">insert()</a> function! </p>

</div>
</div>
<a class="anchor" id="a893e9a9cabddc996a2bf283294e11619"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for a specific row element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element in case the index is found, <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a15560c010b58be3cbef01840e592a95b" title="Returns an iterator just past the last element of the row. ">end()</a> iterator otherwise.</dd></dl>
<p>This function can be used to check whether a specific element is contained in the sparse row. It specifically searches for the element with index <em>index</em>. In case the element is found, the function returns an iterator to the element. Otherwise an iterator just past the last non-zero element of the sparse row (the <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a15560c010b58be3cbef01840e592a95b" title="Returns an iterator just past the last element of the row. ">end()</a> iterator) is returned. Note that the returned sparse row iterator is subject to invalidation due to inserting operations via the subscript operator or the <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a556413e0fb8b43f5d632828b83919eb9" title="Inserting an element into the sparse row. ">insert()</a> function! </p>

</div>
</div>
<a class="anchor" id="a556413e0fb8b43f5d632828b83919eb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a94645f6ae87c9a1b2b01f72965fc9179">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserting an element into the sparse row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the new element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the inserted value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid sparse row access index.</td></tr>
  </table>
  </dd>
</dl>
<p>This function inserts a new element into the sparse row. However, duplicate elements are not allowed. In case the sparse row already contains an element at index <em>index</em>, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a0501a407054288e8835b9e7c536e5c91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the sparse row is aliased with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this sparse row, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address is aliased with the sparse row. In contrast to the <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a6357cc8791f573792612f80348da4c34" title="Returns whether the sparse row can alias with the given address alias. ">canAlias()</a> function this function is not allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="ada63662900ab5f33a39e59c5b4d28a79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::lowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index not less then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index not less then the given index, <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a15560c010b58be3cbef01840e592a95b" title="Returns an iterator just past the last element of the row. ">end()</a> iterator otherwise.</dd></dl>
<p>This function returns an iterator to the first element with an index not less then the given index. In combination with the <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ab31d668e4fb050c04a63f2e1085529a7" title="Returns an iterator to the first index greater then the given index. ">upperBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned sparse row iterator is subject to invalidation due to inserting operations via the subscript operator or the <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a556413e0fb8b43f5d632828b83919eb9" title="Inserting an element into the sparse row. ">insert()</a> function! </p>

</div>
</div>
<a class="anchor" id="aa1488fb3725104797585d02516434e3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::lowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index not less then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index not less then the given index, <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a15560c010b58be3cbef01840e592a95b" title="Returns an iterator just past the last element of the row. ">end()</a> iterator otherwise.</dd></dl>
<p>This function returns an iterator to the first element with an index not less then the given index. In combination with the <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ab31d668e4fb050c04a63f2e1085529a7" title="Returns an iterator to the first index greater then the given index. ">upperBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned sparse row iterator is subject to invalidation due to inserting operations via the subscript operator or the <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a556413e0fb8b43f5d632828b83919eb9" title="Inserting an element into the sparse row. ">insert()</a> function! </p>

</div>
</div>
<a class="anchor" id="a0ff65669e2c909c9e7f8be14e8adf45b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the row. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the row.</dd></dl>
<p>Note that the number of non-zero elements is always less than or equal to the current number of columns of the matrix containing the row. </p>

</div>
</div>
<a class="anchor" id="a01a1f1f58a7011924fce7a35bc480abc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt;MT,SO,SF&gt;&amp; <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}*=\vec{b} $" src="../../form_68.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be multiplied with the sparse row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the sparse row. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a24f8a4d62e4f5e400b2d3851f070f5e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt;MT,SO,SF&gt; &gt;::Type&amp; <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication between a sparse row and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_69.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the sparse row.</dd></dl>
<p>Via this operator it is possible to scale the sparse row. Note however that the function is subject to three restrictions. First, this operator cannot be used for rows on lower or upper unitriangular matrices. The attempt to scale such a row results in a compilation error! Second, this operator can only be used for numeric data types. <a class="el" href="../../d7/d97/structblaze_1_1And.html" title="Compile time logical and evaluation.The And class template performs at compile time a logical and (&#39;&&&#3...">And</a> third, the elements of the sparse row must support the multiplication assignment operator for the given scalar built-in data type. </p>

</div>
</div>
<a class="anchor" id="a18d1b580de66a4638ebbe836c3b2359c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt;MT,SO,SF&gt;&amp; <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator for the addition of a dense vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_66.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be added to the sparse row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the sparse row. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to restricted matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower or upper triangular matrix and the assignment would violate its lower or upper property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a4a9edeed3f0bf56cbb0c6152aae27f5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt;MT,SO,SF&gt;&amp; <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator for the addition of a sparse vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_66.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be added to the sparse row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the sparse row. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to restricted matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower or upper triangular matrix and the assignment would violate its lower or upper property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a8d2f319ac3df11ba247adeba5bab1f58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt;MT,SO,SF&gt;&amp; <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator for the subtraction of a dense vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_67.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted from the sparse row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the sparse row. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to restricted matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower or upper triangular matrix and the assignment would violate its lower or upper property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ac607b18ec82c731d4c54fb5117aad2ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt;MT,SO,SF&gt;&amp; <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator for the subtraction of a sparse vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_67.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted from the sparse row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the sparse row. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to restricted matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower or upper triangular matrix and the assignment would violate its lower or upper property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ad712e9a1ac15a7e89a1201ba46a09b61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt;MT,SO,SF&gt; &gt;::Type&amp; <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator for the division of a sparse row by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_70.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the sparse row.</dd></dl>
<p>Via this operator it is possible to scale the sparse row. Note however that the function is subject to three restrictions. First, this operator cannot be used for rows on lower or upper unitriangular matrices. The attempt to scale such a row results in a compilation error! Second, this operator can only be used for numeric data types. <a class="el" href="../../d7/d97/structblaze_1_1And.html" title="Compile time logical and evaluation.The And class template performs at compile time a logical and (&#39;&&&#3...">And</a> third, the elements of the sparse row must either support the multiplication assignment operator for the given floating point data type or the division assignment operator for the given integral data type.</p>
<p><b>Note:</b> A division by zero is only checked by an user assert. </p>

</div>
</div>
<a class="anchor" id="a07514b8ae2b597a5c3ef27814bfbaa3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt; &amp; <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator for <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html" title="Reference to a specific row of a sparse matrix.The SparseRow template represents a reference to a spe...">SparseRow</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Sparse row to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned row. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d3/db7/structblaze_1_1Row.html" title="Base class for all rows.The Row class serves as a tag for all rows (i.e. dense and sparse rows)...">Row</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to restricted matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two rows don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower or upper triangular matrix and the assignment would violate its lower or upper property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a4960d3119013e108340bb53fd9053be5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt;MT,SO,SF&gt;&amp; <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for dense vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Dense vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned row. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to restricted matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower or upper triangular matrix and the assignment would violate its lower or upper property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a8aeeafa54105a633a5d9172cd4cd625c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt;MT,SO,SF&gt;&amp; <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for sparse vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Sparse vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned row. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to restricted matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower or upper triangular matrix and the assignment would violate its lower or upper property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ac264c873ceb03e1066d61c63eb42984f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ada0b90a1116c26b13bde52e8332d1352">Reference</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the row elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of matrix columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="aacbf22bbf305c6228b0875075936ab50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a2981b8bead50b7e612fc330412cd12ad">ConstReference</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the row elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of matrix columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="a1be3095780509ea4b0c421bdb15920a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt; , TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for non-constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ae37bee20b660eacfcb7a942dc9cdbe19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt; , TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e5ff6db7bc31a0d177a0cc84f85dc63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../df/df0/structblaze_1_1IsRestricted.html">IsRestricted</a>&lt;MT2&gt; &gt;, bool &gt;::Type <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying matrix of type <em>MT</em> would be violated by an assignment of the given vector <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a049993b58265a49311ed50db14a83995"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The lower matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying lower triangular matrix of type <em>MT</em> would be violated by an assignment of the given dense vector <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a20c5e84278fb0c55c40272d96767b7b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The lower matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying lower triangular matrix of type <em>MT</em> would be violated by an assignment of the given sparse vector <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="afd0d929929c10f37805a6215dc90a11e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The upper matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying upper triangular matrix of type <em>MT</em> would be violated by an assignment of the given dense vector <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a700b5db65099caffc7a9dfaf6b575e31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The upper matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying upper triangular matrix of type <em>MT</em> would be violated by an assignment of the given sparse vector <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a383af6896f752bc635f045dafc777f75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt;, bool &gt;::Type <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying diagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The diagonal matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying diagonal matrix of type <em>MT</em> would be violated by an assignment of the given dense vector <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="ad6d009c35b2304419aa91d2acdda345f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt;, bool &gt;::Type <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying diagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The diagonal matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying diagonal matrix of type <em>MT</em> would be violated by an assignment of the given sparse vector <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a620b146674c9f924e6108b1624a23a4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setting the minimum capacity of the sparse row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The new minimum capacity of the sparse row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function increases the capacity of the sparse row to at least <em>n</em> elements. The current values of the row elements are preserved. </p>

</div>
</div>
<a class="anchor" id="ae25f4993c4d5d1fa4d008cce92516f5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to the default initial values. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a6815acac58e1d7559efce06d8a0eca3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsRowMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt;MT,SO,SF&gt;&amp; <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scaling of the sparse row by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_72.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value for the row scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the sparse row.</dd></dl>
<p>This function scales all elements of the row by the given scalar value <em>scalar</em>. Note that the function cannot be used to scale a row on a lower or upper unitriangular matrix. The attempt to scale such a row results in a compile time error! </p>

</div>
</div>
<a class="anchor" id="a45f683e8ed211310f8ac4d85893e1458"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a94645f6ae87c9a1b2b01f72965fc9179">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setting an element of the sparse row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the element to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the set value.</dd></dl>
<p>This function sets the value of an element of the sparse row. In case the sparse row already contains an element with index <em>index</em> its value is modified, else a new element with the given <em>value</em> is inserted. </p>

</div>
</div>
<a class="anchor" id="af2915a7ea6bb89a82973d700241b2464"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current size/dimension of the sparse row. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the sparse row. </dd></dl>

</div>
</div>
<a class="anchor" id="a2184ba1e963abc90a6378085f57d2978"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="abe67561d9cb5100afcb3b0808ac13e7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ab31d668e4fb050c04a63f2e1085529a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a855be5cfd4bf369737ce63b2f1ba9580">Iterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::upperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index greater then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index greater then the given index, <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a15560c010b58be3cbef01840e592a95b" title="Returns an iterator just past the last element of the row. ">end()</a> iterator otherwise.</dd></dl>
<p>This function returns an iterator to the first element with an index greater then the given index. In combination with the <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ab31d668e4fb050c04a63f2e1085529a7" title="Returns an iterator to the first index greater then the given index. ">upperBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned sparse row iterator is subject to invalidation due to inserting operations via the subscript operator or the <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a556413e0fb8b43f5d632828b83919eb9" title="Inserting an element into the sparse row. ">insert()</a> function! </p>

</div>
</div>
<a class="anchor" id="af20c93247b5ff94faa350290ab8c41a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">SparseRow</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#abf8a1376af1b28e14c1be98116d21f59">ConstIterator</a> <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html">blaze::SparseRow</a>&lt; MT, SO, SF &gt;::upperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first index greater then the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the search element. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first index greater then the given index, <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a15560c010b58be3cbef01840e592a95b" title="Returns an iterator just past the last element of the row. ">end()</a> iterator otherwise.</dd></dl>
<p>This function returns an iterator to the first element with an index greater then the given index. In combination with the <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#ab31d668e4fb050c04a63f2e1085529a7" title="Returns an iterator to the first index greater then the given index. ">upperBound()</a> function this function can be used to create a pair of iterators specifying a range of indices. Note that the returned sparse row iterator is subject to invalidation due to inserting operations via the subscript operator or the <a class="el" href="../../d9/dd4/classblaze_1_1SparseRow.html#a556413e0fb8b43f5d632828b83919eb9" title="Inserting an element into the sparse row. ">insert()</a> function! </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>blaze/math/views/<a class="el" href="../../d2/d24/views_2Forward_8h_source.html">Forward.h</a></li>
<li>blaze/math/views/<a class="el" href="../../d6/df1/views_2SparseRow_8h_source.html">SparseRow.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:55:26 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
