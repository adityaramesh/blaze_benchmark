<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>blaze::HybridVector&lt; Type, N, TF &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="../../d7/d11/classblaze_1_1HybridVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::HybridVector&lt; Type, N, TF &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../dc/dcf/group__vector.html">Vectors</a> &raquo; <a class="el" href="../../de/d90/group__dense__vector.html">Dense Vectors</a> &raquo; <a class="el" href="../../d1/dc9/group__hybrid__vector.html">HybridVector</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Efficient implementation of a dynamically sized vector with static memory.The <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a> class template combines the flexibility of a dynamically sized vector with the efficiency and performance of a fixed-size vector. It is implemented as a crossing between the <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector</a> and the <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector</a> class templates: Similar to the static vector it uses static stack memory instead of dynamically allocated memory and similar to the dynamic vector it can be resized (within the extend of the static memory). The type of the elements, the maximum number of elements and the transpose flag of the vector can be specified via the three template parameters:  
 <a href="../../da/d6b/classblaze_1_1HybridVector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d7/dba/dense_2HybridVector_8h_source.html">HybridVector.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">blaze::DenseVector&lt; HybridVector&lt; Type, N, TF &gt;, TF &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d88/structblaze_1_1HybridVector_1_1Rebind.html">Rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dc/d88/structblaze_1_1HybridVector_1_1Rebind.html" title="Rebind mechanism to obtain a HybridVector with different data/element type. ">Rebind</a> mechanism to obtain a <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a> with different data/element type.  <a href="../../dc/d88/structblaze_1_1HybridVector_1_1Rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ga325df944de0d98256be9ddf22808b96d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>vectorizable</b> = IsVectorizable&lt;Type&gt;::value
 }</td></tr>
<tr class="memdesc:ga325df944de0d98256be9ddf22808b96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for intrinsic optimization.  <a href="../../d1/dc9/group__hybrid__vector.html#ga325df944de0d98256be9ddf22808b96d">More...</a><br /></td></tr>
<tr class="separator:ga325df944de0d98256be9ddf22808b96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68bb366e96baf63288a2e4fa08068445"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>smpAssignable</b> = 0
 }</td></tr>
<tr class="memdesc:ga68bb366e96baf63288a2e4fa08068445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for SMP assignments.  <a href="../../d1/dc9/group__hybrid__vector.html#ga68bb366e96baf63288a2e4fa08068445">More...</a><br /></td></tr>
<tr class="separator:ga68bb366e96baf63288a2e4fa08068445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2326767468c4d70473f3e678626bed46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2326767468c4d70473f3e678626bed46"></a>
typedef <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a2326767468c4d70473f3e678626bed46">This</a></td></tr>
<tr class="memdesc:a2326767468c4d70473f3e678626bed46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a> instance. <br /></td></tr>
<tr class="separator:a2326767468c4d70473f3e678626bed46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35eec0e955c67d57113268b4bf4f11a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35eec0e955c67d57113268b4bf4f11a1"></a>
typedef <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a2326767468c4d70473f3e678626bed46">This</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a35eec0e955c67d57113268b4bf4f11a1">ResultType</a></td></tr>
<tr class="memdesc:a35eec0e955c67d57113268b4bf4f11a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br /></td></tr>
<tr class="separator:a35eec0e955c67d57113268b4bf4f11a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb731c4f7b4da29ae880cacff7d217e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fb731c4f7b4da29ae880cacff7d217e"></a>
typedef <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N,!TF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a6fb731c4f7b4da29ae880cacff7d217e">TransposeType</a></td></tr>
<tr class="memdesc:a6fb731c4f7b4da29ae880cacff7d217e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br /></td></tr>
<tr class="separator:a6fb731c4f7b4da29ae880cacff7d217e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c625ccc3c95cc80239e1cadf04933b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c625ccc3c95cc80239e1cadf04933b5"></a>
typedef Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a8c625ccc3c95cc80239e1cadf04933b5">ElementType</a></td></tr>
<tr class="memdesc:a8c625ccc3c95cc80239e1cadf04933b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the vector elements. <br /></td></tr>
<tr class="separator:a8c625ccc3c95cc80239e1cadf04933b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327777ee9e75205f87cb162d1efcc7bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a327777ee9e75205f87cb162d1efcc7bf"></a>
typedef IT::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a327777ee9e75205f87cb162d1efcc7bf">IntrinsicType</a></td></tr>
<tr class="memdesc:a327777ee9e75205f87cb162d1efcc7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic type of the vector elements. <br /></td></tr>
<tr class="separator:a327777ee9e75205f87cb162d1efcc7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c054739b66b0d2c2a91e78892ef27a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4c054739b66b0d2c2a91e78892ef27a"></a>
typedef const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ab4c054739b66b0d2c2a91e78892ef27a">ReturnType</a></td></tr>
<tr class="memdesc:ab4c054739b66b0d2c2a91e78892ef27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br /></td></tr>
<tr class="separator:ab4c054739b66b0d2c2a91e78892ef27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1490557c13b054ed786d9d8b505006db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1490557c13b054ed786d9d8b505006db"></a>
typedef const <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a1490557c13b054ed786d9d8b505006db">CompositeType</a></td></tr>
<tr class="memdesc:a1490557c13b054ed786d9d8b505006db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br /></td></tr>
<tr class="separator:a1490557c13b054ed786d9d8b505006db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a2e935ae43abf2ed5e4518161d49cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91a2e935ae43abf2ed5e4518161d49cf"></a>
typedef Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a91a2e935ae43abf2ed5e4518161d49cf">Reference</a></td></tr>
<tr class="memdesc:a91a2e935ae43abf2ed5e4518161d49cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant vector value. <br /></td></tr>
<tr class="separator:a91a2e935ae43abf2ed5e4518161d49cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11950c312cbb5d8bb9d0a88d58c52ddc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11950c312cbb5d8bb9d0a88d58c52ddc"></a>
typedef const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a11950c312cbb5d8bb9d0a88d58c52ddc">ConstReference</a></td></tr>
<tr class="memdesc:a11950c312cbb5d8bb9d0a88d58c52ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant vector value. <br /></td></tr>
<tr class="separator:a11950c312cbb5d8bb9d0a88d58c52ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc115e50cfa932ecef101f9794f6114"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cc115e50cfa932ecef101f9794f6114"></a>
typedef Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a7cc115e50cfa932ecef101f9794f6114">Pointer</a></td></tr>
<tr class="memdesc:a7cc115e50cfa932ecef101f9794f6114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a non-constant vector value. <br /></td></tr>
<tr class="separator:a7cc115e50cfa932ecef101f9794f6114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e4eda754d0cf3f44b760d9d3ad66aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5e4eda754d0cf3f44b760d9d3ad66aa"></a>
typedef const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac5e4eda754d0cf3f44b760d9d3ad66aa">ConstPointer</a></td></tr>
<tr class="memdesc:ac5e4eda754d0cf3f44b760d9d3ad66aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a constant vector value. <br /></td></tr>
<tr class="separator:ac5e4eda754d0cf3f44b760d9d3ad66aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cc8279d4ccf1d0ef137487d7157109"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23cc8279d4ccf1d0ef137487d7157109"></a>
typedef <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a23cc8279d4ccf1d0ef137487d7157109">Iterator</a></td></tr>
<tr class="memdesc:a23cc8279d4ccf1d0ef137487d7157109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br /></td></tr>
<tr class="separator:a23cc8279d4ccf1d0ef137487d7157109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7640be6ec4dd0f7c9c5461c6e452113"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7640be6ec4dd0f7c9c5461c6e452113"></a>
typedef <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; const Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac7640be6ec4dd0f7c9c5461c6e452113">ConstIterator</a></td></tr>
<tr class="memdesc:ac7640be6ec4dd0f7c9c5461c6e452113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br /></td></tr>
<tr class="separator:ac7640be6ec4dd0f7c9c5461c6e452113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe7ddefcf2554b0bced1ad1b4b53e24"></a>
typedef VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a></td></tr>
<tr class="memdesc:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the vector. <br /></td></tr>
<tr class="separator:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a98371f4fbaf0d0b4a5a3473b5e349b06"><td class="memTemplParams" colspan="2">template&lt;typename Other , size_t M&gt; </td></tr>
<tr class="memitem:a98371f4fbaf0d0b4a5a3473b5e349b06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a98371f4fbaf0d0b4a5a3473b5e349b06">operator=</a> (const Other(&amp;array)[M])</td></tr>
<tr class="memdesc:a98371f4fbaf0d0b4a5a3473b5e349b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array assignment to all vector elements.  <a href="#a98371f4fbaf0d0b4a5a3473b5e349b06">More...</a><br /></td></tr>
<tr class="separator:a98371f4fbaf0d0b4a5a3473b5e349b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ad24bd8c318a75df6ada9b1e8b4800"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a40ad24bd8c318a75df6ada9b1e8b4800"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a40ad24bd8c318a75df6ada9b1e8b4800">operator=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a40ad24bd8c318a75df6ada9b1e8b4800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for different vectors.  <a href="#a40ad24bd8c318a75df6ada9b1e8b4800">More...</a><br /></td></tr>
<tr class="separator:a40ad24bd8c318a75df6ada9b1e8b4800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d59282c9e3be6187a9ce909f2f2ade"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a39d59282c9e3be6187a9ce909f2f2ade"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a39d59282c9e3be6187a9ce909f2f2ade">operator+=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a39d59282c9e3be6187a9ce909f2f2ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator for the addition of a vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_66.png"/>).  <a href="#a39d59282c9e3be6187a9ce909f2f2ade">More...</a><br /></td></tr>
<tr class="separator:a39d59282c9e3be6187a9ce909f2f2ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fcdcfa61a1065812553cc4a04ae919"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a83fcdcfa61a1065812553cc4a04ae919"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a83fcdcfa61a1065812553cc4a04ae919">operator-=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a83fcdcfa61a1065812553cc4a04ae919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator for the subtraction of a vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_67.png"/>).  <a href="#a83fcdcfa61a1065812553cc4a04ae919">More...</a><br /></td></tr>
<tr class="separator:a83fcdcfa61a1065812553cc4a04ae919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29aa44cf5eb106c0f7daa853eda74a07"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a29aa44cf5eb106c0f7daa853eda74a07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a29aa44cf5eb106c0f7daa853eda74a07">operator*=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a29aa44cf5eb106c0f7daa853eda74a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}*=\vec{b} $" src="../../form_68.png"/>).  <a href="#a29aa44cf5eb106c0f7daa853eda74a07">More...</a><br /></td></tr>
<tr class="separator:a29aa44cf5eb106c0f7daa853eda74a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0439bb1387716bc63f31756e49038aba"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a0439bb1387716bc63f31756e49038aba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a0439bb1387716bc63f31756e49038aba">operator*=</a> (Other rhs)</td></tr>
<tr class="memdesc:a0439bb1387716bc63f31756e49038aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication between a vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_69.png"/>).  <a href="#a0439bb1387716bc63f31756e49038aba">More...</a><br /></td></tr>
<tr class="separator:a0439bb1387716bc63f31756e49038aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af565e8766f0c5b2c49ef1e2ec96a1d63"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:af565e8766f0c5b2c49ef1e2ec96a1d63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#af565e8766f0c5b2c49ef1e2ec96a1d63">operator/=</a> (Other rhs)</td></tr>
<tr class="memdesc:af565e8766f0c5b2c49ef1e2ec96a1d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator for the division of a vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_70.png"/>).  <a href="#af565e8766f0c5b2c49ef1e2ec96a1d63">More...</a><br /></td></tr>
<tr class="separator:af565e8766f0c5b2c49ef1e2ec96a1d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30191eaf247d21a692819f6c103bd698"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a30191eaf247d21a692819f6c103bd698"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a30191eaf247d21a692819f6c103bd698">scale</a> (const Other &amp;scalar)</td></tr>
<tr class="memdesc:a30191eaf247d21a692819f6c103bd698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of the vector by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_69.png"/>).  <a href="#a30191eaf247d21a692819f6c103bd698">More...</a><br /></td></tr>
<tr class="separator:a30191eaf247d21a692819f6c103bd698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278e9e7f38441870168e97e6f88243fc"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a278e9e7f38441870168e97e6f88243fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a278e9e7f38441870168e97e6f88243fc">assign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a278e9e7f38441870168e97e6f88243fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a dense vector.  <a href="#a278e9e7f38441870168e97e6f88243fc">More...</a><br /></td></tr>
<tr class="separator:a278e9e7f38441870168e97e6f88243fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebb9021a1a21d676aa1fc61d6cb6d7e"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a0ebb9021a1a21d676aa1fc61d6cb6d7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a0ebb9021a1a21d676aa1fc61d6cb6d7e">assign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0ebb9021a1a21d676aa1fc61d6cb6d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the assignment of a dense vector.  <a href="#a0ebb9021a1a21d676aa1fc61d6cb6d7e">More...</a><br /></td></tr>
<tr class="separator:a0ebb9021a1a21d676aa1fc61d6cb6d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c9575e80f1cab1e407a37bb8b26d0f"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:af5c9575e80f1cab1e407a37bb8b26d0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#af5c9575e80f1cab1e407a37bb8b26d0f">addAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af5c9575e80f1cab1e407a37bb8b26d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a dense vector.  <a href="#af5c9575e80f1cab1e407a37bb8b26d0f">More...</a><br /></td></tr>
<tr class="separator:af5c9575e80f1cab1e407a37bb8b26d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fd629a730b6d2d07bfd1572c679afb"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a72fd629a730b6d2d07bfd1572c679afb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a72fd629a730b6d2d07bfd1572c679afb">addAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a72fd629a730b6d2d07bfd1572c679afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the addition assignment of a dense vector.  <a href="#a72fd629a730b6d2d07bfd1572c679afb">More...</a><br /></td></tr>
<tr class="separator:a72fd629a730b6d2d07bfd1572c679afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84cf74638c7d1f32253766eff36c4dd"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ad84cf74638c7d1f32253766eff36c4dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ad84cf74638c7d1f32253766eff36c4dd">subAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad84cf74638c7d1f32253766eff36c4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a dense vector.  <a href="#ad84cf74638c7d1f32253766eff36c4dd">More...</a><br /></td></tr>
<tr class="separator:ad84cf74638c7d1f32253766eff36c4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aad1557a17892be6eda3894915a6d0"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:aa4aad1557a17892be6eda3894915a6d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#aa4aad1557a17892be6eda3894915a6d0">subAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa4aad1557a17892be6eda3894915a6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the subtraction assignment of a dense vector.  <a href="#aa4aad1557a17892be6eda3894915a6d0">More...</a><br /></td></tr>
<tr class="separator:aa4aad1557a17892be6eda3894915a6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2597a453d1c56906fd403d11899b011b"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a2597a453d1c56906fd403d11899b011b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a2597a453d1c56906fd403d11899b011b">multAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2597a453d1c56906fd403d11899b011b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the multiplication assignment of a dense vector.  <a href="#a2597a453d1c56906fd403d11899b011b">More...</a><br /></td></tr>
<tr class="separator:a2597a453d1c56906fd403d11899b011b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf8b7e0741510f9063779ca4993fff1"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a6bf8b7e0741510f9063779ca4993fff1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a6bf8b7e0741510f9063779ca4993fff1">multAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6bf8b7e0741510f9063779ca4993fff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the multiplication assignment of a dense vector.  <a href="#a6bf8b7e0741510f9063779ca4993fff1">More...</a><br /></td></tr>
<tr class="separator:a6bf8b7e0741510f9063779ca4993fff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be3095780509ea4b0c421bdb15920a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a1be3095780509ea4b0c421bdb15920a0">operator~</a> ()</td></tr>
<tr class="memdesc:a1be3095780509ea4b0c421bdb15920a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for non-constant vectors.  <a href="#a1be3095780509ea4b0c421bdb15920a0">More...</a><br /></td></tr>
<tr class="separator:a1be3095780509ea4b0c421bdb15920a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37bee20b660eacfcb7a942dc9cdbe19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#ae37bee20b660eacfcb7a942dc9cdbe19">operator~</a> () const </td></tr>
<tr class="memdesc:ae37bee20b660eacfcb7a942dc9cdbe19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for constant vectors.  <a href="#ae37bee20b660eacfcb7a942dc9cdbe19">More...</a><br /></td></tr>
<tr class="separator:ae37bee20b660eacfcb7a942dc9cdbe19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a62372fc86bcc8cf5bb6ae3a98786de8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a62372fc86bcc8cf5bb6ae3a98786de8d">HybridVector</a> ()</td></tr>
<tr class="memdesc:a62372fc86bcc8cf5bb6ae3a98786de8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor for <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a>.  <a href="#a62372fc86bcc8cf5bb6ae3a98786de8d">More...</a><br /></td></tr>
<tr class="separator:a62372fc86bcc8cf5bb6ae3a98786de8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82aaefc121837129c2e5fec6370d31b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a82aaefc121837129c2e5fec6370d31b1">HybridVector</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:a82aaefc121837129c2e5fec6370d31b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a vector of size <em>n</em>.  <a href="#a82aaefc121837129c2e5fec6370d31b1">More...</a><br /></td></tr>
<tr class="separator:a82aaefc121837129c2e5fec6370d31b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5190795010eb4944bfd0ff7f5f5023f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#aa5190795010eb4944bfd0ff7f5f5023f">HybridVector</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, const Type &amp;init)</td></tr>
<tr class="memdesc:aa5190795010eb4944bfd0ff7f5f5023f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a homogeneous initialization of all <em>n</em> vector elements.  <a href="#aa5190795010eb4944bfd0ff7f5f5023f">More...</a><br /></td></tr>
<tr class="separator:aa5190795010eb4944bfd0ff7f5f5023f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64939c4c7440ed1352269bdd8455dea"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ac64939c4c7440ed1352269bdd8455dea"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac64939c4c7440ed1352269bdd8455dea">HybridVector</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, const Other *array)</td></tr>
<tr class="memdesc:ac64939c4c7440ed1352269bdd8455dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array initialization of all vector elements.  <a href="#ac64939c4c7440ed1352269bdd8455dea">More...</a><br /></td></tr>
<tr class="separator:ac64939c4c7440ed1352269bdd8455dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d22c175c922f214af01b9b4e934d1c"><td class="memTemplParams" colspan="2">template&lt;typename Other , size_t M&gt; </td></tr>
<tr class="memitem:af3d22c175c922f214af01b9b4e934d1c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#af3d22c175c922f214af01b9b4e934d1c">HybridVector</a> (const Other(&amp;array)[M])</td></tr>
<tr class="memdesc:af3d22c175c922f214af01b9b4e934d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array initialization of all vector elements.  <a href="#af3d22c175c922f214af01b9b4e934d1c">More...</a><br /></td></tr>
<tr class="separator:af3d22c175c922f214af01b9b4e934d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebde71810ffd1818bb8c36742bb4c98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#aaebde71810ffd1818bb8c36742bb4c98">HybridVector</a> (const <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> &amp;v)</td></tr>
<tr class="memdesc:aaebde71810ffd1818bb8c36742bb4c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor for <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a>.  <a href="#aaebde71810ffd1818bb8c36742bb4c98">More...</a><br /></td></tr>
<tr class="separator:aaebde71810ffd1818bb8c36742bb4c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2bf3c3265c2c197cb329bde236ccf0"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a1a2bf3c3265c2c197cb329bde236ccf0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a1a2bf3c3265c2c197cb329bde236ccf0">HybridVector</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;v)</td></tr>
<tr class="memdesc:a1a2bf3c3265c2c197cb329bde236ccf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion constructor from different vectors.  <a href="#a1a2bf3c3265c2c197cb329bde236ccf0">More...</a><br /></td></tr>
<tr class="separator:a1a2bf3c3265c2c197cb329bde236ccf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access functions</div></td></tr>
<tr class="memitem:abf53db2ffda6a38339962130b2700648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a91a2e935ae43abf2ed5e4518161d49cf">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#abf53db2ffda6a38339962130b2700648">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:abf53db2ffda6a38339962130b2700648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the vector elements.  <a href="#abf53db2ffda6a38339962130b2700648">More...</a><br /></td></tr>
<tr class="separator:abf53db2ffda6a38339962130b2700648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f5cf0381ae6533c8e91db5b4736223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a11950c312cbb5d8bb9d0a88d58c52ddc">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a23f5cf0381ae6533c8e91db5b4736223">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:a23f5cf0381ae6533c8e91db5b4736223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the vector elements.  <a href="#a23f5cf0381ae6533c8e91db5b4736223">More...</a><br /></td></tr>
<tr class="separator:a23f5cf0381ae6533c8e91db5b4736223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c63122f66f24dac4661c2a4a9bf802"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a7cc115e50cfa932ecef101f9794f6114">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac7c63122f66f24dac4661c2a4a9bf802">data</a> ()</td></tr>
<tr class="memdesc:ac7c63122f66f24dac4661c2a4a9bf802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the vector elements.  <a href="#ac7c63122f66f24dac4661c2a4a9bf802">More...</a><br /></td></tr>
<tr class="separator:ac7c63122f66f24dac4661c2a4a9bf802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb115b4d2c351259b0d9d93eb57e8ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac5e4eda754d0cf3f44b760d9d3ad66aa">ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a8fb115b4d2c351259b0d9d93eb57e8ea">data</a> () const </td></tr>
<tr class="memdesc:a8fb115b4d2c351259b0d9d93eb57e8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the vector elements.  <a href="#a8fb115b4d2c351259b0d9d93eb57e8ea">More...</a><br /></td></tr>
<tr class="separator:a8fb115b4d2c351259b0d9d93eb57e8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2154c677515bea02608bb23810af95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a23cc8279d4ccf1d0ef137487d7157109">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a5d2154c677515bea02608bb23810af95">begin</a> ()</td></tr>
<tr class="memdesc:a5d2154c677515bea02608bb23810af95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the hybrid vector.  <a href="#a5d2154c677515bea02608bb23810af95">More...</a><br /></td></tr>
<tr class="separator:a5d2154c677515bea02608bb23810af95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c52d278665606fe170a391f80e4bd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac7640be6ec4dd0f7c9c5461c6e452113">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a16c52d278665606fe170a391f80e4bd8">begin</a> () const </td></tr>
<tr class="memdesc:a16c52d278665606fe170a391f80e4bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the hybrid vector.  <a href="#a16c52d278665606fe170a391f80e4bd8">More...</a><br /></td></tr>
<tr class="separator:a16c52d278665606fe170a391f80e4bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc79a93e16ec277776e0db42ee6276b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac7640be6ec4dd0f7c9c5461c6e452113">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#adfc79a93e16ec277776e0db42ee6276b">cbegin</a> () const </td></tr>
<tr class="memdesc:adfc79a93e16ec277776e0db42ee6276b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the hybrid vector.  <a href="#adfc79a93e16ec277776e0db42ee6276b">More...</a><br /></td></tr>
<tr class="separator:adfc79a93e16ec277776e0db42ee6276b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5f6f2a017ed049bba9c854e69cce6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a23cc8279d4ccf1d0ef137487d7157109">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a1f5f6f2a017ed049bba9c854e69cce6f">end</a> ()</td></tr>
<tr class="memdesc:a1f5f6f2a017ed049bba9c854e69cce6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the hybrid vector.  <a href="#a1f5f6f2a017ed049bba9c854e69cce6f">More...</a><br /></td></tr>
<tr class="separator:a1f5f6f2a017ed049bba9c854e69cce6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b61f93ba3273d756c35f54d2d72f9ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac7640be6ec4dd0f7c9c5461c6e452113">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a3b61f93ba3273d756c35f54d2d72f9ee">end</a> () const </td></tr>
<tr class="memdesc:a3b61f93ba3273d756c35f54d2d72f9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the hybrid vector.  <a href="#a3b61f93ba3273d756c35f54d2d72f9ee">More...</a><br /></td></tr>
<tr class="separator:a3b61f93ba3273d756c35f54d2d72f9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0e03222cd8406903ec7beea37e9de1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac7640be6ec4dd0f7c9c5461c6e452113">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#aed0e03222cd8406903ec7beea37e9de1">cend</a> () const </td></tr>
<tr class="memdesc:aed0e03222cd8406903ec7beea37e9de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the hybrid vector.  <a href="#aed0e03222cd8406903ec7beea37e9de1">More...</a><br /></td></tr>
<tr class="separator:aed0e03222cd8406903ec7beea37e9de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment operators</div></td></tr>
<tr class="memitem:af291533577f5761913043e47ee1cd0ff"><td class="memTemplParams" colspan="2"><a class="anchor" id="af291533577f5761913043e47ee1cd0ff"></a>
template&lt;typename Other , size_t M&gt; </td></tr>
<tr class="memitem:af291533577f5761913043e47ee1cd0ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const Other(&amp;array)[M])</td></tr>
<tr class="separator:af291533577f5761913043e47ee1cd0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d3fd8f1433b33fffec97837bbb5c9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a53d3fd8f1433b33fffec97837bbb5c9b">operator=</a> (const Type &amp;rhs)</td></tr>
<tr class="memdesc:a53d3fd8f1433b33fffec97837bbb5c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Homogenous assignment to all vector elements.  <a href="#a53d3fd8f1433b33fffec97837bbb5c9b">More...</a><br /></td></tr>
<tr class="separator:a53d3fd8f1433b33fffec97837bbb5c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95282456fe92fb23c8fdc3da71ed583"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#af95282456fe92fb23c8fdc3da71ed583">operator=</a> (const <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> &amp;rhs)</td></tr>
<tr class="memdesc:af95282456fe92fb23c8fdc3da71ed583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a>.  <a href="#af95282456fe92fb23c8fdc3da71ed583">More...</a><br /></td></tr>
<tr class="separator:af95282456fe92fb23c8fdc3da71ed583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fb4e4a864b07b22c25af31ddefd4b3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a12fb4e4a864b07b22c25af31ddefd4b3"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a12fb4e4a864b07b22c25af31ddefd4b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a12fb4e4a864b07b22c25af31ddefd4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602769e836c7c2e0a7cce21d92bdebf0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a602769e836c7c2e0a7cce21d92bdebf0"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a602769e836c7c2e0a7cce21d92bdebf0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a602769e836c7c2e0a7cce21d92bdebf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619154e739e98a87416a6a3f8107ff09"><td class="memTemplParams" colspan="2"><a class="anchor" id="a619154e739e98a87416a6a3f8107ff09"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a619154e739e98a87416a6a3f8107ff09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a619154e739e98a87416a6a3f8107ff09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8268ffcce8436fa7cc108d8979381eb1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8268ffcce8436fa7cc108d8979381eb1"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a8268ffcce8436fa7cc108d8979381eb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a8268ffcce8436fa7cc108d8979381eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb3c23f1b7b9aef202cf3089e0b16b9"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaeb3c23f1b7b9aef202cf3089e0b16b9"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:aaeb3c23f1b7b9aef202cf3089e0b16b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (Other rhs)</td></tr>
<tr class="separator:aaeb3c23f1b7b9aef202cf3089e0b16b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e3cb6a8192eeb9f67d1192beb84b0f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a33e3cb6a8192eeb9f67d1192beb84b0f"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a33e3cb6a8192eeb9f67d1192beb84b0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (Other rhs)</td></tr>
<tr class="separator:a33e3cb6a8192eeb9f67d1192beb84b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility functions</div></td></tr>
<tr class="memitem:a1184712be187f087362abe3bf5c313af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a1184712be187f087362abe3bf5c313af">size</a> () const </td></tr>
<tr class="memdesc:a1184712be187f087362abe3bf5c313af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size/dimension of the vector.  <a href="#a1184712be187f087362abe3bf5c313af">More...</a><br /></td></tr>
<tr class="separator:a1184712be187f087362abe3bf5c313af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ece4cbc5f6a3e0625e85041b5f47a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a47ece4cbc5f6a3e0625e85041b5f47a7">capacity</a> () const </td></tr>
<tr class="memdesc:a47ece4cbc5f6a3e0625e85041b5f47a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the vector.  <a href="#a47ece4cbc5f6a3e0625e85041b5f47a7">More...</a><br /></td></tr>
<tr class="separator:a47ece4cbc5f6a3e0625e85041b5f47a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a78b6f023e67c048b111bed7ea49bd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a0a78b6f023e67c048b111bed7ea49bd6">nonZeros</a> () const </td></tr>
<tr class="memdesc:a0a78b6f023e67c048b111bed7ea49bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the vector.  <a href="#a0a78b6f023e67c048b111bed7ea49bd6">More...</a><br /></td></tr>
<tr class="separator:a0a78b6f023e67c048b111bed7ea49bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9f7cc1834c80547fbbb5bf69cda24e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a8c9f7cc1834c80547fbbb5bf69cda24e">reset</a> ()</td></tr>
<tr class="memdesc:a8c9f7cc1834c80547fbbb5bf69cda24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to the default initial values.  <a href="#a8c9f7cc1834c80547fbbb5bf69cda24e">More...</a><br /></td></tr>
<tr class="separator:a8c9f7cc1834c80547fbbb5bf69cda24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22a8e311de705143bf40ea83679fce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac22a8e311de705143bf40ea83679fce1">clear</a> ()</td></tr>
<tr class="memdesc:ac22a8e311de705143bf40ea83679fce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the vector.  <a href="#ac22a8e311de705143bf40ea83679fce1">More...</a><br /></td></tr>
<tr class="separator:ac22a8e311de705143bf40ea83679fce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acfa247b976e06b8a5fa7925d0cac39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a6acfa247b976e06b8a5fa7925d0cac39">resize</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve=true)</td></tr>
<tr class="memdesc:a6acfa247b976e06b8a5fa7925d0cac39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing the size of the vector.  <a href="#a6acfa247b976e06b8a5fa7925d0cac39">More...</a><br /></td></tr>
<tr class="separator:a6acfa247b976e06b8a5fa7925d0cac39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb50c3ae2dfe4b65e02b50e1302ae76b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#adb50c3ae2dfe4b65e02b50e1302ae76b">extend</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve=true)</td></tr>
<tr class="memdesc:adb50c3ae2dfe4b65e02b50e1302ae76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extending the size of the vector.  <a href="#adb50c3ae2dfe4b65e02b50e1302ae76b">More...</a><br /></td></tr>
<tr class="separator:adb50c3ae2dfe4b65e02b50e1302ae76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b7ef5243ee06c914a887c0a19a47b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a95b7ef5243ee06c914a887c0a19a47b1"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a95b7ef5243ee06c914a887c0a19a47b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scale</b> (const Other &amp;scalar)</td></tr>
<tr class="separator:a95b7ef5243ee06c914a887c0a19a47b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035b7a7ccf3e6bcce766107c1cab631b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a035b7a7ccf3e6bcce766107c1cab631b">swap</a> (<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> &amp;v)</td></tr>
<tr class="memdesc:a035b7a7ccf3e6bcce766107c1cab631b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two hybrid vectors.  <a href="#a035b7a7ccf3e6bcce766107c1cab631b">More...</a><br /></td></tr>
<tr class="separator:a035b7a7ccf3e6bcce766107c1cab631b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression template evaluation functions</div></td></tr>
<tr class="memitem:a3b8662a2e1c8e1970a3886ddf24d41da"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a3b8662a2e1c8e1970a3886ddf24d41da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a3b8662a2e1c8e1970a3886ddf24d41da">canAlias</a> (const Other *alias) const </td></tr>
<tr class="memdesc:a3b8662a2e1c8e1970a3886ddf24d41da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector can alias with the given address <em>alias</em>.  <a href="#a3b8662a2e1c8e1970a3886ddf24d41da">More...</a><br /></td></tr>
<tr class="separator:a3b8662a2e1c8e1970a3886ddf24d41da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6af292c31d02ad4b7d80b9812c0501"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ade6af292c31d02ad4b7d80b9812c0501"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ade6af292c31d02ad4b7d80b9812c0501">isAliased</a> (const Other *alias) const </td></tr>
<tr class="memdesc:ade6af292c31d02ad4b7d80b9812c0501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector is aliased with the given address <em>alias</em>.  <a href="#ade6af292c31d02ad4b7d80b9812c0501">More...</a><br /></td></tr>
<tr class="separator:ade6af292c31d02ad4b7d80b9812c0501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e769edbdf1453c88e2f80d74a6cfaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac8e769edbdf1453c88e2f80d74a6cfaa">isAligned</a> () const </td></tr>
<tr class="memdesc:ac8e769edbdf1453c88e2f80d74a6cfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector is properly aligned in memory.  <a href="#ac8e769edbdf1453c88e2f80d74a6cfaa">More...</a><br /></td></tr>
<tr class="separator:ac8e769edbdf1453c88e2f80d74a6cfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc7bae6f409f474f247228a076dfa8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a327777ee9e75205f87cb162d1efcc7bf">IntrinsicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#aedc7bae6f409f474f247228a076dfa8d">load</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:aedc7bae6f409f474f247228a076dfa8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned load of an intrinsic element of the vector.  <a href="#aedc7bae6f409f474f247228a076dfa8d">More...</a><br /></td></tr>
<tr class="separator:aedc7bae6f409f474f247228a076dfa8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bb160d223a935f1ab3c9ddd7173531"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a327777ee9e75205f87cb162d1efcc7bf">IntrinsicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a48bb160d223a935f1ab3c9ddd7173531">loadu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:a48bb160d223a935f1ab3c9ddd7173531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned load of an intrinsic element of the vector.  <a href="#a48bb160d223a935f1ab3c9ddd7173531">More...</a><br /></td></tr>
<tr class="separator:a48bb160d223a935f1ab3c9ddd7173531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eedfb5536c2198b237287df783c8839"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a0eedfb5536c2198b237287df783c8839">store</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a327777ee9e75205f87cb162d1efcc7bf">IntrinsicType</a> &amp;value)</td></tr>
<tr class="memdesc:a0eedfb5536c2198b237287df783c8839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of an intrinsic element of the vector.  <a href="#a0eedfb5536c2198b237287df783c8839">More...</a><br /></td></tr>
<tr class="separator:a0eedfb5536c2198b237287df783c8839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee093e28f8dce58385717d1cbec8351"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a7ee093e28f8dce58385717d1cbec8351">storeu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a327777ee9e75205f87cb162d1efcc7bf">IntrinsicType</a> &amp;value)</td></tr>
<tr class="memdesc:a7ee093e28f8dce58385717d1cbec8351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of an intrinsic element of the vector.  <a href="#a7ee093e28f8dce58385717d1cbec8351">More...</a><br /></td></tr>
<tr class="separator:a7ee093e28f8dce58385717d1cbec8351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cdb55836d512eb4df1e643f82d8405"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ab4cdb55836d512eb4df1e643f82d8405">stream</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a327777ee9e75205f87cb162d1efcc7bf">IntrinsicType</a> &amp;value)</td></tr>
<tr class="memdesc:ab4cdb55836d512eb4df1e643f82d8405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of an intrinsic element of the vector.  <a href="#ab4cdb55836d512eb4df1e643f82d8405">More...</a><br /></td></tr>
<tr class="separator:ab4cdb55836d512eb4df1e643f82d8405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44602841f67d2482b64d7c019c6c2e4c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a44602841f67d2482b64d7c019c6c2e4c"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a44602841f67d2482b64d7c019c6c2e4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a44602841f67d2482b64d7c019c6c2e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeded54527643a85236a757d7404c781c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeded54527643a85236a757d7404c781c"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:aeded54527643a85236a757d7404c781c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:aeded54527643a85236a757d7404c781c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51919ad4ebd68f99e58f6f864f8c3222"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a51919ad4ebd68f99e58f6f864f8c3222"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a51919ad4ebd68f99e58f6f864f8c3222">assign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a51919ad4ebd68f99e58f6f864f8c3222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a sparse vector.  <a href="#a51919ad4ebd68f99e58f6f864f8c3222">More...</a><br /></td></tr>
<tr class="separator:a51919ad4ebd68f99e58f6f864f8c3222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb95ef900d3164f90d0279e5c34fe262"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb95ef900d3164f90d0279e5c34fe262"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:abb95ef900d3164f90d0279e5c34fe262"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedAddAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:abb95ef900d3164f90d0279e5c34fe262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06c3fbbc6208f08d8111cabc8da1857"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac06c3fbbc6208f08d8111cabc8da1857"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ac06c3fbbc6208f08d8111cabc8da1857"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedAddAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:ac06c3fbbc6208f08d8111cabc8da1857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922a682fea03ac66b65f55b009b4c9b1"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a922a682fea03ac66b65f55b009b4c9b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a922a682fea03ac66b65f55b009b4c9b1">addAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a922a682fea03ac66b65f55b009b4c9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a sparse vector.  <a href="#a922a682fea03ac66b65f55b009b4c9b1">More...</a><br /></td></tr>
<tr class="separator:a922a682fea03ac66b65f55b009b4c9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812c0ad6166c2027d8a4d0042ab4b693"><td class="memTemplParams" colspan="2"><a class="anchor" id="a812c0ad6166c2027d8a4d0042ab4b693"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a812c0ad6166c2027d8a4d0042ab4b693"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedSubAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a812c0ad6166c2027d8a4d0042ab4b693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af776125923b2634f6d1c544966788f9f"><td class="memTemplParams" colspan="2"><a class="anchor" id="af776125923b2634f6d1c544966788f9f"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:af776125923b2634f6d1c544966788f9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedSubAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:af776125923b2634f6d1c544966788f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8f26a9367ffa8aeb46c80c18b15e7b"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a3d8f26a9367ffa8aeb46c80c18b15e7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a3d8f26a9367ffa8aeb46c80c18b15e7b">subAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a3d8f26a9367ffa8aeb46c80c18b15e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a sparse vector.  <a href="#a3d8f26a9367ffa8aeb46c80c18b15e7b">More...</a><br /></td></tr>
<tr class="separator:a3d8f26a9367ffa8aeb46c80c18b15e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35eccff350474c6d0277dbf0ec77206"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa35eccff350474c6d0277dbf0ec77206"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:aa35eccff350474c6d0277dbf0ec77206"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedMultAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:aa35eccff350474c6d0277dbf0ec77206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287e3ca3855769c0f8cfb404f3f74d88"><td class="memTemplParams" colspan="2"><a class="anchor" id="a287e3ca3855769c0f8cfb404f3f74d88"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a287e3ca3855769c0f8cfb404f3f74d88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedMultAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a287e3ca3855769c0f8cfb404f3f74d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2164c508b5f5a5bcfa7dbf1ecad88a24"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a2164c508b5f5a5bcfa7dbf1ecad88a24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a2164c508b5f5a5bcfa7dbf1ecad88a24">multAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2164c508b5f5a5bcfa7dbf1ecad88a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the multiplication assignment of a sparse vector.  <a href="#a2164c508b5f5a5bcfa7dbf1ecad88a24">More...</a><br /></td></tr>
<tr class="separator:a2164c508b5f5a5bcfa7dbf1ecad88a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory functions</div></td></tr>
<tr class="memitem:a5f2b48817e2330a92d7d8cd9aa8f2ef7"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a5f2b48817e2330a92d7d8cd9aa8f2ef7">operator new</a> (std::size_t <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a1184712be187f087362abe3bf5c313af">size</a>)</td></tr>
<tr class="memdesc:a5f2b48817e2330a92d7d8cd9aa8f2ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class specific implementation of operator new.  <a href="#a5f2b48817e2330a92d7d8cd9aa8f2ef7">More...</a><br /></td></tr>
<tr class="separator:a5f2b48817e2330a92d7d8cd9aa8f2ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ccbea4403baff7c79d9d5d35b8fce3"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac8ccbea4403baff7c79d9d5d35b8fce3">operator new[]</a> (std::size_t <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a1184712be187f087362abe3bf5c313af">size</a>)</td></tr>
<tr class="memdesc:ac8ccbea4403baff7c79d9d5d35b8fce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class specific implementation of operator new[].  <a href="#ac8ccbea4403baff7c79d9d5d35b8fce3">More...</a><br /></td></tr>
<tr class="separator:ac8ccbea4403baff7c79d9d5d35b8fce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c1527b4f39635e57223719f71de141"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#af0c1527b4f39635e57223719f71de141">operator new</a> (std::size_t <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a1184712be187f087362abe3bf5c313af">size</a>, const std::nothrow_t &amp;)</td></tr>
<tr class="memdesc:af0c1527b4f39635e57223719f71de141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class specific implementation of the no-throw operator new.  <a href="#af0c1527b4f39635e57223719f71de141">More...</a><br /></td></tr>
<tr class="separator:af0c1527b4f39635e57223719f71de141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450d2faa792664f31ad22006976eb76e"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a450d2faa792664f31ad22006976eb76e">operator new[]</a> (std::size_t <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a1184712be187f087362abe3bf5c313af">size</a>, const std::nothrow_t &amp;)</td></tr>
<tr class="memdesc:a450d2faa792664f31ad22006976eb76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class specific implementation of the no-throw operator new[].  <a href="#a450d2faa792664f31ad22006976eb76e">More...</a><br /></td></tr>
<tr class="separator:a450d2faa792664f31ad22006976eb76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5898c85476f93a4795630b8369cc74"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a7b5898c85476f93a4795630b8369cc74">operator delete</a> (void *ptr)</td></tr>
<tr class="memdesc:a7b5898c85476f93a4795630b8369cc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class specific implementation of operator delete.  <a href="#a7b5898c85476f93a4795630b8369cc74">More...</a><br /></td></tr>
<tr class="separator:a7b5898c85476f93a4795630b8369cc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583c20c26b9fd48bff0d19750fe6fc3d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a583c20c26b9fd48bff0d19750fe6fc3d">operator delete[]</a> (void *ptr)</td></tr>
<tr class="memdesc:a583c20c26b9fd48bff0d19750fe6fc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class specific implementation of operator delete[].  <a href="#a583c20c26b9fd48bff0d19750fe6fc3d">More...</a><br /></td></tr>
<tr class="separator:a583c20c26b9fd48bff0d19750fe6fc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b6a23e99873bf73eef651ef776a3dd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a59b6a23e99873bf73eef651ef776a3dd">operator delete</a> (void *ptr, const std::nothrow_t &amp;)</td></tr>
<tr class="memdesc:a59b6a23e99873bf73eef651ef776a3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class specific implementation of no-throw operator delete.  <a href="#a59b6a23e99873bf73eef651ef776a3dd">More...</a><br /></td></tr>
<tr class="separator:a59b6a23e99873bf73eef651ef776a3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8375ebfbfe7d240463340c1a6f464a4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#aa8375ebfbfe7d240463340c1a6f464a4">operator delete[]</a> (void *ptr, const std::nothrow_t &amp;)</td></tr>
<tr class="memdesc:aa8375ebfbfe7d240463340c1a6f464a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class specific implementation of no-throw operator delete[].  <a href="#aa8375ebfbfe7d240463340c1a6f464a4">More...</a><br /></td></tr>
<tr class="separator:aa8375ebfbfe7d240463340c1a6f464a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ga40facc22e3c785672b9843a299a8b8ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga40facc22e3c785672b9843a299a8b8ae"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>NN</b> = N + ( IT::size - ( N % IT::size ) ) % IT::size
 }</td></tr>
<tr class="memdesc:ga40facc22e3c785672b9843a299a8b8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment adjustment. <br /></td></tr>
<tr class="separator:ga40facc22e3c785672b9843a299a8b8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d557789a124b5b19493ebe052082786"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d557789a124b5b19493ebe052082786"></a>
typedef <a class="el" href="../../d7/d73/classblaze_1_1IntrinsicTrait.html">IntrinsicTrait</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a3d557789a124b5b19493ebe052082786">IT</a></td></tr>
<tr class="memdesc:a3d557789a124b5b19493ebe052082786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic trait for the vector element type. <br /></td></tr>
<tr class="separator:a3d557789a124b5b19493ebe052082786"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:a6758d32ef718463ddbfcde831d6538fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d25/classblaze_1_1AlignedArray.html">AlignedArray</a>&lt; Type, NN &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a6758d32ef718463ddbfcde831d6538fa">v_</a></td></tr>
<tr class="memdesc:a6758d32ef718463ddbfcde831d6538fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The statically allocated vector elements.  <a href="#a6758d32ef718463ddbfcde831d6538fa">More...</a><br /></td></tr>
<tr class="separator:a6758d32ef718463ddbfcde831d6538fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2a723a4687c1d0f1596151b18e2608"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa2a723a4687c1d0f1596151b18e2608"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#aaa2a723a4687c1d0f1596151b18e2608">size_</a></td></tr>
<tr class="memdesc:aaa2a723a4687c1d0f1596151b18e2608"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current size/dimension of the vector. <br /></td></tr>
<tr class="separator:aaa2a723a4687c1d0f1596151b18e2608"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt;<br />
class blaze::HybridVector&lt; Type, N, TF &gt;</h3>

<p>Efficient implementation of a dynamically sized vector with static memory.</p>
<p>The <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a> class template combines the flexibility of a dynamically sized vector with the efficiency and performance of a fixed-size vector. It is implemented as a crossing between the <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">blaze::StaticVector</a> and the <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">blaze::DynamicVector</a> class templates: Similar to the static vector it uses static stack memory instead of dynamically allocated memory and similar to the dynamic vector it can be resized (within the extend of the static memory). The type of the elements, the maximum number of elements and the transpose flag of the vector can be specified via the three template parameters: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> Type, <span class="keywordtype">size_t</span> N, <span class="keywordtype">bool</span> TF &gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="../../da/d6b/classblaze_1_1HybridVector.html#a62372fc86bcc8cf5bb6ae3a98786de8d">HybridVector</a>;</div>
</div><!-- fragment --><ul>
<li>Type: specifies the type of the vector elements. <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a> can be used with any non-cv-qualified, non-reference, non-pointer element type.</li>
<li>N : specifies the maximum number of vector elements, i.e. the maximum size of the vector. It is expected that <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a> is only used for tiny and small vectors.</li>
<li>TF : specifies whether the vector is a row vector (<em><a class="el" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors. ">blaze::rowVector</a></em>) or a column vector (<em><a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors. ">blaze::columnVector</a></em>). The default value is <em><a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors. ">blaze::columnVector</a></em>.</li>
</ul>
<p>These contiguously stored elements can be directly accessed with the subscript operator. The numbering of the vector elements is</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{4}{c}} 0 &amp; 1 &amp; \cdots &amp; N-1 \\ \end{array}\right)\]" src="../../form_73.png"/>
</p>
<p>The use of <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a> is very natural and intuitive. All operations (addition, subtraction, multiplication, scaling, ...) can be performed on all possible combinations of dense and sparse vectors with fitting element types. The following example gives an impression of the use of a 2-dimensional <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d3/dd3/classblaze_1_1StaticMatrix.html">blaze::StaticMatrix</a>;</div>
<div class="line"></div>
<div class="line">HybridVector&lt;double,2UL&gt; a( 2 );  <span class="comment">// Non-initialized 2D vector of size 2</span></div>
<div class="line">a[0] = 1.0;                       <span class="comment">// Initialization of the first element</span></div>
<div class="line">a[1] = 2.0;                       <span class="comment">// Initialization of the second element</span></div>
<div class="line"></div>
<div class="line">HybridVector&lt;double,2UL&gt; b( 2, 2.0 );  <span class="comment">// Directly, homogeneously initialized 2D vector</span></div>
<div class="line">CompressedVector&lt;float&gt;  c( 2 );       <span class="comment">// Empty sparse single precision vector</span></div>
<div class="line">HybridVector&lt;double,2UL&gt; d;            <span class="comment">// Default constructed hybrid vector</span></div>
<div class="line">StaticMatrix&lt;double,2UL,2UL&gt; A;        <span class="comment">// Default constructed static row-major matrix</span></div>
<div class="line"></div>
<div class="line">d = a + b;  <span class="comment">// Vector addition between vectors of equal element type</span></div>
<div class="line">d = a - c;  <span class="comment">// Vector subtraction between a dense and sparse vector with different element types</span></div>
<div class="line">d = a * b;  <span class="comment">// Component-wise vector multiplication</span></div>
<div class="line"></div>
<div class="line">a *= 2.0;      <span class="comment">// In-place scaling of vector</span></div>
<div class="line">d  = a * 2.0;  <span class="comment">// Scaling of vector a</span></div>
<div class="line">d  = 2.0 * a;  <span class="comment">// Scaling of vector a</span></div>
<div class="line"></div>
<div class="line">d += a - b;  <span class="comment">// Addition assignment</span></div>
<div class="line">d -= a + c;  <span class="comment">// Subtraction assignment</span></div>
<div class="line">d *= a * b;  <span class="comment">// Multiplication assignment</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> scalar = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( a ) * b;  <span class="comment">// Scalar/dot/inner product between two vectors</span></div>
<div class="line"></div>
<div class="line">A = a * <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( b );  <span class="comment">// Outer product between two vectors</span></div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a62372fc86bcc8cf5bb6ae3a98786de8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default constructor for <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a>. </p>
<p>The size of a default constructed <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a> is initially set to 0. </p>

</div>
</div>
<a class="anchor" id="a82aaefc121837129c2e5fec6370d31b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a vector of size <em>n</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The size of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid size for hybrid vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor creates a hybrid vector of size <em>n</em> and initializes all vector elements to the default value (for instance 0 for integral types). In case <em>n</em> is larger than the maximum allowed number of elements (i.e. <em>n</em> &gt; N) a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="aa5190795010eb4944bfd0ff7f5f5023f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a homogeneous initialization of all <em>n</em> vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The size of the vector. </td></tr>
    <tr><td class="paramname">init</td><td>The initial value of the vector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid size for hybrid vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor creates a hybrid vector of size <em>n</em> and initializes all vector elements with the specified value. In case <em>n</em> is larger than the maximum allowed number of elements (i.e. <em>n</em> &gt; N) a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ac64939c4c7440ed1352269bdd8455dea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array initialization of all vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The size of the vector. </td></tr>
    <tr><td class="paramname">array</td><td>Dynamic array for the initialization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid size for hybrid vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This assignment operator offers the option to directly initialize the elements of the vector with a dynamic array:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span>* array = <span class="keyword">new</span> <span class="keywordtype">double</span>[6];</div>
<div class="line"><span class="comment">// ... Initialization of the dynamic array</span></div>
<div class="line"><a class="code" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector&lt;double,6&gt;</a> v( array, 6UL );</div>
<div class="line"><span class="keyword">delete</span>[] array;</div>
</div><!-- fragment --><p>The vector is sized according to the size of the array and initialized with the values from the given array. In case the size of the given array exceeds the maximum size of the hybrid vector (i.e. is larger than N), a <em>std::invalid_argument</em> exception is thrown.<br />
Note that it is expected that the given <em>array</em> has at least <em>n</em> elements. Providing an array with less elements results in undefined behavior! </p>

</div>
</div>
<a class="anchor" id="af3d22c175c922f214af01b9b4e934d1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other , size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> </td>
          <td>(</td>
          <td class="paramtype">const Other(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[M]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array initialization of all vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>M-dimensional array for the initialization.</td></tr>
  </table>
  </dd>
</dl>
<p>This assignment operator offers the option to directly initialize the elements of the vector with a static array:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> init[2] = { 1.0, 2.0 };</div>
<div class="line"><a class="code" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector&lt;double,4&gt;</a> v( init );</div>
</div><!-- fragment --><p>The vector is sized according to the size of the array and initialized with the values from the given array. This constructor only works for arrays with a size smaller-or-equal than the maximum number of elements of the hybrid vector (i.e. M &lt;= N). The attempt to use a larger array will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="aaebde71810ffd1818bb8c36742bb4c98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The copy constructor for <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> to be copied.</td></tr>
  </table>
  </dd>
</dl>
<p>The copy constructor is explicitly defined in order to enable/facilitate NRV optimization. </p>

</div>
</div>
<a class="anchor" id="a1a2bf3c3265c2c197cb329bde236ccf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion constructor from different vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid setup of hybrid vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor initializes the hybrid vector from the given vector. In case the size of the given vector exceeds the maximum size of the hybrid vector (i.e. is larger than N), a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a922a682fea03ac66b65f55b009b4c9b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="af5c9575e80f1cab1e407a37bb8b26d0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a72fd629a730b6d2d07bfd1572c679afb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the addition assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a51919ad4ebd68f99e58f6f864f8c3222"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a278e9e7f38441870168e97e6f88243fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt;::BLAZE_TEMPLATE VectorizedAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a0ebb9021a1a21d676aa1fc61d6cb6d7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt;::BLAZE_TEMPLATE VectorizedAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a5d2154c677515bea02608bb23810af95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a23cc8279d4ccf1d0ef137487d7157109">Iterator</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the hybrid vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the hybrid vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a16c52d278665606fe170a391f80e4bd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac7640be6ec4dd0f7c9c5461c6e452113">ConstIterator</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the hybrid vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the hybrid vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b8662a2e1c8e1970a3886ddf24d41da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::canAlias </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector can alias with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this vector, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address can alias with the vector. In contrast to the <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ade6af292c31d02ad4b7d80b9812c0501" title="Returns whether the vector is aliased with the given address alias. ">isAliased()</a> function this function is allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="a47ece4cbc5f6a3e0625e85041b5f47a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="adfc79a93e16ec277776e0db42ee6276b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac7640be6ec4dd0f7c9c5461c6e452113">ConstIterator</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the hybrid vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the hybrid vector. </dd></dl>

</div>
</div>
<a class="anchor" id="aed0e03222cd8406903ec7beea37e9de1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac7640be6ec4dd0f7c9c5461c6e452113">ConstIterator</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the hybrid vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the hybrid vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ac22a8e311de705143bf40ea83679fce1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clearing the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>After the <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac22a8e311de705143bf40ea83679fce1" title="Clearing the vector. ">clear()</a> function, the size of the vector is 0. </p>

</div>
</div>
<a class="anchor" id="ac7c63122f66f24dac4661c2a4a9bf802"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a7cc115e50cfa932ecef101f9794f6114">Pointer</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the vector elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage of the hybrid vector. </p>

</div>
</div>
<a class="anchor" id="a8fb115b4d2c351259b0d9d93eb57e8ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac5e4eda754d0cf3f44b760d9d3ad66aa">ConstPointer</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the vector elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage of the hybrid vector. </p>

</div>
</div>
<a class="anchor" id="a1f5f6f2a017ed049bba9c854e69cce6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a23cc8279d4ccf1d0ef137487d7157109">Iterator</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the hybrid vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the hybrid vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b61f93ba3273d756c35f54d2d72f9ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#ac7640be6ec4dd0f7c9c5461c6e452113">ConstIterator</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the hybrid vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the hybrid vector. </dd></dl>

</div>
</div>
<a class="anchor" id="adb50c3ae2dfe4b65e02b50e1302ae76b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extending the size of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of additional vector elements. </td></tr>
    <tr><td class="paramname">preserve</td><td><em>true</em> if the old values of the vector should be preserved, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function increases the vector size by <em>n</em> elements. In case the resulting size of the vector is larger than the maximum number of vector elements (i.e. if n &gt; N) a <em>std::invalid_argument</em> exception is thrown. During this operation, all vector elements are potentially changed. In order to preserve the old vector values, the <em>preserve</em> flag can be set to <em>true</em>.<br />
Note that new vector elements are not initialized! </p>

</div>
</div>
<a class="anchor" id="ade6af292c31d02ad4b7d80b9812c0501"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector is aliased with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this vector, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address is aliased with the vector. In contrast to the <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a3b8662a2e1c8e1970a3886ddf24d41da" title="Returns whether the vector can alias with the given address alias. ">canAlias()</a> function this function is not allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="ac8e769edbdf1453c88e2f80d74a6cfaa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::isAligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector is properly aligned in memory. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the vector is aligned, <em>false</em> if not.</dd></dl>
<p>This function returns whether the vector is guaranteed to be properly aligned in memory, i.e. whether the beginning and the end of the vector are guaranteed to conform to the alignment restrictions of the element type <em>Type</em>. </p>

</div>
</div>
<a class="anchor" id="aedc7bae6f409f474f247228a076dfa8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a327777ee9e75205f87cb162d1efcc7bf">IntrinsicType</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned load of an intrinsic element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded intrinsic element.</dd></dl>
<p>This function performs an aligned load of a specific intrinsic element of the dense vector. The index must be smaller than the number of vector elements and it must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a48bb160d223a935f1ab3c9ddd7173531"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a327777ee9e75205f87cb162d1efcc7bf">IntrinsicType</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::loadu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unaligned load of an intrinsic element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded intrinsic element.</dd></dl>
<p>This function performs an unaligned load of a specific intrinsic element of the dense vector. The index must be smaller than the number of vector elements and it must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a2164c508b5f5a5bcfa7dbf1ecad88a24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the multiplication assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a2597a453d1c56906fd403d11899b011b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the multiplication assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a6bf8b7e0741510f9063779ca4993fff1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the multiplication assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a0a78b6f023e67c048b111bed7ea49bd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the vector.</dd></dl>
<p>Note that the number of non-zero elements is always less than or equal to the current size of the vector. </p>

</div>
</div>
<a class="anchor" id="a7b5898c85476f93a4795630b8369cc74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class specific implementation of operator delete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory to be deallocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a59b6a23e99873bf73eef651ef776a3dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nothrow_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class specific implementation of no-throw operator delete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory to be deallocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a583c20c26b9fd48bff0d19750fe6fc3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class specific implementation of operator delete[]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory to be deallocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="aa8375ebfbfe7d240463340c1a6f464a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nothrow_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class specific implementation of no-throw operator delete[]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory to be deallocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a5f2b48817e2330a92d7d8cd9aa8f2ef7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class specific implementation of operator new. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The total number of bytes to be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly allocated memory. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Allocation failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This class-specific implementation of operator new provides the functionality to allocate dynamic memory based on the alignment restrictions of the <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a> class template. </p>

</div>
</div>
<a class="anchor" id="af0c1527b4f39635e57223719f71de141"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nothrow_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class specific implementation of the no-throw operator new. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The total number of bytes to be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly allocated memory. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Allocation failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This class-specific implementation of operator new provides the functionality to allocate dynamic memory based on the alignment restrictions of the <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a> class template. </p>

</div>
</div>
<a class="anchor" id="ac8ccbea4403baff7c79d9d5d35b8fce3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class specific implementation of operator new[]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The total number of bytes to be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly allocated memory. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Allocation failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This class-specific implementation of operator new provides the functionality to allocate dynamic memory based on the alignment restrictions of the <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a> class template. </p>

</div>
</div>
<a class="anchor" id="a450d2faa792664f31ad22006976eb76e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator new[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nothrow_t &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class specific implementation of the no-throw operator new[]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The total number of bytes to be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly allocated memory. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>Allocation failed.</td></tr>
  </table>
  </dd>
</dl>
<p>This class-specific implementation of operator new provides the functionality to allocate dynamic memory based on the alignment restrictions of the <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a> class template. </p>

</div>
</div>
<a class="anchor" id="a29aa44cf5eb106c0f7daa853eda74a07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt;&amp; <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}*=\vec{b} $" src="../../form_68.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be multiplied with the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a0439bb1387716bc63f31756e49038aba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt; &gt;::Type&amp; <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication between a vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_69.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a39d59282c9e3be6187a9ce909f2f2ade"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt;&amp; <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator for the addition of a vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_66.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be added to the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a83fcdcfa61a1065812553cc4a04ae919"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt;&amp; <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator for the subtraction of a vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_67.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be subtracted from the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="af565e8766f0c5b2c49ef1e2ec96a1d63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt; &gt;::Type&amp; <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator for the division of a vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_70.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector.</dd></dl>
<p><b>Note:</b> A division by zero is only checked by an user assert. </p>

</div>
</div>
<a class="anchor" id="a53d3fd8f1433b33fffec97837bbb5c9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp; <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Homogenous assignment to all vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Scalar value to be assigned to all vector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned vector. </dd></dl>

</div>
</div>
<a class="anchor" id="af95282456fe92fb23c8fdc3da71ed583"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp; <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator for <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html" title="Efficient implementation of a dynamically sized vector with static memory.The HybridVector class temp...">HybridVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned vector.</dd></dl>
<p>Explicit definition of a copy assignment operator for performance reasons. </p>

</div>
</div>
<a class="anchor" id="a98371f4fbaf0d0b4a5a3473b5e349b06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename Other , size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt;&amp; <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Other(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[M]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array assignment to all vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>M-dimensional array for the assignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned vector.</dd></dl>
<p>This assignment operator offers the option to directly set all elements of the vector:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> init[2] = { 1.0, 2.0 };</div>
<div class="line"><a class="code" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector&lt;double,4&gt;</a> v;</div>
<div class="line">v = init;</div>
</div><!-- fragment --><p>The vector is sized according to the size of the array and assigned the values of the given array. This assignment operator only works for arrays with a size smaller-or-equal than the maximum number of elements of the hybrid vector. (i.e. M&lt;= N). The attempt to use a larger array will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="a40ad24bd8c318a75df6ada9b1e8b4800"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt;&amp; <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for different vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to hybrid vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor initializes the vector as a copy of the given vector. In case the size of the given vector is larger than N, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="abf53db2ffda6a38339962130b2700648"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a91a2e935ae43abf2ed5e4518161d49cf">Reference</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value.</dd></dl>
<p>In case <a class="el" href="../../d5/d55/group__runtime__assert.html#gaa5c500374d63f8eece0a87b1ce8bc5df" title="Run time assertion macro for user checks.In case of an invalid run time expression, the program execution is terminated. The BLAZE_USER_ASSERT macro can be disabled by setting the BLAZE_USER_ASSERT flag to zero or by defining NDEBUG during the compilation. ">BLAZE_USER_ASSERT()</a> is active, this operator performs an index check. </p>

</div>
</div>
<a class="anchor" id="a23f5cf0381ae6533c8e91db5b4736223"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt;::<a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a11950c312cbb5d8bb9d0a88d58c52ddc">ConstReference</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference-to-const to the accessed value.</dd></dl>
<p>In case <a class="el" href="../../d5/d55/group__runtime__assert.html#gaa5c500374d63f8eece0a87b1ce8bc5df" title="Run time assertion macro for user checks.In case of an invalid run time expression, the program execution is terminated. The BLAZE_USER_ASSERT macro can be disabled by setting the BLAZE_USER_ASSERT flag to zero or by defining NDEBUG during the compilation. ">BLAZE_USER_ASSERT()</a> is active, this operator performs an index check. </p>

</div>
</div>
<a class="anchor" id="a1be3095780509ea4b0c421bdb15920a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; VT, TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for non-constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ae37bee20b660eacfcb7a942dc9cdbe19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; VT, TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c9f7cc1834c80547fbbb5bf69cda24e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to the default initial values. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a6acfa247b976e06b8a5fa7925d0cac39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changing the size of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The new size of the vector. </td></tr>
    <tr><td class="paramname">preserve</td><td><em>true</em> if the old values of the vector should be preserved, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid size for hybrid vector.</td></tr>
  </table>
  </dd>
</dl>
<p>This function resizes the vector to the given size <em>n</em>. In case the given size <em>n</em> is larger than the maximum number of vector elements (i.e. if n &gt; N) a <em>std::invalid_argument</em> exception is thrown. Note that this function may invalidate all existing views (subvectors, ...) on the vector if it used to shrink the vector. Additionally, during this operation all vector elements are potentially changed. In order to preserve the old vector values, the <em>preserve</em> flag can be set to <em>true</em>.</p>
<p>Note that in case the size of the vector is increased new vector elements are not initialized! This is illustrated by the following example, which demonstrates the resizing of a vector of size 2 to a vector of size 4. The new, uninitialized elements are marked with <em>x:</em> </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left(\begin{array}{*{2}{c}} 1 &amp; 2 \\ \end{array}\right) \Longrightarrow \left(\begin{array}{*{4}{c}} 1 &amp; 2 &amp; x &amp; x \\ \end{array}\right) \]" src="../../form_71.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="a30191eaf247d21a692819f6c103bd698"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt;&amp; <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scaling of the vector by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_69.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value for the vector scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a1184712be187f087362abe3bf5c313af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current size/dimension of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a0eedfb5536c2198b237287df783c8839"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a327777ee9e75205f87cb162d1efcc7bf">IntrinsicType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned store of an intrinsic element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
    <tr><td class="paramname">value</td><td>The intrinsic element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an aligned store of a specific intrinsic element of the dense vector. The index must be smaller than the number of vector elements and it must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a7ee093e28f8dce58385717d1cbec8351"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::storeu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a327777ee9e75205f87cb162d1efcc7bf">IntrinsicType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unaligned store of an intrinsic element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
    <tr><td class="paramname">value</td><td>The intrinsic element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an unaligned store of a specific intrinsic element of the dense vector. The index must be smaller than the number of vector elements and it must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="ab4cdb55836d512eb4df1e643f82d8405"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html#a327777ee9e75205f87cb162d1efcc7bf">IntrinsicType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned, non-temporal store of an intrinsic element of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of vector elements. </td></tr>
    <tr><td class="paramname">value</td><td>The intrinsic element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an aligned, non-temporal store of a specific intrinsic element of the dense vector. The index must be smaller than the number of vector elements and it must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a3d8f26a9367ffa8aeb46c80c18b15e7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ad84cf74638c7d1f32253766eff36c4dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="aa4aad1557a17892be6eda3894915a6d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt;Type,N,TF&gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the subtraction assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a035b7a7ccf3e6bcce766107c1cab631b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , size_t N, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">HybridVector</a>&lt; Type, N, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two hybrid vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">no-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a6758d32ef718463ddbfcde831d6538fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, size_t N, bool TF = defaultTransposeFlag&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d25/classblaze_1_1AlignedArray.html">AlignedArray</a>&lt;Type,NN&gt; <a class="el" href="../../da/d6b/classblaze_1_1HybridVector.html">blaze::HybridVector</a>&lt; Type, N, TF &gt;::v_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The statically allocated vector elements. </p>
<p>Access to the vector values is gained via the subscript operator. The order of the elements is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{4}{c}} 0 &amp; 1 &amp; \cdots &amp; N-1 \\ \end{array}\right)\]" src="../../form_73.png"/>
</p>
 
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>blaze/math/dense/<a class="el" href="../../d7/df7/dense_2Forward_8h_source.html">Forward.h</a></li>
<li>blaze/math/dense/<a class="el" href="../../d7/dba/dense_2HybridVector_8h_source.html">HybridVector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:55:25 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
