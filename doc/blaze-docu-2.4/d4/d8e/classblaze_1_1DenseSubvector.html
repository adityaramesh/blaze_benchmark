<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>blaze::DenseSubvector&lt; VT, AF, TF &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="../../dc/d02/classblaze_1_1DenseSubvector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::DenseSubvector&lt; VT, AF, TF &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../d0/d48/group__views.html">Views</a> &raquo; <a class="el" href="../../de/d5c/group__dense__subvector.html">Dense Subvector</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> on a specific subvector of a dense vector.The <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html" title="View on a specific subvector of a dense vector.The DenseSubvector template represents a view on a spe...">DenseSubvector</a> template represents a view on a specific subvector of a dense vector primitive. The type of the dense vector is specified via the first template parameter:  
 <a href="../../d4/d8e/classblaze_1_1DenseSubvector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d8/d61/views_2DenseSubvector_8h_source.html">DenseSubvector.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">blaze::DenseVector&lt; DenseSubvector&lt; VT, AF, TF &gt;, TF &gt;</a>, and <a class="el" href="../../d6/d66/structblaze_1_1Subvector.html">blaze::Subvector</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da9/classblaze_1_1DenseSubvector_1_1SubvectorIterator.html">SubvectorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the elements of the sparse subvector.  <a href="../../d0/da9/classblaze_1_1DenseSubvector_1_1SubvectorIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ga399501e1211c680de577a9da8ccbbe0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga399501e1211c680de577a9da8ccbbe0f"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>vectorizable</b> = VT::vectorizable
 }</td></tr>
<tr class="memdesc:ga399501e1211c680de577a9da8ccbbe0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the expression template evaluation strategy. <br /></td></tr>
<tr class="separator:ga399501e1211c680de577a9da8ccbbe0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2a5b318258710d7f7d1751b0c03d0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf2a5b318258710d7f7d1751b0c03d0f"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>smpAssignable</b> = VT::smpAssignable
 }</td></tr>
<tr class="memdesc:gadf2a5b318258710d7f7d1751b0c03d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the expression template assignment strategy. <br /></td></tr>
<tr class="separator:gadf2a5b318258710d7f7d1751b0c03d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134162883e1befb6bbcb859ef928978a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a134162883e1befb6bbcb859ef928978a"></a>
typedef <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a134162883e1befb6bbcb859ef928978a">This</a></td></tr>
<tr class="memdesc:a134162883e1befb6bbcb859ef928978a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html" title="View on a specific subvector of a dense vector.The DenseSubvector template represents a view on a spe...">DenseSubvector</a> instance. <br /></td></tr>
<tr class="separator:a134162883e1befb6bbcb859ef928978a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0577027ef8cd20f64fbf7ec98f2bf159"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0577027ef8cd20f64fbf7ec98f2bf159"></a>
typedef <a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html">SubvectorTrait</a>&lt; VT &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a0577027ef8cd20f64fbf7ec98f2bf159">ResultType</a></td></tr>
<tr class="memdesc:a0577027ef8cd20f64fbf7ec98f2bf159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br /></td></tr>
<tr class="separator:a0577027ef8cd20f64fbf7ec98f2bf159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e8da6bfba0106a7be27e12546871f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12e8da6bfba0106a7be27e12546871f0"></a>
typedef <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html#a02b3d3c589c780c2abaa5275b79b88ba">ResultType::TransposeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a12e8da6bfba0106a7be27e12546871f0">TransposeType</a></td></tr>
<tr class="memdesc:a12e8da6bfba0106a7be27e12546871f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br /></td></tr>
<tr class="separator:a12e8da6bfba0106a7be27e12546871f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cb447a35a3ac2d4f57ec991da98f00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70cb447a35a3ac2d4f57ec991da98f00"></a>
typedef VT::ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a70cb447a35a3ac2d4f57ec991da98f00">ElementType</a></td></tr>
<tr class="memdesc:a70cb447a35a3ac2d4f57ec991da98f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the subvector elements. <br /></td></tr>
<tr class="separator:a70cb447a35a3ac2d4f57ec991da98f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0faadb521d30e134f69f53a80510fbe6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0faadb521d30e134f69f53a80510fbe6"></a>
typedef IT::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a0faadb521d30e134f69f53a80510fbe6">IntrinsicType</a></td></tr>
<tr class="memdesc:a0faadb521d30e134f69f53a80510fbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic type of the subvector elements. <br /></td></tr>
<tr class="separator:a0faadb521d30e134f69f53a80510fbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9436e2d68c291d8f34839d1eb32cd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac9436e2d68c291d8f34839d1eb32cd4"></a>
typedef VT::ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#aac9436e2d68c291d8f34839d1eb32cd4">ReturnType</a></td></tr>
<tr class="memdesc:aac9436e2d68c291d8f34839d1eb32cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br /></td></tr>
<tr class="separator:aac9436e2d68c291d8f34839d1eb32cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924afdb18f1d3261f98461184c53aa5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a924afdb18f1d3261f98461184c53aa5b"></a>
typedef const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a924afdb18f1d3261f98461184c53aa5b">CompositeType</a></td></tr>
<tr class="memdesc:a924afdb18f1d3261f98461184c53aa5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br /></td></tr>
<tr class="separator:a924afdb18f1d3261f98461184c53aa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901f249615a4c5a06be3f4260019c473"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a901f249615a4c5a06be3f4260019c473"></a>
typedef VT::ConstReference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a901f249615a4c5a06be3f4260019c473">ConstReference</a></td></tr>
<tr class="memdesc:a901f249615a4c5a06be3f4260019c473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant subvector value. <br /></td></tr>
<tr class="separator:a901f249615a4c5a06be3f4260019c473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5817dac57c274026a8b0e2b7562dcc70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5817dac57c274026a8b0e2b7562dcc70"></a>
typedef <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; useConst, <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a901f249615a4c5a06be3f4260019c473">ConstReference</a>, typename VT::Reference &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a5817dac57c274026a8b0e2b7562dcc70">Reference</a></td></tr>
<tr class="memdesc:a5817dac57c274026a8b0e2b7562dcc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant subvector value. <br /></td></tr>
<tr class="separator:a5817dac57c274026a8b0e2b7562dcc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5223713174379fb540166e5c8145e08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5223713174379fb540166e5c8145e08"></a>
typedef const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a70cb447a35a3ac2d4f57ec991da98f00">ElementType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#af5223713174379fb540166e5c8145e08">ConstPointer</a></td></tr>
<tr class="memdesc:af5223713174379fb540166e5c8145e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a constant subvector value. <br /></td></tr>
<tr class="separator:af5223713174379fb540166e5c8145e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ad203bfe87fa86dcec51f2021b2a09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99ad203bfe87fa86dcec51f2021b2a09"></a>
typedef <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; useConst, <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#af5223713174379fb540166e5c8145e08">ConstPointer</a>, <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a70cb447a35a3ac2d4f57ec991da98f00">ElementType</a> * &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a99ad203bfe87fa86dcec51f2021b2a09">Pointer</a></td></tr>
<tr class="memdesc:a99ad203bfe87fa86dcec51f2021b2a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a non-constant subvector value. <br /></td></tr>
<tr class="separator:a99ad203bfe87fa86dcec51f2021b2a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608fa42539fe7cde45d6e6fd206d4dc5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a608fa42539fe7cde45d6e6fd206d4dc5"></a>
typedef <a class="el" href="../../d0/da9/classblaze_1_1DenseSubvector_1_1SubvectorIterator.html">SubvectorIterator</a>&lt; typename VT::ConstIterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a608fa42539fe7cde45d6e6fd206d4dc5">ConstIterator</a></td></tr>
<tr class="memdesc:a608fa42539fe7cde45d6e6fd206d4dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br /></td></tr>
<tr class="separator:a608fa42539fe7cde45d6e6fd206d4dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1673aa20dcadca9606ef19bea0f04b3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1673aa20dcadca9606ef19bea0f04b3d"></a>
typedef <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; useConst, <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a608fa42539fe7cde45d6e6fd206d4dc5">ConstIterator</a>, <a class="el" href="../../d0/da9/classblaze_1_1DenseSubvector_1_1SubvectorIterator.html">SubvectorIterator</a>&lt; typename VT::Iterator &gt; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a1673aa20dcadca9606ef19bea0f04b3d">Iterator</a></td></tr>
<tr class="memdesc:a1673aa20dcadca9606ef19bea0f04b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br /></td></tr>
<tr class="separator:a1673aa20dcadca9606ef19bea0f04b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe7ddefcf2554b0bced1ad1b4b53e24"></a>
typedef VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a></td></tr>
<tr class="memdesc:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the vector. <br /></td></tr>
<tr class="separator:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7eedb1c1c3d19a05c765d3e3fd34c929"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a7eedb1c1c3d19a05c765d3e3fd34c929"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a7eedb1c1c3d19a05c765d3e3fd34c929">operator=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7eedb1c1c3d19a05c765d3e3fd34c929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for different vectors.  <a href="#a7eedb1c1c3d19a05c765d3e3fd34c929">More...</a><br /></td></tr>
<tr class="separator:a7eedb1c1c3d19a05c765d3e3fd34c929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4342d2b0fb0ab36aecd3de804e6df07b"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a4342d2b0fb0ab36aecd3de804e6df07b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a4342d2b0fb0ab36aecd3de804e6df07b">operator+=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4342d2b0fb0ab36aecd3de804e6df07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator for the addition of a vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_66.png"/>).  <a href="#a4342d2b0fb0ab36aecd3de804e6df07b">More...</a><br /></td></tr>
<tr class="separator:a4342d2b0fb0ab36aecd3de804e6df07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef2bf2e243e616e9928dd83c5e96e3b"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a4ef2bf2e243e616e9928dd83c5e96e3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a4ef2bf2e243e616e9928dd83c5e96e3b">operator-=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4ef2bf2e243e616e9928dd83c5e96e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator for the subtraction of a vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_67.png"/>).  <a href="#a4ef2bf2e243e616e9928dd83c5e96e3b">More...</a><br /></td></tr>
<tr class="separator:a4ef2bf2e243e616e9928dd83c5e96e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e0ae2f4a8a177477b8ad9f5db53051"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ab8e0ae2f4a8a177477b8ad9f5db53051"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#ab8e0ae2f4a8a177477b8ad9f5db53051">operator*=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab8e0ae2f4a8a177477b8ad9f5db53051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}*=\vec{b} $" src="../../form_68.png"/>).  <a href="#ab8e0ae2f4a8a177477b8ad9f5db53051">More...</a><br /></td></tr>
<tr class="separator:ab8e0ae2f4a8a177477b8ad9f5db53051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40111b5e961e141ad56566d601d2a014"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a40111b5e961e141ad56566d601d2a014"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a40111b5e961e141ad56566d601d2a014">operator*=</a> (Other rhs)</td></tr>
<tr class="memdesc:a40111b5e961e141ad56566d601d2a014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication between a subvector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_69.png"/>).  <a href="#a40111b5e961e141ad56566d601d2a014">More...</a><br /></td></tr>
<tr class="separator:a40111b5e961e141ad56566d601d2a014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b1bec70cb5cf7a88a8bc868975d45d"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a37b1bec70cb5cf7a88a8bc868975d45d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a37b1bec70cb5cf7a88a8bc868975d45d">operator/=</a> (Other rhs)</td></tr>
<tr class="memdesc:a37b1bec70cb5cf7a88a8bc868975d45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator for the division of a subvector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_70.png"/>).  <a href="#a37b1bec70cb5cf7a88a8bc868975d45d">More...</a><br /></td></tr>
<tr class="separator:a37b1bec70cb5cf7a88a8bc868975d45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8393e1a571d8913dec34c7b35b54d958"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a8393e1a571d8913dec34c7b35b54d958"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a8393e1a571d8913dec34c7b35b54d958">scale</a> (const Other &amp;scalar)</td></tr>
<tr class="memdesc:a8393e1a571d8913dec34c7b35b54d958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of the dense subvector by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_72.png"/>).  <a href="#a8393e1a571d8913dec34c7b35b54d958">More...</a><br /></td></tr>
<tr class="separator:a8393e1a571d8913dec34c7b35b54d958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d495c3ea598a8d4d74b9b7e833c8d20"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a1d495c3ea598a8d4d74b9b7e833c8d20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a1d495c3ea598a8d4d74b9b7e833c8d20">assign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1d495c3ea598a8d4d74b9b7e833c8d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a dense vector.  <a href="#a1d495c3ea598a8d4d74b9b7e833c8d20">More...</a><br /></td></tr>
<tr class="separator:a1d495c3ea598a8d4d74b9b7e833c8d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b3340f4c2f915c2b34e975a623419e"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a09b3340f4c2f915c2b34e975a623419e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a09b3340f4c2f915c2b34e975a623419e">assign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a09b3340f4c2f915c2b34e975a623419e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the assignment of a dense vector.  <a href="#a09b3340f4c2f915c2b34e975a623419e">More...</a><br /></td></tr>
<tr class="separator:a09b3340f4c2f915c2b34e975a623419e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dec88ccb4fb619bba399af26a67684"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:af6dec88ccb4fb619bba399af26a67684"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#af6dec88ccb4fb619bba399af26a67684">addAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af6dec88ccb4fb619bba399af26a67684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a dense vector.  <a href="#af6dec88ccb4fb619bba399af26a67684">More...</a><br /></td></tr>
<tr class="separator:af6dec88ccb4fb619bba399af26a67684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618a4bb1dd3cb49010eb5c072c31578a"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a618a4bb1dd3cb49010eb5c072c31578a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a618a4bb1dd3cb49010eb5c072c31578a">addAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a618a4bb1dd3cb49010eb5c072c31578a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the addition assignment of a dense vector.  <a href="#a618a4bb1dd3cb49010eb5c072c31578a">More...</a><br /></td></tr>
<tr class="separator:a618a4bb1dd3cb49010eb5c072c31578a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace277472a287f733b2cf4e56da5ed8a7"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ace277472a287f733b2cf4e56da5ed8a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#ace277472a287f733b2cf4e56da5ed8a7">subAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ace277472a287f733b2cf4e56da5ed8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a dense vector.  <a href="#ace277472a287f733b2cf4e56da5ed8a7">More...</a><br /></td></tr>
<tr class="separator:ace277472a287f733b2cf4e56da5ed8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46becd941e3dcb89a86af050ce9f2ca7"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a46becd941e3dcb89a86af050ce9f2ca7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a46becd941e3dcb89a86af050ce9f2ca7">subAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a46becd941e3dcb89a86af050ce9f2ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the subtraction assignment of a dense vector.  <a href="#a46becd941e3dcb89a86af050ce9f2ca7">More...</a><br /></td></tr>
<tr class="separator:a46becd941e3dcb89a86af050ce9f2ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fc393c6379594a846690e966b4dd8d"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ae3fc393c6379594a846690e966b4dd8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#ae3fc393c6379594a846690e966b4dd8d">multAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae3fc393c6379594a846690e966b4dd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the multiplication assignment of a dense vector.  <a href="#ae3fc393c6379594a846690e966b4dd8d">More...</a><br /></td></tr>
<tr class="separator:ae3fc393c6379594a846690e966b4dd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa3189466a3dab83d7291ee3bb0e43f"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a2fa3189466a3dab83d7291ee3bb0e43f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a2fa3189466a3dab83d7291ee3bb0e43f">multAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2fa3189466a3dab83d7291ee3bb0e43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the multiplication assignment of a dense vector.  <a href="#a2fa3189466a3dab83d7291ee3bb0e43f">More...</a><br /></td></tr>
<tr class="separator:a2fa3189466a3dab83d7291ee3bb0e43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be3095780509ea4b0c421bdb15920a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a1be3095780509ea4b0c421bdb15920a0">operator~</a> ()</td></tr>
<tr class="memdesc:a1be3095780509ea4b0c421bdb15920a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for non-constant vectors.  <a href="#a1be3095780509ea4b0c421bdb15920a0">More...</a><br /></td></tr>
<tr class="separator:a1be3095780509ea4b0c421bdb15920a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37bee20b660eacfcb7a942dc9cdbe19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#ae37bee20b660eacfcb7a942dc9cdbe19">operator~</a> () const </td></tr>
<tr class="memdesc:ae37bee20b660eacfcb7a942dc9cdbe19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for constant vectors.  <a href="#ae37bee20b660eacfcb7a942dc9cdbe19">More...</a><br /></td></tr>
<tr class="separator:ae37bee20b660eacfcb7a942dc9cdbe19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a907d7589502f0b5e5ffc7d3f9434b712"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a907d7589502f0b5e5ffc7d3f9434b712">DenseSubvector</a> (<a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#aafb07984d43864c643c68e86b3a1c10c">Operand</a> vector, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:a907d7589502f0b5e5ffc7d3f9434b712"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor for <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html" title="View on a specific subvector of a dense vector.The DenseSubvector template represents a view on a spe...">DenseSubvector</a>.  <a href="#a907d7589502f0b5e5ffc7d3f9434b712">More...</a><br /></td></tr>
<tr class="separator:a907d7589502f0b5e5ffc7d3f9434b712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access functions</div></td></tr>
<tr class="memitem:a8b599ae06703d804fd0df3a4947b25a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a5817dac57c274026a8b0e2b7562dcc70">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a8b599ae06703d804fd0df3a4947b25a3">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:a8b599ae06703d804fd0df3a4947b25a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the subvector elements.  <a href="#a8b599ae06703d804fd0df3a4947b25a3">More...</a><br /></td></tr>
<tr class="separator:a8b599ae06703d804fd0df3a4947b25a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fb24203f8745ca791c5fc98d53763f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a901f249615a4c5a06be3f4260019c473">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a39fb24203f8745ca791c5fc98d53763f">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:a39fb24203f8745ca791c5fc98d53763f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the subvector elements.  <a href="#a39fb24203f8745ca791c5fc98d53763f">More...</a><br /></td></tr>
<tr class="separator:a39fb24203f8745ca791c5fc98d53763f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2c58f6445d7bee96481b320821a39f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a99ad203bfe87fa86dcec51f2021b2a09">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a0b2c58f6445d7bee96481b320821a39f">data</a> ()</td></tr>
<tr class="memdesc:a0b2c58f6445d7bee96481b320821a39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the subvector elements.  <a href="#a0b2c58f6445d7bee96481b320821a39f">More...</a><br /></td></tr>
<tr class="separator:a0b2c58f6445d7bee96481b320821a39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed3617c7a639cb2db5c14708243d87b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#af5223713174379fb540166e5c8145e08">ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a3ed3617c7a639cb2db5c14708243d87b">data</a> () const </td></tr>
<tr class="memdesc:a3ed3617c7a639cb2db5c14708243d87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the subvector elements.  <a href="#a3ed3617c7a639cb2db5c14708243d87b">More...</a><br /></td></tr>
<tr class="separator:a3ed3617c7a639cb2db5c14708243d87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8883b44aa6d6127cee162bf8fdbdd1de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a1673aa20dcadca9606ef19bea0f04b3d">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a8883b44aa6d6127cee162bf8fdbdd1de">begin</a> ()</td></tr>
<tr class="memdesc:a8883b44aa6d6127cee162bf8fdbdd1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the subvector.  <a href="#a8883b44aa6d6127cee162bf8fdbdd1de">More...</a><br /></td></tr>
<tr class="separator:a8883b44aa6d6127cee162bf8fdbdd1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7413ba4ca28c2dbf44e14574341dabe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a608fa42539fe7cde45d6e6fd206d4dc5">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a7413ba4ca28c2dbf44e14574341dabe8">begin</a> () const </td></tr>
<tr class="memdesc:a7413ba4ca28c2dbf44e14574341dabe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the subvector.  <a href="#a7413ba4ca28c2dbf44e14574341dabe8">More...</a><br /></td></tr>
<tr class="separator:a7413ba4ca28c2dbf44e14574341dabe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2f48fbb75f153ee90661b7581fae49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a608fa42539fe7cde45d6e6fd206d4dc5">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a8e2f48fbb75f153ee90661b7581fae49">cbegin</a> () const </td></tr>
<tr class="memdesc:a8e2f48fbb75f153ee90661b7581fae49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the subvector.  <a href="#a8e2f48fbb75f153ee90661b7581fae49">More...</a><br /></td></tr>
<tr class="separator:a8e2f48fbb75f153ee90661b7581fae49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9d23f09053778f09e6c0d26939aae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a1673aa20dcadca9606ef19bea0f04b3d">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#add9d23f09053778f09e6c0d26939aae8">end</a> ()</td></tr>
<tr class="memdesc:add9d23f09053778f09e6c0d26939aae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the subvector.  <a href="#add9d23f09053778f09e6c0d26939aae8">More...</a><br /></td></tr>
<tr class="separator:add9d23f09053778f09e6c0d26939aae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6791af34aeeddbb411eeef8e8b730e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a608fa42539fe7cde45d6e6fd206d4dc5">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#ad6791af34aeeddbb411eeef8e8b730e6">end</a> () const </td></tr>
<tr class="memdesc:ad6791af34aeeddbb411eeef8e8b730e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the subvector.  <a href="#ad6791af34aeeddbb411eeef8e8b730e6">More...</a><br /></td></tr>
<tr class="separator:ad6791af34aeeddbb411eeef8e8b730e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618d1d0dbee52eb569ff5b5cd797c503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a608fa42539fe7cde45d6e6fd206d4dc5">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a618d1d0dbee52eb569ff5b5cd797c503">cend</a> () const </td></tr>
<tr class="memdesc:a618d1d0dbee52eb569ff5b5cd797c503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the subvector.  <a href="#a618d1d0dbee52eb569ff5b5cd797c503">More...</a><br /></td></tr>
<tr class="separator:a618d1d0dbee52eb569ff5b5cd797c503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment operators</div></td></tr>
<tr class="memitem:a6bd409c3f97b3a8c142aca9ddd62a88d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a6bd409c3f97b3a8c142aca9ddd62a88d">operator=</a> (const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a70cb447a35a3ac2d4f57ec991da98f00">ElementType</a> &amp;rhs)</td></tr>
<tr class="memdesc:a6bd409c3f97b3a8c142aca9ddd62a88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Homogenous assignment to all subvector elements.  <a href="#a6bd409c3f97b3a8c142aca9ddd62a88d">More...</a><br /></td></tr>
<tr class="separator:a6bd409c3f97b3a8c142aca9ddd62a88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e17eb6c53dbb99dd3b3677f6f70d88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#aa5e17eb6c53dbb99dd3b3677f6f70d88">operator=</a> (const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a> &amp;rhs)</td></tr>
<tr class="memdesc:aa5e17eb6c53dbb99dd3b3677f6f70d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html" title="View on a specific subvector of a dense vector.The DenseSubvector template represents a view on a spe...">DenseSubvector</a>.  <a href="#aa5e17eb6c53dbb99dd3b3677f6f70d88">More...</a><br /></td></tr>
<tr class="separator:aa5e17eb6c53dbb99dd3b3677f6f70d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39daca5742cdd4bda81b952731988ca5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a39daca5742cdd4bda81b952731988ca5"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a39daca5742cdd4bda81b952731988ca5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a39daca5742cdd4bda81b952731988ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2101893dd0b5258660302076b4b1d5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c2101893dd0b5258660302076b4b1d5"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a3c2101893dd0b5258660302076b4b1d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a3c2101893dd0b5258660302076b4b1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc084c752b17093f1e0992af7ef2d69f"><td class="memTemplParams" colspan="2"><a class="anchor" id="afc084c752b17093f1e0992af7ef2d69f"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:afc084c752b17093f1e0992af7ef2d69f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:afc084c752b17093f1e0992af7ef2d69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a41fda4e3f85354463b0d1bed73869"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa1a41fda4e3f85354463b0d1bed73869"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:aa1a41fda4e3f85354463b0d1bed73869"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:aa1a41fda4e3f85354463b0d1bed73869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b7707bdc8ef9e72fbb6c0e16f162a7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab4b7707bdc8ef9e72fbb6c0e16f162a7"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ab4b7707bdc8ef9e72fbb6c0e16f162a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (Other rhs)</td></tr>
<tr class="separator:ab4b7707bdc8ef9e72fbb6c0e16f162a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66007df6778a4d7795815ce1fc6ff8d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab66007df6778a4d7795815ce1fc6ff8d"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ab66007df6778a4d7795815ce1fc6ff8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (Other rhs)</td></tr>
<tr class="separator:ab66007df6778a4d7795815ce1fc6ff8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility functions</div></td></tr>
<tr class="memitem:a711fce22dfe288fe434a0a5d5994af6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a711fce22dfe288fe434a0a5d5994af6a">size</a> () const </td></tr>
<tr class="memdesc:a711fce22dfe288fe434a0a5d5994af6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size/dimension of the dense subvector.  <a href="#a711fce22dfe288fe434a0a5d5994af6a">More...</a><br /></td></tr>
<tr class="separator:a711fce22dfe288fe434a0a5d5994af6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524f33e37d0be52b903b35f8453ec880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a524f33e37d0be52b903b35f8453ec880">capacity</a> () const </td></tr>
<tr class="memdesc:a524f33e37d0be52b903b35f8453ec880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the dense subvector.  <a href="#a524f33e37d0be52b903b35f8453ec880">More...</a><br /></td></tr>
<tr class="separator:a524f33e37d0be52b903b35f8453ec880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de961cfa9264817c94770df76405013"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a4de961cfa9264817c94770df76405013">nonZeros</a> () const </td></tr>
<tr class="memdesc:a4de961cfa9264817c94770df76405013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the subvector.  <a href="#a4de961cfa9264817c94770df76405013">More...</a><br /></td></tr>
<tr class="separator:a4de961cfa9264817c94770df76405013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00ed48979f5f5afcfac27a15ec1046c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#af00ed48979f5f5afcfac27a15ec1046c">reset</a> ()</td></tr>
<tr class="memdesc:af00ed48979f5f5afcfac27a15ec1046c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to the default initial values.  <a href="#af00ed48979f5f5afcfac27a15ec1046c">More...</a><br /></td></tr>
<tr class="separator:af00ed48979f5f5afcfac27a15ec1046c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea3720922b9c681febe85700ee56d26"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9ea3720922b9c681febe85700ee56d26"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a9ea3720922b9c681febe85700ee56d26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scale</b> (const Other &amp;scalar)</td></tr>
<tr class="separator:a9ea3720922b9c681febe85700ee56d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression template evaluation functions</div></td></tr>
<tr class="memitem:a5461f87a2f7e4e192473525790aa89b0"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a5461f87a2f7e4e192473525790aa89b0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a5461f87a2f7e4e192473525790aa89b0">canAlias</a> (const Other *alias) const </td></tr>
<tr class="memdesc:a5461f87a2f7e4e192473525790aa89b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the dense subvector can alias with the given address <em>alias</em>.  <a href="#a5461f87a2f7e4e192473525790aa89b0">More...</a><br /></td></tr>
<tr class="separator:a5461f87a2f7e4e192473525790aa89b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d76f4ac58b524cdfb48d71b03497ff"><td class="memTemplParams" colspan="2">template&lt;typename VT2 , bool AF2, bool TF2&gt; </td></tr>
<tr class="memitem:a33d76f4ac58b524cdfb48d71b03497ff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a33d76f4ac58b524cdfb48d71b03497ff">canAlias</a> (const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT2, AF2, TF2 &gt; *alias) const </td></tr>
<tr class="memdesc:a33d76f4ac58b524cdfb48d71b03497ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the dense subvector can alias with the given dense subvector <em>alias</em>.  <a href="#a33d76f4ac58b524cdfb48d71b03497ff">More...</a><br /></td></tr>
<tr class="separator:a33d76f4ac58b524cdfb48d71b03497ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ff8492b607608048f199d6f57d1f80"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ab1ff8492b607608048f199d6f57d1f80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#ab1ff8492b607608048f199d6f57d1f80">isAliased</a> (const Other *alias) const </td></tr>
<tr class="memdesc:ab1ff8492b607608048f199d6f57d1f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the dense subvector is aliased with the given address <em>alias</em>.  <a href="#ab1ff8492b607608048f199d6f57d1f80">More...</a><br /></td></tr>
<tr class="separator:ab1ff8492b607608048f199d6f57d1f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7977b631ce3e75ac167e639562f4a09"><td class="memTemplParams" colspan="2">template&lt;typename VT2 , bool AF2, bool TF2&gt; </td></tr>
<tr class="memitem:ad7977b631ce3e75ac167e639562f4a09"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#ad7977b631ce3e75ac167e639562f4a09">isAliased</a> (const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT2, AF2, TF2 &gt; *alias) const </td></tr>
<tr class="memdesc:ad7977b631ce3e75ac167e639562f4a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the dense subvector is aliased with the given dense subvector <em>alias</em>.  <a href="#ad7977b631ce3e75ac167e639562f4a09">More...</a><br /></td></tr>
<tr class="separator:ad7977b631ce3e75ac167e639562f4a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f691447328f8ca4f8ba60eb68cc904"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#ab7f691447328f8ca4f8ba60eb68cc904">isAligned</a> () const </td></tr>
<tr class="memdesc:ab7f691447328f8ca4f8ba60eb68cc904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the subvector is properly aligned in memory.  <a href="#ab7f691447328f8ca4f8ba60eb68cc904">More...</a><br /></td></tr>
<tr class="separator:ab7f691447328f8ca4f8ba60eb68cc904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9425bbb0ed4cfea12c7668aa708a92af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a9425bbb0ed4cfea12c7668aa708a92af">canSMPAssign</a> () const </td></tr>
<tr class="memdesc:a9425bbb0ed4cfea12c7668aa708a92af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the subvector can be used in SMP assignments.  <a href="#a9425bbb0ed4cfea12c7668aa708a92af">More...</a><br /></td></tr>
<tr class="separator:a9425bbb0ed4cfea12c7668aa708a92af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec302ccbb1b958f8f187292dbb38fa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a0faadb521d30e134f69f53a80510fbe6">IntrinsicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a0ec302ccbb1b958f8f187292dbb38fa1">load</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:a0ec302ccbb1b958f8f187292dbb38fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned load of an intrinsic element of the dense subvector.  <a href="#a0ec302ccbb1b958f8f187292dbb38fa1">More...</a><br /></td></tr>
<tr class="separator:a0ec302ccbb1b958f8f187292dbb38fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ec4f625cf5c607a6aad705e573bcc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a0faadb521d30e134f69f53a80510fbe6">IntrinsicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a47ec4f625cf5c607a6aad705e573bcc6">loadu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:a47ec4f625cf5c607a6aad705e573bcc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned load of an intrinsic element of the dense subvector.  <a href="#a47ec4f625cf5c607a6aad705e573bcc6">More...</a><br /></td></tr>
<tr class="separator:a47ec4f625cf5c607a6aad705e573bcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200b706341a6a386d24dae66dede66cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a200b706341a6a386d24dae66dede66cc">store</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a0faadb521d30e134f69f53a80510fbe6">IntrinsicType</a> &amp;value)</td></tr>
<tr class="memdesc:a200b706341a6a386d24dae66dede66cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of an intrinsic element of the subvector.  <a href="#a200b706341a6a386d24dae66dede66cc">More...</a><br /></td></tr>
<tr class="separator:a200b706341a6a386d24dae66dede66cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3fa13681e34a570efe74e0f6854ec0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a0a3fa13681e34a570efe74e0f6854ec0">storeu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a0faadb521d30e134f69f53a80510fbe6">IntrinsicType</a> &amp;value)</td></tr>
<tr class="memdesc:a0a3fa13681e34a570efe74e0f6854ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of an intrinsic element of the subvector.  <a href="#a0a3fa13681e34a570efe74e0f6854ec0">More...</a><br /></td></tr>
<tr class="separator:a0a3fa13681e34a570efe74e0f6854ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1852fe99f351dea26ea7b1d2d0e6a4ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a1852fe99f351dea26ea7b1d2d0e6a4ac">stream</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a0faadb521d30e134f69f53a80510fbe6">IntrinsicType</a> &amp;value)</td></tr>
<tr class="memdesc:a1852fe99f351dea26ea7b1d2d0e6a4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of an intrinsic element of the subvector.  <a href="#a1852fe99f351dea26ea7b1d2d0e6a4ac">More...</a><br /></td></tr>
<tr class="separator:a1852fe99f351dea26ea7b1d2d0e6a4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8344fdcfd065440cb57906a0cc8097c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa8344fdcfd065440cb57906a0cc8097c"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:aa8344fdcfd065440cb57906a0cc8097c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:aa8344fdcfd065440cb57906a0cc8097c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084922aca372ef90499072bf68b8bac7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a084922aca372ef90499072bf68b8bac7"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a084922aca372ef90499072bf68b8bac7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a084922aca372ef90499072bf68b8bac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedd6c77df269f02e6e0ea08123e98fe"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:afedd6c77df269f02e6e0ea08123e98fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#afedd6c77df269f02e6e0ea08123e98fe">assign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:afedd6c77df269f02e6e0ea08123e98fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a sparse vector.  <a href="#afedd6c77df269f02e6e0ea08123e98fe">More...</a><br /></td></tr>
<tr class="separator:afedd6c77df269f02e6e0ea08123e98fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c29879a22e41edf34cb076422b3e692"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9c29879a22e41edf34cb076422b3e692"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a9c29879a22e41edf34cb076422b3e692"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedAddAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a9c29879a22e41edf34cb076422b3e692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58e4e9fe60943df85c8dfc417298848"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac58e4e9fe60943df85c8dfc417298848"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ac58e4e9fe60943df85c8dfc417298848"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedAddAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:ac58e4e9fe60943df85c8dfc417298848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8169bc0c9910a6c9c7e115a19aa9aad0"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a8169bc0c9910a6c9c7e115a19aa9aad0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a8169bc0c9910a6c9c7e115a19aa9aad0">addAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8169bc0c9910a6c9c7e115a19aa9aad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a sparse vector.  <a href="#a8169bc0c9910a6c9c7e115a19aa9aad0">More...</a><br /></td></tr>
<tr class="separator:a8169bc0c9910a6c9c7e115a19aa9aad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f604e6dff06553a29377ca0448f17c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9f604e6dff06553a29377ca0448f17c9"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a9f604e6dff06553a29377ca0448f17c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedSubAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a9f604e6dff06553a29377ca0448f17c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac761799f6a72b32c568afa99670f25e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac761799f6a72b32c568afa99670f25e4"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ac761799f6a72b32c568afa99670f25e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedSubAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:ac761799f6a72b32c568afa99670f25e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27187e0e219c7e210841a412e0ba514c"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a27187e0e219c7e210841a412e0ba514c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a27187e0e219c7e210841a412e0ba514c">subAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a27187e0e219c7e210841a412e0ba514c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a sparse vector.  <a href="#a27187e0e219c7e210841a412e0ba514c">More...</a><br /></td></tr>
<tr class="separator:a27187e0e219c7e210841a412e0ba514c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3e66a2fbb1d16ca67ecb024d4e70b9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2b3e66a2fbb1d16ca67ecb024d4e70b9"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a2b3e66a2fbb1d16ca67ecb024d4e70b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedMultAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a2b3e66a2fbb1d16ca67ecb024d4e70b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56428c0d27e63f4b6ef286da562b489e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56428c0d27e63f4b6ef286da562b489e"></a>
template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:a56428c0d27e63f4b6ef286da562b489e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedMultAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="separator:a56428c0d27e63f4b6ef286da562b489e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c0488ef667f3210316c2bceefe6269"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:af4c0488ef667f3210316c2bceefe6269"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#af4c0488ef667f3210316c2bceefe6269">multAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af4c0488ef667f3210316c2bceefe6269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the multiplication assignment of a sparse vector.  <a href="#af4c0488ef667f3210316c2bceefe6269">More...</a><br /></td></tr>
<tr class="separator:af4c0488ef667f3210316c2bceefe6269"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ga4599b6f7e97a040191a5b97a27f66a3b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>useConst</b> = IsConst&lt;VT&gt;::value
 }</td></tr>
<tr class="memdesc:ga4599b6f7e97a040191a5b97a27f66a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the non-const reference and iterator types.  <a href="../../de/d5c/group__dense__subvector.html#ga4599b6f7e97a040191a5b97a27f66a3b">More...</a><br /></td></tr>
<tr class="separator:ga4599b6f7e97a040191a5b97a27f66a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb07984d43864c643c68e86b3a1c10c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafb07984d43864c643c68e86b3a1c10c"></a>
typedef <a class="el" href="../../d7/d0c/structblaze_1_1If.html">If</a>&lt; <a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html">IsExpression</a>&lt; VT &gt;, VT, VT &amp; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#aafb07984d43864c643c68e86b3a1c10c">Operand</a></td></tr>
<tr class="memdesc:aafb07984d43864c643c68e86b3a1c10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite data type of the dense vector expression. <br /></td></tr>
<tr class="separator:aafb07984d43864c643c68e86b3a1c10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41b0e7e0a4ef92781ee773ed5c25b1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac41b0e7e0a4ef92781ee773ed5c25b1e"></a>
typedef <a class="el" href="../../d7/d73/classblaze_1_1IntrinsicTrait.html">IntrinsicTrait</a>&lt; typename VT::ElementType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#ac41b0e7e0a4ef92781ee773ed5c25b1e">IT</a></td></tr>
<tr class="memdesc:ac41b0e7e0a4ef92781ee773ed5c25b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic trait for the vector element type. <br /></td></tr>
<tr class="separator:ac41b0e7e0a4ef92781ee773ed5c25b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:a5888ba05e59b54d3a93d3770e5032690"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5888ba05e59b54d3a93d3770e5032690"></a>
<a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#aafb07984d43864c643c68e86b3a1c10c">Operand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a5888ba05e59b54d3a93d3770e5032690">vector_</a></td></tr>
<tr class="memdesc:a5888ba05e59b54d3a93d3770e5032690"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dense vector containing the subvector. <br /></td></tr>
<tr class="separator:a5888ba05e59b54d3a93d3770e5032690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743334971dfc032ccc6d3677b97a11af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a743334971dfc032ccc6d3677b97a11af"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a743334971dfc032ccc6d3677b97a11af">offset_</a></td></tr>
<tr class="memdesc:a743334971dfc032ccc6d3677b97a11af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The offset of the subvector within the dense vector. <br /></td></tr>
<tr class="separator:a743334971dfc032ccc6d3677b97a11af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857149ae84f5abca2c11f55c6766ec41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a857149ae84f5abca2c11f55c6766ec41"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a857149ae84f5abca2c11f55c6766ec41">size_</a></td></tr>
<tr class="memdesc:a857149ae84f5abca2c11f55c6766ec41"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the subvector. <br /></td></tr>
<tr class="separator:a857149ae84f5abca2c11f55c6766ec41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad38acd79cf964c8c941e3201fb571d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ad38acd79cf964c8c941e3201fb571d"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a6ad38acd79cf964c8c941e3201fb571d">rest_</a></td></tr>
<tr class="memdesc:a6ad38acd79cf964c8c941e3201fb571d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of remaining elements in an unaligned intrinsic operation. <br /></td></tr>
<tr class="separator:a6ad38acd79cf964c8c941e3201fb571d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc8772a4e3c6d2674584b1b4b859e8e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a5cc8772a4e3c6d2674584b1b4b859e8e">final_</a></td></tr>
<tr class="memdesc:a5cc8772a4e3c6d2674584b1b4b859e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The final index for unaligned intrinsic operations.  <a href="#a5cc8772a4e3c6d2674584b1b4b859e8e">More...</a><br /></td></tr>
<tr class="separator:a5cc8772a4e3c6d2674584b1b4b859e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859f75aa23f361fe17b53d064948589f"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a859f75aa23f361fe17b53d064948589f">isAligned_</a></td></tr>
<tr class="memdesc:a859f75aa23f361fe17b53d064948589f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory alignment flag.  <a href="#a859f75aa23f361fe17b53d064948589f">More...</a><br /></td></tr>
<tr class="separator:a859f75aa23f361fe17b53d064948589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt;<br />
class blaze::DenseSubvector&lt; VT, AF, TF &gt;</h3>

<p><a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> on a specific subvector of a dense vector.</p>
<p>The <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html" title="View on a specific subvector of a dense vector.The DenseSubvector template represents a view on a spe...">DenseSubvector</a> template represents a view on a specific subvector of a dense vector primitive. The type of the dense vector is specified via the first template parameter: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> VT, <span class="keywordtype">bool</span> AF, <span class="keywordtype">bool</span> TF &gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a907d7589502f0b5e5ffc7d3f9434b712">DenseSubvector</a>;</div>
</div><!-- fragment --><ul>
<li>VT: specifies the type of the dense vector primitive. <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html" title="View on a specific subvector of a dense vector.The DenseSubvector template represents a view on a spe...">DenseSubvector</a> can be used with every dense vector primitive or view, but does not work with any vector expression type.</li>
<li>AF: the alignment flag specifies whether the subvector is aligned (<em><a class="el" href="../../d2/de9/namespaceblaze.html#a30a412c45e10cff7eba4dacc999d55c7" title="Alignment flag for aligned subvectors and submatrices. ">blaze::aligned</a></em>) or unaligned (<em><a class="el" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5" title="Alignment flag for unaligned subvectors and submatrices. ">blaze::unaligned</a></em>). The default value is <em><a class="el" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5" title="Alignment flag for unaligned subvectors and submatrices. ">blaze::unaligned</a></em>.</li>
<li>TF: specifies whether the vector is a row vector (<em><a class="el" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors. ">blaze::rowVector</a></em>) or a column vector (<em><a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors. ">blaze::columnVector</a></em>). This template parameter doesn't have to be explicitly defined, but is automatically derived from the first template parameter.</li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="dense_subvector_setup"></a>
Setup of Dense Subvectors</h1>
<p>A view on a dense subvector can be created very conveniently via the <code><a class="el" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c" title="Creating a view on a specific subvector of the given vector. ">subvector()</a></code> function:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,blaze::rowVector&gt;</a>  DenseVectorType;</div>
<div class="line"></div>
<div class="line">DenseVectorType x;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a subvector from index 8 with a size of 16 (i.e. in the range [8..23])</span></div>
<div class="line"><a class="code" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector&lt;DenseVectorType&gt;</a> sv = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( x, 8UL, 16UL );</div>
</div><!-- fragment --><p>This view can be treated as any other dense vector, i.e. it can be assigned to, it can be copied from, and it can be used in arithmetic operations. The view can also be used on both sides of an assignment: The subvector can either be used as an alias to grant write access to a specific subvector of a dense vector primitive on the left-hand side of an assignment or to grant read-access to a specific subvector of a dense vector primitive or expression on the right-hand side of an assignment. The following example demonstrates this in detail:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,blaze::rowVector&gt;</a>     DenseVectorType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::rowVector&gt;</a>  SparseVectorType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a>      DenseMatrixType;</div>
<div class="line"></div>
<div class="line">DenseVectorType  x;</div>
<div class="line">SparseVectorType y;</div>
<div class="line">DenseMatrixType  A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a subvector from index 0 with a size of 10 (i.e. in the range [0..9])</span></div>
<div class="line"><a class="code" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector&lt;DenseVectorType&gt;</a> sv = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( x, 0UL, 10UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the first ten elements of x to the 2nd row of matrix A</span></div>
<div class="line">sv = <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 2UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the second ten elements of x to y</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( x, 10UL, 10UL ) = y;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the 3rd row of A to a subvector of x</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 3UL ) = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( x, 3UL, 10UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting x to a subvector of the result of the addition between y and the 1st row of A</span></div>
<div class="line">x = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( y + <a class="code" href="../../d0/d48/group__views.html#gaa1976b7e7ab9eb9608a57a4c20307ea9">row</a>( A, 1UL ), 2UL, 5UL )</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="dense_subvector_element_access"></a>
Element access</h1>
<p>A dense subvector can be used like any other dense vector. For instance, the elements of the dense subvector can be directly accessed with the subscript operator.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,blaze::rowVector&gt;</a>  <a class="code" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>;</div>
<div class="line">VectorType v;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating an 8-dimensional subvector, starting from index 4</span></div>
<div class="line"><a class="code" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector&lt;VectorType&gt;</a> sv = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( v, 4UL, 8UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the 1st element of the subvector, which corresponds to</span></div>
<div class="line"><span class="comment">// the element at index 5 in vector v</span></div>
<div class="line">sv[1] = 2.0;</div>
</div><!-- fragment --><p>The numbering of the subvector elements is</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; 1 &amp; 2 &amp; \cdots &amp; N-1 \\ \end{array}\right),\]" src="../../form_20.png"/>
</p>
<p>where N is the specified size of the subvector. Alternatively, the elements of a subvector can be traversed via iterators. Just as with vectors, in case of non-const subvectors, <code><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a8883b44aa6d6127cee162bf8fdbdd1de" title="Returns an iterator to the first element of the subvector. ">begin()</a></code> and <code><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#add9d23f09053778f09e6c0d26939aae8" title="Returns an iterator just past the last element of the subvector. ">end()</a></code> return an Iterator, which allows a manipulation of the non-zero values, in case of constant subvectors a ConstIterator is returned:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;int,blaze::rowVector&gt;</a>  <a class="code" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector&lt;VectorType&gt;</a>           SubvectorType;</div>
<div class="line"></div>
<div class="line">VectorType v( 256UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a reference to a specific subvector of vector v</span></div>
<div class="line">SubvectorType sv = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( v, 16UL, 64UL );</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">SubvectorType::Iterator</a> it=sv.begin(); it!=sv.end(); ++it ) {</div>
<div class="line">   *it = ...;  <span class="comment">// OK: Write access to the dense subvector value.</span></div>
<div class="line">   ... = *it;  <span class="comment">// OK: Read access to the dense subvector value.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">SubvectorType::ConstIterator</a> it=sv.begin(); it!=sv.end(); ++it ) {</div>
<div class="line">   *it = ...;  <span class="comment">// Compilation error: Assignment to the value via a ConstIterator is invalid.</span></div>
<div class="line">   ... = *it;  <span class="comment">// OK: Read access to the dense subvector value.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="dense_subvector_common_operations"></a>
Common Operations</h1>
<p>The current number of subvector elements can be obtained via the <code><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a711fce22dfe288fe434a0a5d5994af6a" title="Returns the current size/dimension of the dense subvector. ">size()</a></code> function, the current capacity via the <code><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a524f33e37d0be52b903b35f8453ec880" title="Returns the maximum capacity of the dense subvector. ">capacity()</a></code> function, and the number of non-zero elements via the <code><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a4de961cfa9264817c94770df76405013" title="Returns the number of non-zero elements in the subvector. ">nonZeros()</a></code> function. However, since subvector are views on a specific subvector of a vector, several operations are not possible on views, such as resizing and swapping:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;int,blaze::rowVector&gt;</a>  <a class="code" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector&lt;VectorType&gt;</a>           SubvectorType;</div>
<div class="line"></div>
<div class="line">VectorType v( 42UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a view on the range [5..15] of vector v</span></div>
<div class="line">SubvectorType sv = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( v, 5UL, 10UL );</div>
<div class="line"></div>
<div class="line">sv.size();          <span class="comment">// Returns the number of elements in the subvector</span></div>
<div class="line">sv.capacity();      <span class="comment">// Returns the capacity of the subvector</span></div>
<div class="line">sv.nonZeros();      <span class="comment">// Returns the number of non-zero elements contained in the subvector</span></div>
<div class="line"></div>
<div class="line">sv.resize( 84UL );  <span class="comment">// Compilation error: Cannot resize a subvector of a vector</span></div>
<div class="line"></div>
<div class="line">SubvectorType sv2 = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( v, 15UL, 10UL );</div>
<div class="line"><a class="code" href="../../d0/d90/group__diagonal__matrix.html#ga172895200063f120b6ffd241af12bbae">swap</a>( sv, sv2 );   <span class="comment">// Compilation error: Swap operation not allowed</span></div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="dense_subvector_arithmetic_operations"></a>
Arithmetic Operations</h1>
<p>The following example gives an impression of the use of <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html" title="View on a specific subvector of a dense vector.The DenseSubvector template represents a view on a spe...">DenseSubvector</a> within arithmetic operations. All operations (addition, subtraction, multiplication, scaling, ...) can be performed on all possible combinations of dense and sparse vectors with fitting element types:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,blaze::rowVector&gt;</a>     DenseVectorType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::rowVector&gt;</a>  SparseVectorType;</div>
<div class="line">DenseVectorType d1, d2, d3;</div>
<div class="line">SparseVectorType s1, s2;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a>  DenseMatrixType;</div>
<div class="line">DenseMatrixType A;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector&lt;DenseVectorType&gt;</a>  SubvectorType;</div>
<div class="line">SubvectorType sv( <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( d1, 0UL, 10UL ) );  <span class="comment">// View on the range [0..9] of vector d1</span></div>
<div class="line"></div>
<div class="line">sv = d2;                           <span class="comment">// Dense vector initialization of the range [0..9]</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( d1, 10UL, 10UL ) = s1;  <span class="comment">// Sparse vector initialization of the range [10..19]</span></div>
<div class="line"></div>
<div class="line">d3 = sv + d2;                           <span class="comment">// Dense vector/dense vector addition</span></div>
<div class="line">s2 = s1 + <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( d1, 10UL, 10UL );  <span class="comment">// Sparse vector/dense vector addition</span></div>
<div class="line">d2 = sv * <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( d1, 20UL, 10UL );  <span class="comment">// Component-wise vector multiplication</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( d1, 3UL, 4UL ) *= 2.0;      <span class="comment">// In-place scaling of the range [3..6]</span></div>
<div class="line">d2 = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( d1, 7UL, 3UL ) * 2.0;  <span class="comment">// Scaling of the range [7..9]</span></div>
<div class="line">d2 = 2.0 * <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( d1, 7UL, 3UL );  <span class="comment">// Scaling of the range [7..9]</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( d1, 0UL , 10UL ) += d2;  <span class="comment">// Addition assignment</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( d1, 10UL, 10UL ) -= s2;  <span class="comment">// Subtraction assignment</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( d1, 20UL, 10UL ) *= sv;  <span class="comment">// Multiplication assignment</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> scalar = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( d1, 5UL, 10UL ) * <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( s1 );  <span class="comment">// Scalar/dot/inner product between two vectors</span></div>
<div class="line"></div>
<div class="line">A = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( s1 ) * <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( d1, 4UL, 16UL );  <span class="comment">// Outer product between two vectors</span></div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="dense_subvector_aligned_subvector"></a>
Aligned Subvectors</h1>
<p>Usually subvectors can be defined anywhere within a vector. They may start at any position and may have an arbitrary size (only restricted by the size of the underlying vector). However, in contrast to vectors themselves, which are always properly aligned in memory and therefore can provide maximum performance, this means that subvectors in general have to be considered to be unaligned. This can be made explicit by the <em><a class="el" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5" title="Alignment flag for unaligned subvectors and submatrices. ">blaze::unaligned</a></em> flag:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a9182d2466faf6f39bfc6a7cd2e5895a5">blaze::unaligned</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,blaze::rowVector&gt;</a>  DenseVectorType;</div>
<div class="line"></div>
<div class="line">DenseVectorType x;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Identical creations of an unaligned subvector in the range [8..23]</span></div>
<div class="line"><a class="code" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector&lt;DenseVectorType&gt;</a>           sv1 = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>           ( x, 8UL, 16UL );</div>
<div class="line"><a class="code" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector&lt;DenseVectorType&gt;</a>           sv2 = subvector&lt;unaligned&gt;( x, 8UL, 16UL );</div>
<div class="line"><a class="code" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector&lt;DenseVectorType,unaligned&gt;</a> sv3 = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>           ( x, 8UL, 16UL );</div>
<div class="line"><a class="code" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector&lt;DenseVectorType,unaligned&gt;</a> sv4 = subvector&lt;unaligned&gt;( x, 8UL, 16UL );</div>
</div><!-- fragment --><p>All of these calls to the <code><a class="el" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c" title="Creating a view on a specific subvector of the given vector. ">subvector()</a></code> function are identical. Whether the alignment flag is explicitly specified or not, it always returns an unaligned subvector. Whereas this may provide full flexibility in the creation of subvectors, this might result in performance restrictions (even in case the specified subvector could be aligned). However, it is also possible to create aligned subvectors. Aligned subvectors are identical to unaligned subvectors in all aspects, except that they may pose additional alignment restrictions and therefore have less flexibility during creation, but don't suffer from performance penalties and provide the same performance as the underlying vector. Aligned subvectors are created by explicitly specifying the <em><a class="el" href="../../d2/de9/namespaceblaze.html#a30a412c45e10cff7eba4dacc999d55c7" title="Alignment flag for aligned subvectors and submatrices. ">blaze::aligned</a></em> flag:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a30a412c45e10cff7eba4dacc999d55c7">blaze::aligned</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating an aligned subvector in the range [8..23]</span></div>
<div class="line"><a class="code" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector&lt;DenseVectorType,aligned&gt;</a> sv = subvector&lt;aligned&gt;( x, 8UL, 16UL );</div>
</div><!-- fragment --><p>The alignment restrictions refer to system dependent address restrictions for the used element type and the available vectorization mode (SSE, AVX, ...). The following source code gives some examples for a double precision dense vector, assuming that AVX is available, which packs 4 <code>double</code> values into an intrinsic vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a>  <a class="code" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector&lt;VectorType,aligned&gt;</a>  SubvectorType;</div>
<div class="line"></div>
<div class="line">VectorType d( 17UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// OK: Starts at the beginning and the size is a multiple of 4</span></div>
<div class="line">SubvectorType dsv1 = subvector&lt;aligned&gt;( d, 0UL, 12UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// OK: Start index and the size are both a multiple of 4</span></div>
<div class="line">SubvectorType dsv2 = subvector&lt;aligned&gt;( d, 4UL, 8UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// OK: The start index is a multiple of 4 and the subvector includes the last element</span></div>
<div class="line">SubvectorType dsv3 = subvector&lt;aligned&gt;( d, 8UL, 9UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Error: Start index is not a multiple of 4</span></div>
<div class="line">SubvectorType dsv4 = subvector&lt;aligned&gt;( d, 5UL, 8UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Error: Size is not a multiple of 4 and the subvector does not include the last element</span></div>
<div class="line">SubvectorType dsv5 = subvector&lt;aligned&gt;( d, 8UL, 5UL );</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="dense_subvector_on_dense_subvector"></a>
Subvectors on Subvectors</h1>
<p>It is also possible to create a subvector view on another subvector. In this context it is important to remember that the type returned by the <code><a class="el" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c" title="Creating a view on a specific subvector of the given vector. ">subvector()</a></code> function is the same type as the type of the given subvector, since the view on a subvector is just another view on the underlying dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,blaze::rowVector&gt;</a>  <a class="code" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector&lt;VectorType&gt;</a>              SubvectorType;</div>
<div class="line"></div>
<div class="line">VectorType d1;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a subvector view on the dense vector d1</span></div>
<div class="line">SubvectorType sv1 = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( d1, 5UL, 10UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a subvector view on the dense subvector sv1</span></div>
<div class="line">SubvectorType sv2 = <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( sv1, 1UL, 5UL );</div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a907d7589502f0b5e5ffc7d3f9434b712"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#aafb07984d43864c643c68e86b3a1c10c">Operand</a>&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constructor for <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html" title="View on a specific subvector of a dense vector.The DenseSubvector template represents a view on a spe...">DenseSubvector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>The dense vector containing the subvector. </td></tr>
    <tr><td class="paramname">index</td><td>The first index of the subvector in the given vector. </td></tr>
    <tr><td class="paramname">n</td><td>The size of the subvector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid subvector specification.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the subvector is not properly specified (i.e. if the specified first index is larger than the size of the given vector or the subvector is specified beyond the size of the vector) a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8169bc0c9910a6c9c7e115a19aa9aad0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="af6dec88ccb4fb619bba399af26a67684"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt;VT,AF,TF&gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt;VT2&gt; &gt;::Type <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a618a4bb1dd3cb49010eb5c072c31578a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt;VT,AF,TF&gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt;VT2&gt; &gt;::Type <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the addition assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="afedd6c77df269f02e6e0ea08123e98fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a1d495c3ea598a8d4d74b9b7e833c8d20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt;VT,AF,TF&gt;::BLAZE_TEMPLATE VectorizedAssign&lt;VT2&gt; &gt;::Type <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a09b3340f4c2f915c2b34e975a623419e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt;VT,AF,TF&gt;::BLAZE_TEMPLATE VectorizedAssign&lt;VT2&gt; &gt;::Type <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a8883b44aa6d6127cee162bf8fdbdd1de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a1673aa20dcadca9606ef19bea0f04b3d">Iterator</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the subvector.</dd></dl>
<p>This function returns an iterator to the first element of the subvector. </p>

</div>
</div>
<a class="anchor" id="a7413ba4ca28c2dbf44e14574341dabe8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a608fa42539fe7cde45d6e6fd206d4dc5">ConstIterator</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the subvector.</dd></dl>
<p>This function returns an iterator to the first element of the subvector. </p>

</div>
</div>
<a class="anchor" id="a5461f87a2f7e4e192473525790aa89b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::canAlias </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the dense subvector can alias with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this dense subvector, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address can alias with the dense subvector. In contrast to the <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#ab1ff8492b607608048f199d6f57d1f80" title="Returns whether the dense subvector is aliased with the given address alias. ">isAliased()</a> function this function is allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="a33d76f4ac58b524cdfb48d71b03497ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 , bool AF2, bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::canAlias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT2, AF2, TF2 &gt; *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the dense subvector can alias with the given dense subvector <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this dense subvector, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address can alias with the dense subvector. In contrast to the <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#ab1ff8492b607608048f199d6f57d1f80" title="Returns whether the dense subvector is aliased with the given address alias. ">isAliased()</a> function this function is allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="a9425bbb0ed4cfea12c7668aa708a92af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::canSMPAssign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the subvector can be used in SMP assignments. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the subvector can be used in SMP assignments, <em>false</em> if not.</dd></dl>
<p>This function returns whether the subvector can be used in SMP assignments. In contrast to the <em>smpAssignable</em> member enumeration, which is based solely on compile time information, this function additionally provides runtime information (as for instance the current size of the subvector). </p>

</div>
</div>
<a class="anchor" id="a524f33e37d0be52b903b35f8453ec880"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the dense subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the dense subvector. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e2f48fbb75f153ee90661b7581fae49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a608fa42539fe7cde45d6e6fd206d4dc5">ConstIterator</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the subvector.</dd></dl>
<p>This function returns an iterator to the first element of the subvector. </p>

</div>
</div>
<a class="anchor" id="a618d1d0dbee52eb569ff5b5cd797c503"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a608fa42539fe7cde45d6e6fd206d4dc5">ConstIterator</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the subvector.</dd></dl>
<p>This function returns an iterator just past the last element of the subvector. </p>

</div>
</div>
<a class="anchor" id="a0b2c58f6445d7bee96481b320821a39f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a99ad203bfe87fa86dcec51f2021b2a09">Pointer</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the subvector elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage of the dense subvector. </p>

</div>
</div>
<a class="anchor" id="a3ed3617c7a639cb2db5c14708243d87b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#af5223713174379fb540166e5c8145e08">ConstPointer</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the subvector elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage of the dense subvector. </p>

</div>
</div>
<a class="anchor" id="add9d23f09053778f09e6c0d26939aae8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a1673aa20dcadca9606ef19bea0f04b3d">Iterator</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the subvector.</dd></dl>
<p>This function returns an iterator just past the last element of the subvector. </p>

</div>
</div>
<a class="anchor" id="ad6791af34aeeddbb411eeef8e8b730e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a608fa42539fe7cde45d6e6fd206d4dc5">ConstIterator</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the subvector.</dd></dl>
<p>This function returns an iterator just past the last element of the subvector. </p>

</div>
</div>
<a class="anchor" id="ab1ff8492b607608048f199d6f57d1f80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the dense subvector is aliased with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this dense subvector, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address is aliased with the dense subvector. In contrast to the <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a5461f87a2f7e4e192473525790aa89b0" title="Returns whether the dense subvector can alias with the given address alias. ">canAlias()</a> function this function is not allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="ad7977b631ce3e75ac167e639562f4a09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 , bool AF2, bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT2, AF2, TF2 &gt; *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the dense subvector is aliased with the given dense subvector <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this dense subvector, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address is aliased with the dense subvector. In contrast to the <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a5461f87a2f7e4e192473525790aa89b0" title="Returns whether the dense subvector can alias with the given address alias. ">canAlias()</a> function this function is not allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="ab7f691447328f8ca4f8ba60eb68cc904"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::isAligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the subvector is properly aligned in memory. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the subvector is aligned, <em>false</em> if not.</dd></dl>
<p>This function returns whether the subvector is guaranteed to be properly aligned in memory, i.e. whether the beginning and the end of the subvector are guaranteed to conform to the alignment restrictions of the underlying element type. </p>

</div>
</div>
<a class="anchor" id="a0ec302ccbb1b958f8f187292dbb38fa1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a0faadb521d30e134f69f53a80510fbe6">IntrinsicType</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligned load of an intrinsic element of the dense subvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of subvector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded intrinsic element.</dd></dl>
<p>This function performs an aligned load of a specific intrinsic element of the dense subvector. The index must be smaller than the number of subvector elements and it must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a47ec4f625cf5c607a6aad705e573bcc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a0faadb521d30e134f69f53a80510fbe6">IntrinsicType</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::loadu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unaligned load of an intrinsic element of the dense subvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of subvector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded intrinsic element.</dd></dl>
<p>This function performs an unaligned load of a specific intrinsic element of the dense subvector. The index must be smaller than the number of subvector elements and it must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="af4c0488ef667f3210316c2bceefe6269"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the multiplication assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ae3fc393c6379594a846690e966b4dd8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt;VT,AF,TF&gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt;VT2&gt; &gt;::Type <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the multiplication assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a2fa3189466a3dab83d7291ee3bb0e43f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt;VT,AF,TF&gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt;VT2&gt; &gt;::Type <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the multiplication assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a4de961cfa9264817c94770df76405013"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the subvector.</dd></dl>
<p>Note that the number of non-zero elements is always less than or equal to the current size of the subvector. </p>

</div>
</div>
<a class="anchor" id="ab8e0ae2f4a8a177477b8ad9f5db53051"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt;VT,AF,TF&gt;&amp; <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}*=\vec{b} $" src="../../form_68.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be multiplied with the dense subvector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a40111b5e961e141ad56566d601d2a014"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt;VT,AF,TF&gt; &gt;::Type&amp; <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication between a subvector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_69.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector. </dd></dl>

</div>
</div>
<a class="anchor" id="a4342d2b0fb0ab36aecd3de804e6df07b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt;VT,AF,TF&gt;&amp; <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator for the addition of a vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_66.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be added to the dense subvector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a4ef2bf2e243e616e9928dd83c5e96e3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt;VT,AF,TF&gt;&amp; <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator for the subtraction of a vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_67.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be subtracted from the dense subvector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a37b1bec70cb5cf7a88a8bc868975d45d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt;VT,AF,TF&gt; &gt;::Type&amp; <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator for the division of a subvector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_70.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector.</dd></dl>
<p><b>Note:</b> A division by zero is only checked by an user assert. </p>

</div>
</div>
<a class="anchor" id="a6bd409c3f97b3a8c142aca9ddd62a88d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt; &amp; <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a70cb447a35a3ac2d4f57ec991da98f00">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Homogenous assignment to all subvector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Scalar value to be assigned to all subvector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5e17eb6c53dbb99dd3b3677f6f70d88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt; &amp; <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator for <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html" title="View on a specific subvector of a dense vector.The DenseSubvector template represents a view on a spe...">DenseSubvector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Dense subvector to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d6/d66/structblaze_1_1Subvector.html" title="Base class for all subvectors.The Subvector class serves as a tag for all subvectors (i...">Subvector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two subvectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a7eedb1c1c3d19a05c765d3e3fd34c929"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt;VT,AF,TF&gt;&amp; <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for different vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned subvector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a8b599ae06703d804fd0df3a4947b25a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a5817dac57c274026a8b0e2b7562dcc70">Reference</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the subvector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of subvector elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="a39fb24203f8745ca791c5fc98d53763f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt; VT, AF, TF &gt;::<a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a901f249615a4c5a06be3f4260019c473">ConstReference</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the subvector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of subvector columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="a1be3095780509ea4b0c421bdb15920a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; VT, TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for non-constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ae37bee20b660eacfcb7a942dc9cdbe19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; VT, TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="af00ed48979f5f5afcfac27a15ec1046c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to the default initial values. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a8393e1a571d8913dec34c7b35b54d958"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt;VT,AF,TF&gt;&amp; <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scaling of the dense subvector by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_72.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value for the subvector scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the dense subvector. </dd></dl>

</div>
</div>
<a class="anchor" id="a711fce22dfe288fe434a0a5d5994af6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current size/dimension of the dense subvector. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the dense subvector. </dd></dl>

</div>
</div>
<a class="anchor" id="a200b706341a6a386d24dae66dede66cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a0faadb521d30e134f69f53a80510fbe6">IntrinsicType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligned store of an intrinsic element of the subvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of subvector elements. </td></tr>
    <tr><td class="paramname">value</td><td>The intrinsic element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an aligned store a specific intrinsic element of the dense subvector. The index must be smaller than the number of subvector elements and it must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a0a3fa13681e34a570efe74e0f6854ec0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::storeu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a0faadb521d30e134f69f53a80510fbe6">IntrinsicType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unaligned store of an intrinsic element of the subvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of subvector elements. </td></tr>
    <tr><td class="paramname">value</td><td>The intrinsic element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an unaligned store a specific intrinsic element of the dense subvector. The index must be smaller than the number of subvector elements and it must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a1852fe99f351dea26ea7b1d2d0e6a4ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html#a0faadb521d30e134f69f53a80510fbe6">IntrinsicType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligned, non-temporal store of an intrinsic element of the subvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of subvector elements. </td></tr>
    <tr><td class="paramname">value</td><td>The intrinsic element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an aligned, non-temporal store a specific intrinsic element of the dense subvector. The index must be smaller than the number of subvector elements and it must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a27187e0e219c7e210841a412e0ba514c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ace277472a287f733b2cf4e56da5ed8a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt;VT,AF,TF&gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt;VT2&gt; &gt;::Type <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a46becd941e3dcb89a86af050ce9f2ca7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">DenseSubvector</a>&lt;VT,AF,TF&gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt;VT2&gt; &gt;::Type <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the subtraction assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a5cc8772a4e3c6d2674584b1b4b859e8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::final_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The final index for unaligned intrinsic operations. </p>
<p>In case the subvector is not fully aligned and the subvector is involved in a vectorized operation, the final index indicates at which index a special treatment for the remaining elements is required. </p>

</div>
</div>
<a class="anchor" id="a859f75aa23f361fe17b53d064948589f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="../../d4/d8e/classblaze_1_1DenseSubvector.html">blaze::DenseSubvector</a>&lt; VT, AF, TF &gt;::isAligned_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory alignment flag. </p>
<p>The alignment flag indicates whether the subvector is fully aligned. In case the subvector is fully aligned, no special handling has to be used for the last elements of the subvector in a vectorized operation. In order to be aligned, the following conditions must hold for the subvector:</p><ul>
<li>The first element of the subvector must be aligned</li>
<li>The subvector must be at the end of the given vector or</li>
<li>The size of the subvector must be a multiple of the number of values per intrinsic element. </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>blaze/math/views/<a class="el" href="../../d8/d61/views_2DenseSubvector_8h_source.html">DenseSubvector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:55:23 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
