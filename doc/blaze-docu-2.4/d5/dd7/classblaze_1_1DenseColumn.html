<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>blaze::DenseColumn&lt; MT, SO, SF &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="../../d3/d50/classblaze_1_1DenseColumn-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::DenseColumn&lt; MT, SO, SF &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../d0/d48/group__views.html">Views</a> &raquo; <a class="el" href="../../da/d47/group__dense__column.html">DenseColumn</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Reference to a specific column of a dense matrix.The <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html" title="Reference to a specific column of a dense matrix.The DenseColumn template represents a reference to a...">DenseColumn</a> template represents a reference to a specific column of a dense matrix primitive. The type of the dense matrix is specified via the first template parameter:  
 <a href="../../d5/dd7/classblaze_1_1DenseColumn.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../df/d4b/views_2DenseColumn_8h_source.html">DenseColumn.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">blaze::DenseVector&lt; DenseColumn&lt; MT, SO, SF &gt;, false &gt;</a>, and <a class="el" href="../../d2/deb/structblaze_1_1Column.html">blaze::Column</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ga89fff6a2bb4e32b7975621077455f972"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga89fff6a2bb4e32b7975621077455f972"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>vectorizable</b> = MT::vectorizable
 }</td></tr>
<tr class="memdesc:ga89fff6a2bb4e32b7975621077455f972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the expression template evaluation strategy. <br /></td></tr>
<tr class="separator:ga89fff6a2bb4e32b7975621077455f972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b75164b7732ae73d46d8815c3c447a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8b75164b7732ae73d46d8815c3c447a0"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>smpAssignable</b> = MT::smpAssignable
 }</td></tr>
<tr class="memdesc:ga8b75164b7732ae73d46d8815c3c447a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the expression template assignment strategy. <br /></td></tr>
<tr class="separator:ga8b75164b7732ae73d46d8815c3c447a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62192f3dc51e8d4893d4e69b6e4caaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae62192f3dc51e8d4893d4e69b6e4caaa"></a>
typedef <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ae62192f3dc51e8d4893d4e69b6e4caaa">This</a></td></tr>
<tr class="memdesc:ae62192f3dc51e8d4893d4e69b6e4caaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html" title="Reference to a specific column of a dense matrix.The DenseColumn template represents a reference to a...">DenseColumn</a> instance. <br /></td></tr>
<tr class="separator:ae62192f3dc51e8d4893d4e69b6e4caaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae256fdae79c868b101ace2cf364c35ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae256fdae79c868b101ace2cf364c35ac"></a>
typedef <a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html">ColumnTrait</a>&lt; MT &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ae256fdae79c868b101ace2cf364c35ac">ResultType</a></td></tr>
<tr class="memdesc:ae256fdae79c868b101ace2cf364c35ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br /></td></tr>
<tr class="separator:ae256fdae79c868b101ace2cf364c35ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1cb584873af6ec361d301178ba1e23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c1cb584873af6ec361d301178ba1e23"></a>
typedef <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html#a02b3d3c589c780c2abaa5275b79b88ba">ResultType::TransposeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a0c1cb584873af6ec361d301178ba1e23">TransposeType</a></td></tr>
<tr class="memdesc:a0c1cb584873af6ec361d301178ba1e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br /></td></tr>
<tr class="separator:a0c1cb584873af6ec361d301178ba1e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782653abafd7ce742eddde0238a9ade3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a782653abafd7ce742eddde0238a9ade3"></a>
typedef MT::ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a782653abafd7ce742eddde0238a9ade3">ElementType</a></td></tr>
<tr class="memdesc:a782653abafd7ce742eddde0238a9ade3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the column elements. <br /></td></tr>
<tr class="separator:a782653abafd7ce742eddde0238a9ade3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602dedbb0962cf7a30052bed5e655758"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a602dedbb0962cf7a30052bed5e655758"></a>
typedef IT::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a602dedbb0962cf7a30052bed5e655758">IntrinsicType</a></td></tr>
<tr class="memdesc:a602dedbb0962cf7a30052bed5e655758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic type of the column elements. <br /></td></tr>
<tr class="separator:a602dedbb0962cf7a30052bed5e655758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb32212465a82c2b6f952bd7c4a6f40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedb32212465a82c2b6f952bd7c4a6f40"></a>
typedef MT::ReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#aedb32212465a82c2b6f952bd7c4a6f40">ReturnType</a></td></tr>
<tr class="memdesc:aedb32212465a82c2b6f952bd7c4a6f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br /></td></tr>
<tr class="separator:aedb32212465a82c2b6f952bd7c4a6f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1465fba4f6f86054ee446d2af7f899f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1465fba4f6f86054ee446d2af7f899f"></a>
typedef const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ad1465fba4f6f86054ee446d2af7f899f">CompositeType</a></td></tr>
<tr class="memdesc:ad1465fba4f6f86054ee446d2af7f899f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br /></td></tr>
<tr class="separator:ad1465fba4f6f86054ee446d2af7f899f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e32e99b06ece405a06e9a791c67583"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02e32e99b06ece405a06e9a791c67583"></a>
typedef MT::ConstReference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a02e32e99b06ece405a06e9a791c67583">ConstReference</a></td></tr>
<tr class="memdesc:a02e32e99b06ece405a06e9a791c67583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant column value. <br /></td></tr>
<tr class="separator:a02e32e99b06ece405a06e9a791c67583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac36089a592e83c8ac40d443341f75e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ac36089a592e83c8ac40d443341f75e"></a>
typedef <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; useConst, <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a02e32e99b06ece405a06e9a791c67583">ConstReference</a>, typename MT::Reference &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a9ac36089a592e83c8ac40d443341f75e">Reference</a></td></tr>
<tr class="memdesc:a9ac36089a592e83c8ac40d443341f75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant column value. <br /></td></tr>
<tr class="separator:a9ac36089a592e83c8ac40d443341f75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35350fa7810b002e36bc0c819a2bf979"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35350fa7810b002e36bc0c819a2bf979"></a>
typedef const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a782653abafd7ce742eddde0238a9ade3">ElementType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a35350fa7810b002e36bc0c819a2bf979">ConstPointer</a></td></tr>
<tr class="memdesc:a35350fa7810b002e36bc0c819a2bf979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a constant row value. <br /></td></tr>
<tr class="separator:a35350fa7810b002e36bc0c819a2bf979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68527d4874045e2a13ed995ed3770185"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68527d4874045e2a13ed995ed3770185"></a>
typedef <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; useConst, <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a35350fa7810b002e36bc0c819a2bf979">ConstPointer</a>, <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a782653abafd7ce742eddde0238a9ade3">ElementType</a> * &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a68527d4874045e2a13ed995ed3770185">Pointer</a></td></tr>
<tr class="memdesc:a68527d4874045e2a13ed995ed3770185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a non-constant row value. <br /></td></tr>
<tr class="separator:a68527d4874045e2a13ed995ed3770185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fe8170a67dfba6b7a3d4ee574b0ebe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21fe8170a67dfba6b7a3d4ee574b0ebe"></a>
typedef MT::ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a21fe8170a67dfba6b7a3d4ee574b0ebe">ConstIterator</a></td></tr>
<tr class="memdesc:a21fe8170a67dfba6b7a3d4ee574b0ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br /></td></tr>
<tr class="separator:a21fe8170a67dfba6b7a3d4ee574b0ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df919493ed5197273df28ec1130d806"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1df919493ed5197273df28ec1130d806"></a>
typedef <a class="el" href="../../de/d6e/structblaze_1_1IfTrue.html">IfTrue</a>&lt; useConst, <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a21fe8170a67dfba6b7a3d4ee574b0ebe">ConstIterator</a>, typename MT::Iterator &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a1df919493ed5197273df28ec1130d806">Iterator</a></td></tr>
<tr class="memdesc:a1df919493ed5197273df28ec1130d806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br /></td></tr>
<tr class="separator:a1df919493ed5197273df28ec1130d806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe7ddefcf2554b0bced1ad1b4b53e24"></a>
typedef VT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a></td></tr>
<tr class="memdesc:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the vector. <br /></td></tr>
<tr class="separator:a8fe7ddefcf2554b0bced1ad1b4b53e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3f601515daef9f042d96795076ec859a"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a3f601515daef9f042d96795076ec859a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a3f601515daef9f042d96795076ec859a">operator=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a3f601515daef9f042d96795076ec859a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for different vectors.  <a href="#a3f601515daef9f042d96795076ec859a">More...</a><br /></td></tr>
<tr class="separator:a3f601515daef9f042d96795076ec859a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c440dbb30936cc45eb769cbb464b31"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a99c440dbb30936cc45eb769cbb464b31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a99c440dbb30936cc45eb769cbb464b31">operator+=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a99c440dbb30936cc45eb769cbb464b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator for the addition of a vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_66.png"/>).  <a href="#a99c440dbb30936cc45eb769cbb464b31">More...</a><br /></td></tr>
<tr class="separator:a99c440dbb30936cc45eb769cbb464b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eace320c6b0ac1ef7df41de3115a635"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a8eace320c6b0ac1ef7df41de3115a635"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a8eace320c6b0ac1ef7df41de3115a635">operator-=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a8eace320c6b0ac1ef7df41de3115a635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator for the subtraction of a vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_67.png"/>).  <a href="#a8eace320c6b0ac1ef7df41de3115a635">More...</a><br /></td></tr>
<tr class="separator:a8eace320c6b0ac1ef7df41de3115a635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54ed060cb653e933ac695fcc3d0ec70"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:aa54ed060cb653e933ac695fcc3d0ec70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#aa54ed060cb653e933ac695fcc3d0ec70">operator*=</a> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa54ed060cb653e933ac695fcc3d0ec70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}*=\vec{b} $" src="../../form_68.png"/>).  <a href="#aa54ed060cb653e933ac695fcc3d0ec70">More...</a><br /></td></tr>
<tr class="separator:aa54ed060cb653e933ac695fcc3d0ec70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b791b5c929d07e432cf0e335e681655"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a7b791b5c929d07e432cf0e335e681655"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a7b791b5c929d07e432cf0e335e681655">operator*=</a> (Other rhs)</td></tr>
<tr class="memdesc:a7b791b5c929d07e432cf0e335e681655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication between a dense column and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_69.png"/>).  <a href="#a7b791b5c929d07e432cf0e335e681655">More...</a><br /></td></tr>
<tr class="separator:a7b791b5c929d07e432cf0e335e681655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa149b8fa189a64135658a42fff7e086c"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:aa149b8fa189a64135658a42fff7e086c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#aa149b8fa189a64135658a42fff7e086c">operator/=</a> (Other rhs)</td></tr>
<tr class="memdesc:aa149b8fa189a64135658a42fff7e086c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator for the division of a dense column by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_70.png"/>).  <a href="#aa149b8fa189a64135658a42fff7e086c">More...</a><br /></td></tr>
<tr class="separator:aa149b8fa189a64135658a42fff7e086c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe75a58760b866c42018060132b3d818"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:abe75a58760b866c42018060132b3d818"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#abe75a58760b866c42018060132b3d818">scale</a> (const Other &amp;scalar)</td></tr>
<tr class="memdesc:abe75a58760b866c42018060132b3d818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of the column by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_72.png"/>).  <a href="#abe75a58760b866c42018060132b3d818">More...</a><br /></td></tr>
<tr class="separator:abe75a58760b866c42018060132b3d818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388f78f8483214ad9b65566ac1d8d9f9"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a388f78f8483214ad9b65566ac1d8d9f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../df/df0/structblaze_1_1IsRestricted.html">IsRestricted</a>&lt; MT2 &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a388f78f8483214ad9b65566ac1d8d9f9">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a388f78f8483214ad9b65566ac1d8d9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying matrix.  <a href="#a388f78f8483214ad9b65566ac1d8d9f9">More...</a><br /></td></tr>
<tr class="separator:a388f78f8483214ad9b65566ac1d8d9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c53e4e685d86548aa90778fa459e28d"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a3c53e4e685d86548aa90778fa459e28d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a3c53e4e685d86548aa90778fa459e28d">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a3c53e4e685d86548aa90778fa459e28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying lower triangular matrix.  <a href="#a3c53e4e685d86548aa90778fa459e28d">More...</a><br /></td></tr>
<tr class="separator:a3c53e4e685d86548aa90778fa459e28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d78a8cc37b000803b98e92137576eb"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a13d78a8cc37b000803b98e92137576eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a13d78a8cc37b000803b98e92137576eb">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a13d78a8cc37b000803b98e92137576eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying lower triangular matrix.  <a href="#a13d78a8cc37b000803b98e92137576eb">More...</a><br /></td></tr>
<tr class="separator:a13d78a8cc37b000803b98e92137576eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fd6b4c4de3a7c7655afd4b45b99e09"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:ac9fd6b4c4de3a7c7655afd4b45b99e09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ac9fd6b4c4de3a7c7655afd4b45b99e09">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac9fd6b4c4de3a7c7655afd4b45b99e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying upper triangular matrix.  <a href="#ac9fd6b4c4de3a7c7655afd4b45b99e09">More...</a><br /></td></tr>
<tr class="separator:ac9fd6b4c4de3a7c7655afd4b45b99e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cb5421ad5ee137e9d6f181ff5113e4"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a87cb5421ad5ee137e9d6f181ff5113e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a87cb5421ad5ee137e9d6f181ff5113e4">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a87cb5421ad5ee137e9d6f181ff5113e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying upper triangular matrix.  <a href="#a87cb5421ad5ee137e9d6f181ff5113e4">More...</a><br /></td></tr>
<tr class="separator:a87cb5421ad5ee137e9d6f181ff5113e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31625a57de10379b19a578bcd8a30b1f"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a31625a57de10379b19a578bcd8a30b1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a31625a57de10379b19a578bcd8a30b1f">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a31625a57de10379b19a578bcd8a30b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying diagonal matrix.  <a href="#a31625a57de10379b19a578bcd8a30b1f">More...</a><br /></td></tr>
<tr class="separator:a31625a57de10379b19a578bcd8a30b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e013e1b734a30bc0081d8822e8ad7ec"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a7e013e1b734a30bc0081d8822e8ad7ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a7e013e1b734a30bc0081d8822e8ad7ec">preservesInvariant</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7e013e1b734a30bc0081d8822e8ad7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checking for possible invariant violations of the underlying diagonal matrix.  <a href="#a7e013e1b734a30bc0081d8822e8ad7ec">More...</a><br /></td></tr>
<tr class="separator:a7e013e1b734a30bc0081d8822e8ad7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e6d74ff780f8bde954a39918996d4d"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a19e6d74ff780f8bde954a39918996d4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a19e6d74ff780f8bde954a39918996d4d">assign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a19e6d74ff780f8bde954a39918996d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a dense vector.  <a href="#a19e6d74ff780f8bde954a39918996d4d">More...</a><br /></td></tr>
<tr class="separator:a19e6d74ff780f8bde954a39918996d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d35b1f5c7374e06816d7877538a7109"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a6d35b1f5c7374e06816d7877538a7109"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a6d35b1f5c7374e06816d7877538a7109">assign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6d35b1f5c7374e06816d7877538a7109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the assignment of a dense vector.  <a href="#a6d35b1f5c7374e06816d7877538a7109">More...</a><br /></td></tr>
<tr class="separator:a6d35b1f5c7374e06816d7877538a7109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac683fe2aadb44b0b9a7dbbf8ab1a11"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a2ac683fe2aadb44b0b9a7dbbf8ab1a11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a2ac683fe2aadb44b0b9a7dbbf8ab1a11">addAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2ac683fe2aadb44b0b9a7dbbf8ab1a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a dense vector.  <a href="#a2ac683fe2aadb44b0b9a7dbbf8ab1a11">More...</a><br /></td></tr>
<tr class="separator:a2ac683fe2aadb44b0b9a7dbbf8ab1a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3689ff37fb71459e68384e977480d04"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ae3689ff37fb71459e68384e977480d04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ae3689ff37fb71459e68384e977480d04">addAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae3689ff37fb71459e68384e977480d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the addition assignment of a dense vector.  <a href="#ae3689ff37fb71459e68384e977480d04">More...</a><br /></td></tr>
<tr class="separator:ae3689ff37fb71459e68384e977480d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f7990deb39774d4ad22342959c78d5"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a36f7990deb39774d4ad22342959c78d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a36f7990deb39774d4ad22342959c78d5">subAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a36f7990deb39774d4ad22342959c78d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a dense vector.  <a href="#a36f7990deb39774d4ad22342959c78d5">More...</a><br /></td></tr>
<tr class="separator:a36f7990deb39774d4ad22342959c78d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bc69ab23abfd8d5b9c7b7f98e1e71e"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:af2bc69ab23abfd8d5b9c7b7f98e1e71e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#af2bc69ab23abfd8d5b9c7b7f98e1e71e">subAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af2bc69ab23abfd8d5b9c7b7f98e1e71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the subtraction assignment of a dense vector.  <a href="#af2bc69ab23abfd8d5b9c7b7f98e1e71e">More...</a><br /></td></tr>
<tr class="separator:af2bc69ab23abfd8d5b9c7b7f98e1e71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132a7012ded16741a7de97abddc2feac"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a132a7012ded16741a7de97abddc2feac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a132a7012ded16741a7de97abddc2feac">multAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a132a7012ded16741a7de97abddc2feac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the multiplication assignment of a dense vector.  <a href="#a132a7012ded16741a7de97abddc2feac">More...</a><br /></td></tr>
<tr class="separator:a132a7012ded16741a7de97abddc2feac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef921c3eb5e0a983150083292646461"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:adef921c3eb5e0a983150083292646461"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#adef921c3eb5e0a983150083292646461">multAssign</a> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:adef921c3eb5e0a983150083292646461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the multiplication assignment of a dense vector.  <a href="#adef921c3eb5e0a983150083292646461">More...</a><br /></td></tr>
<tr class="separator:adef921c3eb5e0a983150083292646461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be3095780509ea4b0c421bdb15920a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#a1be3095780509ea4b0c421bdb15920a0">operator~</a> ()</td></tr>
<tr class="memdesc:a1be3095780509ea4b0c421bdb15920a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for non-constant vectors.  <a href="#a1be3095780509ea4b0c421bdb15920a0">More...</a><br /></td></tr>
<tr class="separator:a1be3095780509ea4b0c421bdb15920a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37bee20b660eacfcb7a942dc9cdbe19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d86/structblaze_1_1Vector.html#ae37bee20b660eacfcb7a942dc9cdbe19">operator~</a> () const </td></tr>
<tr class="memdesc:ae37bee20b660eacfcb7a942dc9cdbe19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for constant vectors.  <a href="#ae37bee20b660eacfcb7a942dc9cdbe19">More...</a><br /></td></tr>
<tr class="separator:ae37bee20b660eacfcb7a942dc9cdbe19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a530d69bd6be4930da35e40dc71ac2961"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a530d69bd6be4930da35e40dc71ac2961">DenseColumn</a> (MT &amp;matrix, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:a530d69bd6be4930da35e40dc71ac2961"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor for <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html" title="Reference to a specific column of a dense matrix.The DenseColumn template represents a reference to a...">DenseColumn</a>.  <a href="#a530d69bd6be4930da35e40dc71ac2961">More...</a><br /></td></tr>
<tr class="separator:a530d69bd6be4930da35e40dc71ac2961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access functions</div></td></tr>
<tr class="memitem:a9e466a85f8d149d49d01e7f2a18caf8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a9ac36089a592e83c8ac40d443341f75e">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a9e466a85f8d149d49d01e7f2a18caf8d">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index)</td></tr>
<tr class="memdesc:a9e466a85f8d149d49d01e7f2a18caf8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the column elements.  <a href="#a9e466a85f8d149d49d01e7f2a18caf8d">More...</a><br /></td></tr>
<tr class="separator:a9e466a85f8d149d49d01e7f2a18caf8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bfdc53272ed856ccb93b1a6e9650c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a02e32e99b06ece405a06e9a791c67583">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ac1bfdc53272ed856ccb93b1a6e9650c1">operator[]</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:ac1bfdc53272ed856ccb93b1a6e9650c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator for the direct access to the column elements.  <a href="#ac1bfdc53272ed856ccb93b1a6e9650c1">More...</a><br /></td></tr>
<tr class="separator:ac1bfdc53272ed856ccb93b1a6e9650c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda2a70edf8abca759e35bb17a023bcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a68527d4874045e2a13ed995ed3770185">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#acda2a70edf8abca759e35bb17a023bcc">data</a> ()</td></tr>
<tr class="memdesc:acda2a70edf8abca759e35bb17a023bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the column elements.  <a href="#acda2a70edf8abca759e35bb17a023bcc">More...</a><br /></td></tr>
<tr class="separator:acda2a70edf8abca759e35bb17a023bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab481810845248716b956884ab6d2ad71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a35350fa7810b002e36bc0c819a2bf979">ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ab481810845248716b956884ab6d2ad71">data</a> () const </td></tr>
<tr class="memdesc:ab481810845248716b956884ab6d2ad71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the column elements.  <a href="#ab481810845248716b956884ab6d2ad71">More...</a><br /></td></tr>
<tr class="separator:ab481810845248716b956884ab6d2ad71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad670aaca94bad403fedee0af45495110"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a1df919493ed5197273df28ec1130d806">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ad670aaca94bad403fedee0af45495110">begin</a> ()</td></tr>
<tr class="memdesc:ad670aaca94bad403fedee0af45495110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the column.  <a href="#ad670aaca94bad403fedee0af45495110">More...</a><br /></td></tr>
<tr class="separator:ad670aaca94bad403fedee0af45495110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ca63238cfebd1bd5d655eb10c5546c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a21fe8170a67dfba6b7a3d4ee574b0ebe">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#aa8ca63238cfebd1bd5d655eb10c5546c">begin</a> () const </td></tr>
<tr class="memdesc:aa8ca63238cfebd1bd5d655eb10c5546c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the column.  <a href="#aa8ca63238cfebd1bd5d655eb10c5546c">More...</a><br /></td></tr>
<tr class="separator:aa8ca63238cfebd1bd5d655eb10c5546c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7314f66930703b708db4cbf0cbf680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a21fe8170a67dfba6b7a3d4ee574b0ebe">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a5b7314f66930703b708db4cbf0cbf680">cbegin</a> () const </td></tr>
<tr class="memdesc:a5b7314f66930703b708db4cbf0cbf680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the column.  <a href="#a5b7314f66930703b708db4cbf0cbf680">More...</a><br /></td></tr>
<tr class="separator:a5b7314f66930703b708db4cbf0cbf680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41828da2f9dbf1beda54cbe75c343c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a1df919493ed5197273df28ec1130d806">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#aa41828da2f9dbf1beda54cbe75c343c1">end</a> ()</td></tr>
<tr class="memdesc:aa41828da2f9dbf1beda54cbe75c343c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the column.  <a href="#aa41828da2f9dbf1beda54cbe75c343c1">More...</a><br /></td></tr>
<tr class="separator:aa41828da2f9dbf1beda54cbe75c343c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0128cfeb17d86376f3a7de45a02009f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a21fe8170a67dfba6b7a3d4ee574b0ebe">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a0128cfeb17d86376f3a7de45a02009f0">end</a> () const </td></tr>
<tr class="memdesc:a0128cfeb17d86376f3a7de45a02009f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the column.  <a href="#a0128cfeb17d86376f3a7de45a02009f0">More...</a><br /></td></tr>
<tr class="separator:a0128cfeb17d86376f3a7de45a02009f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2431bade275dddffb78a9a5def0609"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a21fe8170a67dfba6b7a3d4ee574b0ebe">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#abe2431bade275dddffb78a9a5def0609">cend</a> () const </td></tr>
<tr class="memdesc:abe2431bade275dddffb78a9a5def0609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the column.  <a href="#abe2431bade275dddffb78a9a5def0609">More...</a><br /></td></tr>
<tr class="separator:abe2431bade275dddffb78a9a5def0609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment operators</div></td></tr>
<tr class="memitem:aa45865a71e41b2bf5ac8124d8c9d7920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#aa45865a71e41b2bf5ac8124d8c9d7920">operator=</a> (const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a782653abafd7ce742eddde0238a9ade3">ElementType</a> &amp;rhs)</td></tr>
<tr class="memdesc:aa45865a71e41b2bf5ac8124d8c9d7920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Homogenous assignment to all column elements.  <a href="#aa45865a71e41b2bf5ac8124d8c9d7920">More...</a><br /></td></tr>
<tr class="separator:aa45865a71e41b2bf5ac8124d8c9d7920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb29187d15c8733d7ec2c099567a011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a4cb29187d15c8733d7ec2c099567a011">operator=</a> (const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a> &amp;rhs)</td></tr>
<tr class="memdesc:a4cb29187d15c8733d7ec2c099567a011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html" title="Reference to a specific column of a dense matrix.The DenseColumn template represents a reference to a...">DenseColumn</a>.  <a href="#a4cb29187d15c8733d7ec2c099567a011">More...</a><br /></td></tr>
<tr class="separator:a4cb29187d15c8733d7ec2c099567a011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b7a8fdfe1764c0c828dc41b6386dd6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac7b7a8fdfe1764c0c828dc41b6386dd6"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ac7b7a8fdfe1764c0c828dc41b6386dd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:ac7b7a8fdfe1764c0c828dc41b6386dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74c494f103862078dacd577e35c107a"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa74c494f103862078dacd577e35c107a"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:aa74c494f103862078dacd577e35c107a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:aa74c494f103862078dacd577e35c107a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4927dddb8e41417091f552baef598ba1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4927dddb8e41417091f552baef598ba1"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a4927dddb8e41417091f552baef598ba1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a4927dddb8e41417091f552baef598ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c0042b564904e784366b2351f69b94"><td class="memTemplParams" colspan="2"><a class="anchor" id="a78c0042b564904e784366b2351f69b94"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a78c0042b564904e784366b2351f69b94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a78c0042b564904e784366b2351f69b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa8f8341a9e4188be25a8d3966d93e2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1fa8f8341a9e4188be25a8d3966d93e2"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a1fa8f8341a9e4188be25a8d3966d93e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (Other rhs)</td></tr>
<tr class="separator:a1fa8f8341a9e4188be25a8d3966d93e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d22a7661524064bfbe5bc2cce72c6b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae8d22a7661524064bfbe5bc2cce72c6b"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ae8d22a7661524064bfbe5bc2cce72c6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (Other rhs)</td></tr>
<tr class="separator:ae8d22a7661524064bfbe5bc2cce72c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression template evaluation functions</div></td></tr>
<tr class="memitem:a26829c561cf63eed14cd0b1026d6d35f"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a26829c561cf63eed14cd0b1026d6d35f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a26829c561cf63eed14cd0b1026d6d35f">canAlias</a> (const Other *alias) const </td></tr>
<tr class="memdesc:a26829c561cf63eed14cd0b1026d6d35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the dense column can alias with the given address <em>alias</em>.  <a href="#a26829c561cf63eed14cd0b1026d6d35f">More...</a><br /></td></tr>
<tr class="separator:a26829c561cf63eed14cd0b1026d6d35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd018007490062194fb5b1ad109059c8"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, bool SF2&gt; </td></tr>
<tr class="memitem:afd018007490062194fb5b1ad109059c8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#afd018007490062194fb5b1ad109059c8">canAlias</a> (const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT2, SO2, SF2 &gt; *alias) const </td></tr>
<tr class="memdesc:afd018007490062194fb5b1ad109059c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the dense column can alias with the given dense column <em>alias</em>.  <a href="#afd018007490062194fb5b1ad109059c8">More...</a><br /></td></tr>
<tr class="separator:afd018007490062194fb5b1ad109059c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b13996fcf1908e18183b14623d1ed0"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ae6b13996fcf1908e18183b14623d1ed0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ae6b13996fcf1908e18183b14623d1ed0">isAliased</a> (const Other *alias) const </td></tr>
<tr class="memdesc:ae6b13996fcf1908e18183b14623d1ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the dense column is aliased with the given address <em>alias</em>.  <a href="#ae6b13996fcf1908e18183b14623d1ed0">More...</a><br /></td></tr>
<tr class="separator:ae6b13996fcf1908e18183b14623d1ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab115fde3939e0a2ac6b9d338cdaf385b"><td class="memTemplParams" colspan="2">template&lt;typename MT2 , bool SO2, bool SF2&gt; </td></tr>
<tr class="memitem:ab115fde3939e0a2ac6b9d338cdaf385b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ab115fde3939e0a2ac6b9d338cdaf385b">isAliased</a> (const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT2, SO2, SF2 &gt; *alias) const </td></tr>
<tr class="memdesc:ab115fde3939e0a2ac6b9d338cdaf385b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the dense column is aliased with the given dense column <em>alias</em>.  <a href="#ab115fde3939e0a2ac6b9d338cdaf385b">More...</a><br /></td></tr>
<tr class="separator:ab115fde3939e0a2ac6b9d338cdaf385b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f3309ec37bc5aff6d818a5cdd83cbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a93f3309ec37bc5aff6d818a5cdd83cbb">isAligned</a> () const </td></tr>
<tr class="memdesc:a93f3309ec37bc5aff6d818a5cdd83cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the dense column is properly aligned in memory.  <a href="#a93f3309ec37bc5aff6d818a5cdd83cbb">More...</a><br /></td></tr>
<tr class="separator:a93f3309ec37bc5aff6d818a5cdd83cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3098d06e5384fb5e8ff5ad8025aef31f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a3098d06e5384fb5e8ff5ad8025aef31f">canSMPAssign</a> () const </td></tr>
<tr class="memdesc:a3098d06e5384fb5e8ff5ad8025aef31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the dense column can be used in SMP assignments.  <a href="#a3098d06e5384fb5e8ff5ad8025aef31f">More...</a><br /></td></tr>
<tr class="separator:a3098d06e5384fb5e8ff5ad8025aef31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af711d77e15c8d3db18f65a171f2a6864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a602dedbb0962cf7a30052bed5e655758">IntrinsicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#af711d77e15c8d3db18f65a171f2a6864">load</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:af711d77e15c8d3db18f65a171f2a6864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned load of an intrinsic element of the dense column.  <a href="#af711d77e15c8d3db18f65a171f2a6864">More...</a><br /></td></tr>
<tr class="separator:af711d77e15c8d3db18f65a171f2a6864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103c2d63c1eada453e95a03253c06b2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a602dedbb0962cf7a30052bed5e655758">IntrinsicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a103c2d63c1eada453e95a03253c06b2e">loadu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index) const </td></tr>
<tr class="memdesc:a103c2d63c1eada453e95a03253c06b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned load of an intrinsic element of the dense column.  <a href="#a103c2d63c1eada453e95a03253c06b2e">More...</a><br /></td></tr>
<tr class="separator:a103c2d63c1eada453e95a03253c06b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25fae6b2f9cc13fe81cc00c56f2ed9fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a25fae6b2f9cc13fe81cc00c56f2ed9fd">store</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a602dedbb0962cf7a30052bed5e655758">IntrinsicType</a> &amp;value)</td></tr>
<tr class="memdesc:a25fae6b2f9cc13fe81cc00c56f2ed9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of an intrinsic element of the dense column.  <a href="#a25fae6b2f9cc13fe81cc00c56f2ed9fd">More...</a><br /></td></tr>
<tr class="separator:a25fae6b2f9cc13fe81cc00c56f2ed9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b30367c7b280cdcb1c82ebd43af5d66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a2b30367c7b280cdcb1c82ebd43af5d66">storeu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a602dedbb0962cf7a30052bed5e655758">IntrinsicType</a> &amp;value)</td></tr>
<tr class="memdesc:a2b30367c7b280cdcb1c82ebd43af5d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of an intrinsic element of the dense column.  <a href="#a2b30367c7b280cdcb1c82ebd43af5d66">More...</a><br /></td></tr>
<tr class="separator:a2b30367c7b280cdcb1c82ebd43af5d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f30cc61cb40d8740ed2636534eab91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ae6f30cc61cb40d8740ed2636534eab91">stream</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> index, const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a602dedbb0962cf7a30052bed5e655758">IntrinsicType</a> &amp;value)</td></tr>
<tr class="memdesc:ae6f30cc61cb40d8740ed2636534eab91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of an intrinsic element of the dense column.  <a href="#ae6f30cc61cb40d8740ed2636534eab91">More...</a><br /></td></tr>
<tr class="separator:ae6f30cc61cb40d8740ed2636534eab91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4e29d67f48521456425bf84544542b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3a4e29d67f48521456425bf84544542b"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a3a4e29d67f48521456425bf84544542b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a3a4e29d67f48521456425bf84544542b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad969574982720107d4d92b63af8e67f6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad969574982720107d4d92b63af8e67f6"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ad969574982720107d4d92b63af8e67f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:ad969574982720107d4d92b63af8e67f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcbf65eb5aab43447cee33d4ab5386b"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a1dcbf65eb5aab43447cee33d4ab5386b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a1dcbf65eb5aab43447cee33d4ab5386b">assign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1dcbf65eb5aab43447cee33d4ab5386b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a sparse vector.  <a href="#a1dcbf65eb5aab43447cee33d4ab5386b">More...</a><br /></td></tr>
<tr class="separator:a1dcbf65eb5aab43447cee33d4ab5386b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f287cfd8a653a35d14d3306ebabc98"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad8f287cfd8a653a35d14d3306ebabc98"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ad8f287cfd8a653a35d14d3306ebabc98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedAddAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:ad8f287cfd8a653a35d14d3306ebabc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5882e625f695dc61b25bdc7d1dc2c6b5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5882e625f695dc61b25bdc7d1dc2c6b5"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a5882e625f695dc61b25bdc7d1dc2c6b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedAddAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a5882e625f695dc61b25bdc7d1dc2c6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1122f5aef092e2400d184bda50ae3bfb"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a1122f5aef092e2400d184bda50ae3bfb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a1122f5aef092e2400d184bda50ae3bfb">addAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1122f5aef092e2400d184bda50ae3bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a sparse vector.  <a href="#a1122f5aef092e2400d184bda50ae3bfb">More...</a><br /></td></tr>
<tr class="separator:a1122f5aef092e2400d184bda50ae3bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fc53661d9ac7c8de5122412a880063"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60fc53661d9ac7c8de5122412a880063"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a60fc53661d9ac7c8de5122412a880063"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedSubAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a60fc53661d9ac7c8de5122412a880063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ad4735ab05eefeab4baeddde21fa20"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac4ad4735ab05eefeab4baeddde21fa20"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ac4ad4735ab05eefeab4baeddde21fa20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedSubAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:ac4ad4735ab05eefeab4baeddde21fa20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5e0b7ceabdf986d8570a29006fa910"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a2e5e0b7ceabdf986d8570a29006fa910"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a2e5e0b7ceabdf986d8570a29006fa910">subAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2e5e0b7ceabdf986d8570a29006fa910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a sparse vector.  <a href="#a2e5e0b7ceabdf986d8570a29006fa910">More...</a><br /></td></tr>
<tr class="separator:a2e5e0b7ceabdf986d8570a29006fa910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd0ab31af0205a8afbce5be8929c937"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6fd0ab31af0205a8afbce5be8929c937"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a6fd0ab31af0205a8afbce5be8929c937"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedMultAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a6fd0ab31af0205a8afbce5be8929c937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47452944bcdaa73925367a9c5f35e3bf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a47452944bcdaa73925367a9c5f35e3bf"></a>
template&lt;typename VT &gt; </td></tr>
<tr class="memitem:a47452944bcdaa73925367a9c5f35e3bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedMultAssign&lt; VT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multAssign</b> (const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a47452944bcdaa73925367a9c5f35e3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9788687397119fd7352a2ee0e717d70"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ad9788687397119fd7352a2ee0e717d70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ad9788687397119fd7352a2ee0e717d70">multAssign</a> (const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad9788687397119fd7352a2ee0e717d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the multiplication assignment of a sparse vector.  <a href="#ad9788687397119fd7352a2ee0e717d70">More...</a><br /></td></tr>
<tr class="separator:ad9788687397119fd7352a2ee0e717d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ga2e218ad6208711b589a5e59edd2caa5d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>useConst</b> = IsConst&lt;MT&gt;::value
 }</td></tr>
<tr class="memdesc:ga2e218ad6208711b589a5e59edd2caa5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the non-const reference and iterator types.  <a href="../../da/d47/group__dense__column.html#ga2e218ad6208711b589a5e59edd2caa5d">More...</a><br /></td></tr>
<tr class="separator:ga2e218ad6208711b589a5e59edd2caa5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45400064080acd55d530a381344b538f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45400064080acd55d530a381344b538f"></a>
typedef <a class="el" href="../../d7/d0c/structblaze_1_1If.html">If</a>&lt; <a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html">IsExpression</a>&lt; MT &gt;, MT, MT &amp; &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a45400064080acd55d530a381344b538f">Operand</a></td></tr>
<tr class="memdesc:a45400064080acd55d530a381344b538f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite data type of the dense matrix expression. <br /></td></tr>
<tr class="separator:a45400064080acd55d530a381344b538f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5355452c7920b8bb2e1c04b726112ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5355452c7920b8bb2e1c04b726112ee"></a>
typedef <a class="el" href="../../d7/d73/classblaze_1_1IntrinsicTrait.html">IntrinsicTrait</a>&lt; typename MT::ElementType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ae5355452c7920b8bb2e1c04b726112ee">IT</a></td></tr>
<tr class="memdesc:ae5355452c7920b8bb2e1c04b726112ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic trait for the column element type. <br /></td></tr>
<tr class="separator:ae5355452c7920b8bb2e1c04b726112ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:a4cc1e7ea898ef5af180ee937a3b27259"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cc1e7ea898ef5af180ee937a3b27259"></a>
<a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a45400064080acd55d530a381344b538f">Operand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a4cc1e7ea898ef5af180ee937a3b27259">matrix_</a></td></tr>
<tr class="memdesc:a4cc1e7ea898ef5af180ee937a3b27259"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dense matrix containing the column. <br /></td></tr>
<tr class="separator:a4cc1e7ea898ef5af180ee937a3b27259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d835241011f09256c52b6c0548ac6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1d835241011f09256c52b6c0548ac6c"></a>
const <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ac1d835241011f09256c52b6c0548ac6c">col_</a></td></tr>
<tr class="memdesc:ac1d835241011f09256c52b6c0548ac6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the column in the matrix. <br /></td></tr>
<tr class="separator:ac1d835241011f09256c52b6c0548ac6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Utility functions</h2></td></tr>
<tr class="memitem:a6072a27a1643de9be8b50b165ca83261"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a6072a27a1643de9be8b50b165ca83261">size</a> () const </td></tr>
<tr class="memdesc:a6072a27a1643de9be8b50b165ca83261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size/dimension of the column.  <a href="#a6072a27a1643de9be8b50b165ca83261">More...</a><br /></td></tr>
<tr class="separator:a6072a27a1643de9be8b50b165ca83261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684ee1df73e9b9b1d0555d3a7175d471"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a684ee1df73e9b9b1d0555d3a7175d471">capacity</a> () const </td></tr>
<tr class="memdesc:a684ee1df73e9b9b1d0555d3a7175d471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the dense column.  <a href="#a684ee1df73e9b9b1d0555d3a7175d471">More...</a><br /></td></tr>
<tr class="separator:a684ee1df73e9b9b1d0555d3a7175d471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbc0a02bf3b408cf356487f77aafdd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a4cbc0a02bf3b408cf356487f77aafdd3">nonZeros</a> () const </td></tr>
<tr class="memdesc:a4cbc0a02bf3b408cf356487f77aafdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the column.  <a href="#a4cbc0a02bf3b408cf356487f77aafdd3">More...</a><br /></td></tr>
<tr class="separator:a4cbc0a02bf3b408cf356487f77aafdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f7fd186af025b35184ef23a13f7fda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ab8f7fd186af025b35184ef23a13f7fda">reset</a> ()</td></tr>
<tr class="memdesc:ab8f7fd186af025b35184ef23a13f7fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to the default initial values.  <a href="#ab8f7fd186af025b35184ef23a13f7fda">More...</a><br /></td></tr>
<tr class="separator:ab8f7fd186af025b35184ef23a13f7fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f90debbea3f4361009942acb8ee4441"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4f90debbea3f4361009942acb8ee4441"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a4f90debbea3f4361009942acb8ee4441"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scale</b> (const Other &amp;scalar)</td></tr>
<tr class="separator:a4f90debbea3f4361009942acb8ee4441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388f78f8483214ad9b65566ac1d8d9f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a388f78f8483214ad9b65566ac1d8d9f9"></a>
template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a388f78f8483214ad9b65566ac1d8d9f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../df/df0/structblaze_1_1IsRestricted.html">IsRestricted</a>&lt; MT2 &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a388f78f8483214ad9b65566ac1d8d9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c53e4e685d86548aa90778fa459e28d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c53e4e685d86548aa90778fa459e28d"></a>
template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a3c53e4e685d86548aa90778fa459e28d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a3c53e4e685d86548aa90778fa459e28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d78a8cc37b000803b98e92137576eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a13d78a8cc37b000803b98e92137576eb"></a>
template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a13d78a8cc37b000803b98e92137576eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a13d78a8cc37b000803b98e92137576eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fd6b4c4de3a7c7655afd4b45b99e09"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac9fd6b4c4de3a7c7655afd4b45b99e09"></a>
template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:ac9fd6b4c4de3a7c7655afd4b45b99e09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:ac9fd6b4c4de3a7c7655afd4b45b99e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cb5421ad5ee137e9d6f181ff5113e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a87cb5421ad5ee137e9d6f181ff5113e4"></a>
template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a87cb5421ad5ee137e9d6f181ff5113e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt; MT2 &gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt; &gt; &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a87cb5421ad5ee137e9d6f181ff5113e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31625a57de10379b19a578bcd8a30b1f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a31625a57de10379b19a578bcd8a30b1f"></a>
template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a31625a57de10379b19a578bcd8a30b1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a31625a57de10379b19a578bcd8a30b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e013e1b734a30bc0081d8822e8ad7ec"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7e013e1b734a30bc0081d8822e8ad7ec"></a>
template&lt;typename MT2 , bool SO2, typename VT &gt; </td></tr>
<tr class="memitem:a7e013e1b734a30bc0081d8822e8ad7ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt; MT2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>preservesInvariant</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;lhs, const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;rhs)</td></tr>
<tr class="separator:a7e013e1b734a30bc0081d8822e8ad7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt;<br />
class blaze::DenseColumn&lt; MT, SO, SF &gt;</h3>

<p>Reference to a specific column of a dense matrix.</p>
<p>The <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html" title="Reference to a specific column of a dense matrix.The DenseColumn template represents a reference to a...">DenseColumn</a> template represents a reference to a specific column of a dense matrix primitive. The type of the dense matrix is specified via the first template parameter: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> MT, <span class="keywordtype">bool</span> SO &gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a530d69bd6be4930da35e40dc71ac2961">DenseColumn</a>;</div>
</div><!-- fragment --><ul>
<li>MT: specifies the type of the dense matrix primitive. <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html" title="Reference to a specific column of a dense matrix.The DenseColumn template represents a reference to a...">DenseColumn</a> can be used with every dense matrix primitive, but does not work with any matrix expression type.</li>
<li>SO: specifies the storage order (<a class="el" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices. ">blaze::rowMajor</a>, <a class="el" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583" title="Storage order flag for column-major matrices. ">blaze::columnMajor</a>) of the dense matrix. This template parameter doesn't have to be explicitly defined, but is automatically derived from the first template parameter.</li>
<li>SF: specifies whether the given matrix is a symmetric matrix or not. Also this parameter doesn't have to be explicitly defined, but is automatically derived from the first template parameter.</li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="dense_column_setup"></a>
Setup of Dense Columns</h1>
<p>A reference to a dense column can be created very conveniently via the <code><a class="el" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40" title="Creating a view on a specific column of the given matrix. ">column()</a></code> function. This reference can be treated as any other column vector, i.e. it can be assigned to, it can be copied from, and it can be used in arithmetic operations. The reference can also be used on both sides of an assignment: The column can either be used as an alias to grant write access to a specific column of a matrix primitive on the left-hand side of an assignment or to grant read-access to a specific column of a matrix primitive or expression on the right-hand side of an assignment. The following example demonstrates this in detail:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,blaze::columnVector&gt;</a>     DenseVectorType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::columnVector&gt;</a>  SparseVectorType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a>      DenseMatrixType;</div>
<div class="line"></div>
<div class="line">DenseVectorType  x;</div>
<div class="line">SparseVectorType y;</div>
<div class="line">DenseMatrixType  A, B;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the 2nd column of matrix A to x</span></div>
<div class="line"><a class="code" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn&lt;DenseMatrixType&gt;</a> col2 = <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 2UL );</div>
<div class="line">col2 = x;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the 3rd column of matrix B to y</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( B, 3UL ) = y;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting x to the 1st column of matrix B</span></div>
<div class="line">x = <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( B, 1UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting y to the 4th column of the result of the matrix multiplication</span></div>
<div class="line">y = <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A * B, 4UL );</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="dense_column_element_access"></a>
Element access</h1>
<p>A dense column can be used like any other column vector. For instance, the elements of the dense column can be directly accessed with the subscript operator.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a>  MatrixType;</div>
<div class="line">MatrixType A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a view on the 4th column of matrix A</span></div>
<div class="line"><a class="code" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn&lt;MatrixType&gt;</a> col4 = <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 4UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Setting the 1st element of the dense column, which corresponds</span></div>
<div class="line"><span class="comment">// to the 1st element in the 4th column of matrix A</span></div>
<div class="line">col4[1] = 2.0;</div>
</div><!-- fragment --><p>The numbering of the column elements is</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; 1 &amp; 2 &amp; \cdots &amp; N-1 \\ \end{array}\right),\]" src="../../form_20.png"/>
</p>
<p>where N is the number of rows of the referenced matrix. Alternatively, the elements of a column can be traversed via iterators. Just as with vectors, in case of non-const rows, <code><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ad670aaca94bad403fedee0af45495110" title="Returns an iterator to the first element of the column. ">begin()</a></code> and <code><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#aa41828da2f9dbf1beda54cbe75c343c1" title="Returns an iterator just past the last element of the column. ">end()</a></code> return an Iterator, which allows a manipulation of the non-zero values, in case of constant columns a ConstIterator is returned:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::columnMajor&gt;</a>  MatrixType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn&lt;MatrixType&gt;</a>                ColumnType;</div>
<div class="line"></div>
<div class="line">MatrixType A( 128UL, 256UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a reference to the 31st column of matrix A</span></div>
<div class="line">ColumnType col31 = <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 31UL );</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">ColumnType::Iterator</a> it=col31.begin(); it!=col31.end(); ++it ) {</div>
<div class="line">   *it = ...;  <span class="comment">// OK; Write access to the dense column value</span></div>
<div class="line">   ... = *it;  <span class="comment">// OK: Read access to the dense column value.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a816aca4ad4888412e9d5e9339b9b5fcb">ColumnType::ConstIterator</a> it=col31.begin(); it!=col31.end(); ++it ) {</div>
<div class="line">   *it = ...;  <span class="comment">// Compilation error: Assignment to the value via a ConstIterator is invalid.</span></div>
<div class="line">   ... = *it;  <span class="comment">// OK: Read access to the dense column value.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="dense_column_common_operations"></a>
Common Operations</h1>
<p>The current number of column elements can be obtained via the <code><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a6072a27a1643de9be8b50b165ca83261" title="Returns the current size/dimension of the column. ">size()</a></code> function, the current capacity via the <code><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a684ee1df73e9b9b1d0555d3a7175d471" title="Returns the maximum capacity of the dense column. ">capacity()</a></code> function, and the number of non-zero elements via the <code><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a4cbc0a02bf3b408cf356487f77aafdd3" title="Returns the number of non-zero elements in the column. ">nonZeros()</a></code> function. However, since columns are references to specific columns of a matrix, several operations are not possible on views, such as resizing and swapping:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::columnMajor&gt;</a>  MatrixType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn&lt;MatrixType&gt;</a>                ColumnType;</div>
<div class="line"></div>
<div class="line">MatrixType A( 42UL, 42UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a reference to the 2nd column of matrix A</span></div>
<div class="line">ColumnType col2 = <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 2UL );</div>
<div class="line"></div>
<div class="line">col2.size();          <span class="comment">// Returns the number of elements in the column</span></div>
<div class="line">col2.capacity();      <span class="comment">// Returns the capacity of the column</span></div>
<div class="line">col2.nonZeros();      <span class="comment">// Returns the number of non-zero elements contained in the column</span></div>
<div class="line"></div>
<div class="line">col2.resize( 84UL );  <span class="comment">// Compilation error: Cannot resize a single column of a matrix</span></div>
<div class="line"></div>
<div class="line">ColumnType col3 = <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 3UL );</div>
<div class="line"><a class="code" href="../../d0/d90/group__diagonal__matrix.html#ga172895200063f120b6ffd241af12bbae">swap</a>( col2, col3 );   <span class="comment">// Compilation error: Swap operation not allowed</span></div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="dense_column_arithmetic_operations"></a>
Arithmetic Operations</h1>
<p>The following example gives an impression of the use of <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html" title="Reference to a specific column of a dense matrix.The DenseColumn template represents a reference to a...">DenseColumn</a> within arithmetic operations. All operations (addition, subtraction, multiplication, scaling, ...) can be performed on all possible combinations of dense and sparse vectors with fitting element types:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,blaze::columnVector&gt;</a> a( 2UL, 2.0 ), b;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,blaze::columnVector&gt;</a> c( 2UL );</div>
<div class="line">c[1] = 3.0;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::columnMajor&gt;</a>  MatrixType;</div>
<div class="line">MatrixType A( 2UL, 4UL );  <span class="comment">// Non-initialized 2x4 matrix</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn&lt;DenseMatrix&gt;</a>  RowType;</div>
<div class="line">RowType col0( <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 0UL ) );  <span class="comment">// Reference to the 0th column of A</span></div>
<div class="line"></div>
<div class="line">col0[0] = 0.0;           <span class="comment">// Manual initialization of the 0th column of A</span></div>
<div class="line">col0[1] = 0.0;</div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 1UL ) = 1.0;  <span class="comment">// Homogeneous initialization of the 1st column of A</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 2UL ) = a;    <span class="comment">// Dense vector initialization of the 2nd column of A</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 3UL ) = c;    <span class="comment">// Sparse vector initialization of the 3rd column of A</span></div>
<div class="line"></div>
<div class="line">b = col0 + a;                 <span class="comment">// Dense vector/dense vector addition</span></div>
<div class="line">b = c + <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 1UL );     <span class="comment">// Sparse vector/dense vector addition</span></div>
<div class="line">b = col0 * <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 2UL );  <span class="comment">// Component-wise vector multiplication</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 1UL ) *= 2.0;     <span class="comment">// In-place scaling of the 1st column</span></div>
<div class="line">b = <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 1UL ) * 2.0;  <span class="comment">// Scaling of the 1st column</span></div>
<div class="line">b = 2.0 * <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 1UL );  <span class="comment">// Scaling of the 1st column</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 2UL ) += a;                 <span class="comment">// Addition assignment</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 2UL ) -= c;                 <span class="comment">// Subtraction assignment</span></div>
<div class="line"><a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 2UL ) *= <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 0UL );  <span class="comment">// Multiplication assignment</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> scalar = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( c ) * <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 1UL );  <span class="comment">// Scalar/dot/inner product between two vectors</span></div>
<div class="line"></div>
<div class="line">A = <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 1UL ) * <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( c );  <span class="comment">// Outer product between two vectors</span></div>
</div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="dense_column_on_row_major_matrix"></a>
Dense Column on a Row-Major Matrix</h1>
<p>It is especially noteworthy that column views can be created for both row-major and column-major matrices. Whereas the interface of a row-major matrix only allows to traverse a row directly and the interface of a column-major matrix only allows to traverse a column, via views it is also possible to traverse a column of a row-major matrix. For instance:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,blaze::rowMajor&gt;</a>  MatrixType;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn&lt;MatrixType&gt;</a>             ColumnType;</div>
<div class="line"></div>
<div class="line">MatrixType A( 64UL, 32UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a reference to the 1st column of a column-major matrix A</span></div>
<div class="line">ColumnType col1 = <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A, 1UL );</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>( <a class="code" href="../../d2/de9/namespaceblaze.html#a4164808f730b18f0f772e8904c562a89">ColumnType::Iterator</a> it=col1.begin(); it!=col1.end(); ++it ) {</div>
<div class="line">   <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>However, please note that creating a column view on a matrix stored in a row-major fashion can result in a considerable performance decrease in comparison to a column view on a matrix with column-major storage format. This is due to the non-contiguous storage of the matrix elements. Therefore care has to be taken in the choice of the most suitable storage order:</p>
<div class="fragment"><div class="line"><span class="comment">// Setup of two row-major matrices</span></div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> A( 128UL, 128UL );</div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,blaze::rowMajor&gt;</a> B( 128UL, 128UL );</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// The computation of the 15th column of the multiplication between A and B ...</span></div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,blaze::columnVector&gt;</a> x = <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( A * B, 15UL );</div>
<div class="line"></div>
<div class="line"><span class="comment">// ... is essentially the same as the following computation, which multiplies</span></div>
<div class="line"><span class="comment">// A with the 15th column of the row-major matrix B.</span></div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,blaze::rowVector&gt;</a> x = A * <a class="code" href="../../d0/d48/group__views.html#ga0eab8cf8e4f12f22d6c8ce8d55f2ea40">column</a>( B, 15UL );</div>
</div><!-- fragment --><p>Although Blaze performs the resulting matrix/vector multiplication as efficiently as possible using a column-major storage order for matrix A would result in a more efficient evaluation. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a530d69bd6be4930da35e40dc71ac2961"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a> </td>
          <td>(</td>
          <td class="paramtype">MT &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constructor for <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html" title="Reference to a specific column of a dense matrix.The DenseColumn template represents a reference to a...">DenseColumn</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix containing the column. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid column access index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1122f5aef092e2400d184bda50ae3bfb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a2ac683fe2aadb44b0b9a7dbbf8ab1a11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt;MT,SO,SF&gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ae3689ff37fb71459e68384e977480d04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt;MT,SO,SF&gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the addition assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a1dcbf65eb5aab43447cee33d4ab5386b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a19e6d74ff780f8bde954a39918996d4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt;MT,SO,SF&gt;::BLAZE_TEMPLATE VectorizedAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a6d35b1f5c7374e06816d7877538a7109"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt;MT,SO,SF&gt;::BLAZE_TEMPLATE VectorizedAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ad670aaca94bad403fedee0af45495110"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a1df919493ed5197273df28ec1130d806">Iterator</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the column. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the column.</dd></dl>
<p>This function returns an iterator to the first element of the column. </p>

</div>
</div>
<a class="anchor" id="aa8ca63238cfebd1bd5d655eb10c5546c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a21fe8170a67dfba6b7a3d4ee574b0ebe">ConstIterator</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the column. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the column.</dd></dl>
<p>This function returns an iterator to the first element of the column. </p>

</div>
</div>
<a class="anchor" id="a26829c561cf63eed14cd0b1026d6d35f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::canAlias </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the dense column can alias with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this dense column, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address can alias with the dense column. In contrast to the <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ae6b13996fcf1908e18183b14623d1ed0" title="Returns whether the dense column is aliased with the given address alias. ">isAliased()</a> function this function is allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="afd018007490062194fb5b1ad109059c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, bool SF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::canAlias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT2, SO2, SF2 &gt; *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the dense column can alias with the given dense column <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this dense column, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address can alias with the dense column. In contrast to the <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#ae6b13996fcf1908e18183b14623d1ed0" title="Returns whether the dense column is aliased with the given address alias. ">isAliased()</a> function this function is allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="a3098d06e5384fb5e8ff5ad8025aef31f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::canSMPAssign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the dense column can be used in SMP assignments. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the dense column can be used in SMP assignments, <em>false</em> if not.</dd></dl>
<p>This function returns whether the dense column can be used in SMP assignments. In contrast to the <em>smpAssignable</em> member enumeration, which is based solely on compile time information, this function additionally provides runtime information (as for instance the current size of the dense column). </p>

</div>
</div>
<a class="anchor" id="a684ee1df73e9b9b1d0555d3a7175d471"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the dense column. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the dense column. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b7314f66930703b708db4cbf0cbf680"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a21fe8170a67dfba6b7a3d4ee574b0ebe">ConstIterator</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the column. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the column.</dd></dl>
<p>This function returns an iterator to the first element of the column. </p>

</div>
</div>
<a class="anchor" id="abe2431bade275dddffb78a9a5def0609"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a21fe8170a67dfba6b7a3d4ee574b0ebe">ConstIterator</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the column. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the column.</dd></dl>
<p>This function returns an iterator just past the last element of the column. </p>

</div>
</div>
<a class="anchor" id="acda2a70edf8abca759e35bb17a023bcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a68527d4874045e2a13ed995ed3770185">Pointer</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the column elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage of the dense column. </p>

</div>
</div>
<a class="anchor" id="ab481810845248716b956884ab6d2ad71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a35350fa7810b002e36bc0c819a2bf979">ConstPointer</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the column elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage of the dense column. </p>

</div>
</div>
<a class="anchor" id="aa41828da2f9dbf1beda54cbe75c343c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a1df919493ed5197273df28ec1130d806">Iterator</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the column. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the column.</dd></dl>
<p>This function returns an iterator just past the last element of the column. </p>

</div>
</div>
<a class="anchor" id="a0128cfeb17d86376f3a7de45a02009f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a21fe8170a67dfba6b7a3d4ee574b0ebe">ConstIterator</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the column. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the column.</dd></dl>
<p>This function returns an iterator just past the last element of the column. </p>

</div>
</div>
<a class="anchor" id="ae6b13996fcf1908e18183b14623d1ed0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the dense column is aliased with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this dense column, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address is aliased with the dense column. In contrast to the <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a26829c561cf63eed14cd0b1026d6d35f" title="Returns whether the dense column can alias with the given address alias. ">canAlias()</a> function this function is not allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="ab115fde3939e0a2ac6b9d338cdaf385b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, bool SF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT2, SO2, SF2 &gt; *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the dense column is aliased with the given dense column <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this dense column, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address is aliased with the dense column. In contrast to the <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a26829c561cf63eed14cd0b1026d6d35f" title="Returns whether the dense column can alias with the given address alias. ">canAlias()</a> function this function is not allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="a93f3309ec37bc5aff6d818a5cdd83cbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::isAligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the dense column is properly aligned in memory. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the dense column is aligned, <em>false</em> if not.</dd></dl>
<p>This function returns whether the dense column is guaranteed to be properly aligned in memory, i.e. whether the beginning and the end of the dense column are guaranteed to conform to the alignment restrictions of the element type <em>Type</em>. </p>

</div>
</div>
<a class="anchor" id="af711d77e15c8d3db18f65a171f2a6864"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a602dedbb0962cf7a30052bed5e655758">IntrinsicType</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned load of an intrinsic element of the dense column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of matrix rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded intrinsic element.</dd></dl>
<p>This function performs an aligned load of a specific intrinsic element of the dense column. The index must be smaller than the number of matrix rows. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a103c2d63c1eada453e95a03253c06b2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a602dedbb0962cf7a30052bed5e655758">IntrinsicType</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::loadu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unaligned load of an intrinsic element of the dense column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of matrix rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded intrinsic element.</dd></dl>
<p>This function performs an unaligned load of a specific intrinsic element of the dense column. The index must be smaller than the number of matrix rows. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="ad9788687397119fd7352a2ee0e717d70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the multiplication assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a132a7012ded16741a7de97abddc2feac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt;MT,SO,SF&gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the multiplication assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="adef921c3eb5e0a983150083292646461"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt;MT,SO,SF&gt;::BLAZE_TEMPLATE VectorizedMultAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::multAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the multiplication assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a4cbc0a02bf3b408cf356487f77aafdd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the column. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the column.</dd></dl>
<p>Note that the number of non-zero elements is always less than or equal to the current number of rows of the matrix containing the column. </p>

</div>
</div>
<a class="anchor" id="aa54ed060cb653e933ac695fcc3d0ec70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt;MT,SO,SF&gt;&amp; <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication of a vector ( <img class="formulaInl" alt="$ \vec{a}*=\vec{b} $" src="../../form_68.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be multiplied with the dense column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned column. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a7b791b5c929d07e432cf0e335e681655"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt;MT,SO,SF&gt; &gt;::Type&amp; <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication between a dense column and a scalar value ( <img class="formulaInl" alt="$ \vec{a}*=s $" src="../../form_69.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector.</dd></dl>
<p>This operator cannot be used for columns on lower or upper unitriangular matrices. The attempt to scale such a row results in a compilation error! </p>

</div>
</div>
<a class="anchor" id="a99c440dbb30936cc45eb769cbb464b31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt;MT,SO,SF&gt;&amp; <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator for the addition of a vector ( <img class="formulaInl" alt="$ \vec{a}+=\vec{b} $" src="../../form_66.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be added to the dense column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned column. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to restricted matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower or upper triangular matrix and the assignment would violate its lower or upper property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a8eace320c6b0ac1ef7df41de3115a635"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt;MT,SO,SF&gt;&amp; <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator for the subtraction of a vector ( <img class="formulaInl" alt="$ \vec{a}-=\vec{b} $" src="../../form_67.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side vector to be subtracted from the dense column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned column. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to restricted matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower or upper triangular matrix and the assignment would violate its lower or upper property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="aa149b8fa189a64135658a42fff7e086c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt;MT,SO,SF&gt; &gt;::Type&amp; <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator for the division of a dense column by a scalar value ( <img class="formulaInl" alt="$ \vec{a}/=s $" src="../../form_70.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the vector.</dd></dl>
<p>This operator cannot be used for columns on lower or upper unitriangular matrices. The attempt to scale such a row results in a compilation error!</p>
<p><b>Note:</b> A division by zero is only checked by an user assert. </p>

</div>
</div>
<a class="anchor" id="aa45865a71e41b2bf5ac8124d8c9d7920"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt; &amp; <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a782653abafd7ce742eddde0238a9ade3">ElementType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Homogenous assignment to all column elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Scalar value to be assigned to all column elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned column.</dd></dl>
<p>This function homogeneously assigns the given value to all elements of the column. Note that in case the underlying dense matrix is a lower/upper matrix only lower/upper and diagonal elements of the underlying matrix are modified. </p>

</div>
</div>
<a class="anchor" id="a4cb29187d15c8733d7ec2c099567a011"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt; &amp; <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator for <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html" title="Reference to a specific column of a dense matrix.The DenseColumn template represents a reference to a...">DenseColumn</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Dense column to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned column. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d2/deb/structblaze_1_1Column.html" title="Base class for all columns.The Column class serves as a tag for all columns (i.e. dense and sparse co...">Column</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to restricted matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two columns don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower or upper triangular matrix and the assignment would violate its lower or upper property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a3f601515daef9f042d96795076ec859a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt;MT,SO,SF&gt;&amp; <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for different vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned column. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid assignment to restricted matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two vectors don't match, a <em>std::invalid_argument</em> exception is thrown. Also, if the underlying matrix <em>MT</em> is a lower or upper triangular matrix and the assignment would violate its lower or upper property, respectively, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a9e466a85f8d149d49d01e7f2a18caf8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a9ac36089a592e83c8ac40d443341f75e">Reference</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the column elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of matrix rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1bfdc53272ed856ccb93b1a6e9650c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt; MT, SO, SF &gt;::<a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a02e32e99b06ece405a06e9a791c67583">ConstReference</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscript operator for the direct access to the column elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of matrix rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="a1be3095780509ea4b0c421bdb15920a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; VT, TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for non-constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ae37bee20b660eacfcb7a942dc9cdbe19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../da/d86/structblaze_1_1Vector.html#a8fe7ddefcf2554b0bced1ad1b4b53e24">VectorType</a>&amp; <a class="el" href="../../da/d86/structblaze_1_1Vector.html">blaze::Vector</a>&lt; VT, TF &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for constant vectors. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference of the actual type of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a388f78f8483214ad9b65566ac1d8d9f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../df/df0/structblaze_1_1IsRestricted.html">IsRestricted</a>&lt;MT2&gt; &gt;, bool &gt;::Type <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d86/structblaze_1_1Vector.html">Vector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying matrix of type <em>MT</em> would be violated by an assignment of the given vector <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a3c53e4e685d86548aa90778fa459e28d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The lower matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying lower triangular matrix of type <em>MT</em> would be violated by an assignment of the given dense vector <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a13d78a8cc37b000803b98e92137576eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">IsLower</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying lower triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The lower matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying lower triangular matrix of type <em>MT</em> would be violated by an assignment of the given sparse vector <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="ac9fd6b4c4de3a7c7655afd4b45b99e09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The upper matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying upper triangular matrix of type <em>MT</em> would be violated by an assignment of the given dense vector <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a87cb5421ad5ee137e9d6f181ff5113e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d7/d97/structblaze_1_1And.html">And</a>&lt; <a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">IsUpper</a>&lt;MT2&gt;, <a class="el" href="../../dd/d46/structblaze_1_1Not.html">Not</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt; &gt; &gt;, bool &gt;::Type <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The upper matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying upper triangular matrix of type <em>MT</em> would be violated by an assignment of the given sparse vector <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a31625a57de10379b19a578bcd8a30b1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt;, bool &gt;::Type <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying diagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The diagonal matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The dense vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying diagonal matrix of type <em>MT</em> would be violated by an assignment of the given dense vector <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="a7e013e1b734a30bc0081d8822e8ad7ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename MT2 , bool SO2, typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">IsDiagonal</a>&lt;MT2&gt;, bool &gt;::Type <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::preservesInvariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT2, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checking for possible invariant violations of the underlying diagonal matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The diagonal matrix to be assigned to. </td></tr>
    <tr><td class="paramname">rhs</td><td>The sparse vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the invariants of the matrix are preserved, <em>false</em> if not.</dd></dl>
<p>This function checks if the invariants of the underlying diagonal matrix of type <em>MT</em> would be violated by an assignment of the given sparse vector <em>rhs</em>. In case the matrix would be preserved, the function returns <em>true</em>. Otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="ab8f7fd186af025b35184ef23a13f7fda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to the default initial values. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="abe75a58760b866c42018060132b3d818"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt;MT,SO,SF&gt;&amp; <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scaling of the column by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_72.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value for the column scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the dense column.</dd></dl>
<p>This function scales all elements of the column by the given scalar value <em>scalar</em>. Note that the function cannot be used to scale a column on a lower or upper unitriangular matrix. The attempt to scale such a row results in a compile time error! </p>

</div>
</div>
<a class="anchor" id="a6072a27a1643de9be8b50b165ca83261"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current size/dimension of the column. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the column. </dd></dl>

</div>
</div>
<a class="anchor" id="a25fae6b2f9cc13fe81cc00c56f2ed9fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a602dedbb0962cf7a30052bed5e655758">IntrinsicType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned store of an intrinsic element of the dense column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of matrix rows. </td></tr>
    <tr><td class="paramname">value</td><td>The intrinsic element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an aligned store a specific intrinsic element of the dense column. The index must be smaller than the number of matrix rows. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a2b30367c7b280cdcb1c82ebd43af5d66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::storeu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a602dedbb0962cf7a30052bed5e655758">IntrinsicType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unaligned store of an intrinsic element of the dense column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of matrix rows. </td></tr>
    <tr><td class="paramname">value</td><td>The intrinsic element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an unaligned store a specific intrinsic element of the dense column. The index must be smaller than the number of matrix rows. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="ae6f30cc61cb40d8740ed2636534eab91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html#a602dedbb0962cf7a30052bed5e655758">IntrinsicType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned, non-temporal store of an intrinsic element of the dense column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Access index. The index must be smaller than the number of matrix rows. </td></tr>
    <tr><td class="paramname">value</td><td>The intrinsic element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an aligned, non-temporal store a specific intrinsic element of the dense column. The index must be smaller than the number of matrix rows. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a2e5e0b7ceabdf986d8570a29006fa910"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , bool SO, bool SF&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a36f7990deb39774d4ad22342959c78d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt;MT,SO,SF&gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="af2bc69ab23abfd8d5b9c7b7f98e1e71e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO = IsColumnMajorMatrix&lt;MT&gt;::value, bool SF = IsSymmetric&lt;MT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">DenseColumn</a>&lt;MT,SO,SF&gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt;VT&gt; &gt;::Type <a class="el" href="../../d5/dd7/classblaze_1_1DenseColumn.html">blaze::DenseColumn</a>&lt; MT, SO, SF &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the subtraction assignment of a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>blaze/math/views/<a class="el" href="../../df/d4b/views_2DenseColumn_8h_source.html">DenseColumn.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:55:22 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
