<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Type traits</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Type traits<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d5d/structblaze_1_1BaseElementType.html">blaze::BaseElementType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the base element type of a given data type.Via this type trait it is possible to evaluate the base (fundamental) element type at the heart of a given data type. Examples:  <a href="../../d7/d5d/structblaze_1_1BaseElementType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d84/structblaze_1_1Columns.html">blaze::Columns&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time evaluation of the number of columns of a matrix.The <a class="el" href="../../d5/d84/structblaze_1_1Columns.html" title="Compile time evaluation of the number of columns of a matrix.The Columns type trait evaluates the num...">Columns</a> type trait evaluates the number of columns of the given matrix type at compile time. In case the given type <em>T</em> is a matrix type with a fixed number of columns (e.g. <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a>), the <em>value</em> member constant is set to the according number of columns. In all other cases, <em>value</em> is set to 0.  <a href="../../d5/d84/structblaze_1_1Columns.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd2/structblaze_1_1HasConstDataAccess.html">blaze::HasConstDataAccess&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for low-level access to constant data.This type trait tests whether the given data type provides a low-level access to constant data via a const 'data' member function. In case the according member function is provided, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../df/dd2/structblaze_1_1HasConstDataAccess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d87/structblaze_1_1HasMutableDataAccess.html">blaze::HasMutableDataAccess&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for low-level access to mutable data.This type trait tests whether the given data type provides a low-level access to mutable data via a non-const 'data' member function. In case the according member function is provided, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../dc/d87/structblaze_1_1HasMutableDataAccess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dba/structblaze_1_1IsAbsExpr.html">blaze::IsAbsExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is an absolute value expression template.This type trait class tests whether or not the given type <em>Type</em> is an absolute value expression template. In order to qualify as a valid absolute value expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../dc/d3f/structblaze_1_1AbsExpr.html" title="Base class for all absolute value expression templates.The AbsExpr class serves as a tag for all expr...">AbsExpr</a> base class. In case the given type is a valid absolute value expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/dba/structblaze_1_1IsAbsExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da2/structblaze_1_1IsAdaptor.html">blaze::IsAdaptor&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for adaptors.This type trait tests whether the given template parameter is an adaptor type (for instance <em><a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html" title="Matrix adapter for lower triangular  matrices. ">LowerMatrix</a></em>, <em><a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html" title="Matrix adapter for upper triangular  matrices. ">UpperMatrix</a></em>, or <em><a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html" title="Matrix adapter for symmetric  matrices. ">SymmetricMatrix</a></em>). In case the type is an adaptor type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. The following example demonstrates this by means of the mentioned matrix adaptors:  <a href="../../d4/da2/structblaze_1_1IsAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0e/structblaze_1_1IsAddExpr.html">blaze::IsAddExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is an addition expression template.This type trait class tests whether or not the given type <em>Type</em> is an addition expression template (i.e. an expression representing a vector addition or a matrix addition). In order to qualify as a valid addition expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d5/d2f/structblaze_1_1AddExpr.html" title="Base class for all addition expression templates.The AddExpr class serves as a tag for all expression...">AddExpr</a> base class. In case the given type is a valid addition expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d0e/structblaze_1_1IsAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d6d/structblaze_1_1IsBlasCompatible.html">blaze::IsBlasCompatible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types.This type trait tests whether or not the given template parameter is a data type compatible to the BLAS standard. The BLAS standard currently only supports float, double, complex&lt;float&gt; and complex&lt;double&gt; values. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type is BLAS compatible, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d6d/structblaze_1_1IsBlasCompatible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d61/structblaze_1_1IsColumn.html">blaze::IsColumn&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for columns.This type trait tests whether or not the given template parameter is a column (i.e. dense or sparse column). In case the type is a column, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d61/structblaze_1_1IsColumn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d55/structblaze_1_1IsColumnMajorMatrix.html">blaze::IsColumnMajorMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for column-major matrix types.This type trait tests whether or not the given template argument is a column-major dense or sparse matrix type (i.e., a matrix whose storage order is set to <em>true</em>). In case the type is a column-major matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d55/structblaze_1_1IsColumnMajorMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d10/structblaze_1_1IsColumnVector.html">blaze::IsColumnVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for column vector types.This type trait tests whether or not the given template argument is a column dense or sparse vector type (i.e. a vector whose transposition flag is set to <a class="el" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa" title="Transpose flag for column vectors. ">blaze::columnVector</a>). In case the type is a column vector type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d10/structblaze_1_1IsColumnVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/daf/structblaze_1_1IsComputation.html">blaze::IsComputation&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a computational expression template.This type trait class tests whether or not the given type <em>Type</em> is a computational expression template (i.e. a mathematical operation such as an addition, a subtraction, a multiplication, a division, an absolute value calculation, ...). In order to qualify as a valid computational expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> base class. In case the given type is a valid computational expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/daf/structblaze_1_1IsComputation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d43/structblaze_1_1IsCrossExpr.html">blaze::IsCrossExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a cross product expression template.This type trait class tests whether or not the given type <em>Type</em> is a cross product expression template. In order to qualify as a valid cross product expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../dc/dc0/structblaze_1_1CrossExpr.html" title="Base class for all cross product expression templates.The CrossExpr class serves as a tag for all exp...">CrossExpr</a> base class. In case the given type is a valid cross product expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d43/structblaze_1_1IsCrossExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d1a/structblaze_1_1IsDenseMatrix.html">blaze::IsDenseMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for dense matrix types.This type trait tests whether or not the given template parameter is a dense, N-dimensional matrix type. In case the type is a dense matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d1a/structblaze_1_1IsDenseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d50/structblaze_1_1IsDenseVector.html">blaze::IsDenseVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for dense vector types.This type trait tests whether or not the given template parameter is a dense, N-dimensional vector type. In case the type is a dense vector type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d50/structblaze_1_1IsDenseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d38/structblaze_1_1IsDiagonal.html">blaze::IsDiagonal&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for diagonal matrices.This type trait tests whether or not the given template parameter is a diagonal matrix type (i.e. a matrix type that is guaranteed to be diagonal at compile time). In case the type is a diagonal matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d38/structblaze_1_1IsDiagonal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d13/structblaze_1_1IsDivExpr.html">blaze::IsDivExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a division expression template.This type trait class tests whether or not the given type <em>Type</em> is a division expression template (i.e. an expression representing a vector/scalar division or a matrix/scalar division). In order to qualify as a valid division expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../dd/d46/structblaze_1_1DivExpr.html" title="Base class for all division expression templates.The DivExpr class serves as a tag for all expression...">DivExpr</a> base class. In case the given type is a valid division expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d13/structblaze_1_1IsDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d62/structblaze_1_1IsEvalExpr.html">blaze::IsEvalExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is an evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is an evaluation expression template. In order to qualify as a valid evaluation expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../db/d24/structblaze_1_1EvalExpr.html" title="Base class for all evaluation expression templates.The EvalExpr class serves as a tag for all express...">EvalExpr</a> base class. In case the given type is a valid evaluation expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d62/structblaze_1_1IsEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html">blaze::IsExpression&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is an expression template.This type trait class tests whether or not the given type <em>Type</em> is a Blaze expression template. In order to qualify as a valid expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> base class. In case the given type is a valid expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d44/structblaze_1_1IsExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db0/structblaze_1_1IsIdentity.html">blaze::IsIdentity&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for identity matrices.This type trait tests whether or not the given template parameter is an identity matrix type (i.e. a matrix type that is guaranteed to be an identity matrix at compile time). In case the type is an identity matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/db0/structblaze_1_1IsIdentity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d64/structblaze_1_1IsLower.html">blaze::IsLower&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for lower triangular matrices.This type trait tests whether or not the given template parameter is a lower triangular matrix type (i.e. a matrix type that is guaranteed to be lower triangular at compile time). This also includes lower unitriangular and strictly lower triangular matrices. In case the type is a lower triangular matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d64/structblaze_1_1IsLower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d69/structblaze_1_1IsMatAbsExpr.html">blaze::IsMatAbsExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix absolute value expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix absolute value expression template. In order to qualify as a valid matrix absolute value expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d3/d67/structblaze_1_1MatAbsExpr.html" title="Base class for all matrix absolute value expression templates.The MatAbsExpr class serves as a tag fo...">MatAbsExpr</a> base class. In case the given type is a valid matrix absolute value expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d69/structblaze_1_1IsMatAbsExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d49/structblaze_1_1IsMatEvalExpr.html">blaze::IsMatEvalExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix evaluation expression template. In order to qualify as a valid matrix evaluation expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d5/d77/structblaze_1_1MatEvalExpr.html" title="Base class for all matrix evaluation expression templates.The MatEvalExpr class serves as a tag for a...">MatEvalExpr</a> base class. In case the given type is a valid matrix evaluation expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d49/structblaze_1_1IsMatEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d11/structblaze_1_1IsMatMatAddExpr.html">blaze::IsMatMatAddExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/matrix addition expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/matrix addition expression template. In order to qualify as a valid matrix addition expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d0/dea/structblaze_1_1MatMatAddExpr.html" title="Base class for all matrix/matrix addition expression templates.The MatMatAddExpr class serves as a ta...">MatMatAddExpr</a> base class. In case the given type is a valid matrix addition expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d11/structblaze_1_1IsMatMatAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html">blaze::IsMatMatMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/matrix multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/matrix multiplication expression template. In order to qualify as a valid matrix multiplication expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d5/d0d/structblaze_1_1MatMatMultExpr.html" title="Base class for all matrix/matrix multiplication expression templates.The MatMatMultExpr class serves ...">MatMatMultExpr</a> base class. In case the given type is a valid matrix multiplication expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d07/structblaze_1_1IsMatMatSubExpr.html">blaze::IsMatMatSubExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/matrix subtraction expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/matrix subtraction expression template. In order to qualify as a valid matrix subtraction expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../db/dbd/structblaze_1_1MatMatSubExpr.html" title="Base class for all matrix/matrix subtraction expression templates.The MatMatSubExpr class serves as a...">MatMatSubExpr</a> base class. In case the given type is a valid matrix subtraction expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d07/structblaze_1_1IsMatMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d44/structblaze_1_1IsMatrix.html">blaze::IsMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for matrix types.This type trait tests whether or not the given template parameter is a N-dimensional dense or sparse matrix type. In case the type is a matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d44/structblaze_1_1IsMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd2/structblaze_1_1IsMatScalarDivExpr.html">blaze::IsMatScalarDivExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/scalar division expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/scalar division expression template. In order to qualify as a valid matrix/scalar division expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d2/dc1/structblaze_1_1MatScalarDivExpr.html" title="Base class for all matrix/scalar divsion expression templates.The MatScalarDivExpr class serves as a ...">MatScalarDivExpr</a> base class. In case the given type is a valid matrix/scalar division expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/dd2/structblaze_1_1IsMatScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/structblaze_1_1IsMatScalarMultExpr.html">blaze::IsMatScalarMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/scalar multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/scalar multiplication expression template. In order to qualify as a valid matrix/scalar multiplication expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../da/d0e/structblaze_1_1MatScalarMultExpr.html" title="Base class for all matrix/scalar multiplication expression templates.The MatScalarMultExpr class serv...">MatScalarMultExpr</a> base class. In case the given type is a valid matrix/scalar multiplication expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/db6/structblaze_1_1IsMatScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dba/structblaze_1_1IsMatSerialExpr.html">blaze::IsMatSerialExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix serial evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix serial evaluation expression template. In order to qualify as a valid matrix serial evaluation expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d6/d2f/structblaze_1_1MatSerialExpr.html" title="Base class for all matrix serial evaluation expression templates.The MatSerialExpr class serves as a ...">MatSerialExpr</a> base class. In case the given type is a valid matrix serial evaluation expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/dba/structblaze_1_1IsMatSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da5/structblaze_1_1IsMatTransExpr.html">blaze::IsMatTransExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix transposition expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix transposition expression template. In order to qualify as a valid matrix transposition expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d7/d54/structblaze_1_1MatTransExpr.html" title="Base class for all matrix transposition expression templates.The MatTransExpr class serves as a tag f...">MatTransExpr</a> base class. In case the given type is a valid matrix transposition expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/da5/structblaze_1_1IsMatTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d84/structblaze_1_1IsMatVecMultExpr.html">blaze::IsMatVecMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a matrix/vector multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a matrix/vector multiplication expression template. In order to qualify as a valid matrix/vector multiplication expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../db/de7/structblaze_1_1MatVecMultExpr.html" title="Base class for all matrix/vector multiplication expression templates.The MatVecMultExpr class serves ...">MatVecMultExpr</a> base class. In case the given type is a valid matrix/vector multiplication expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d84/structblaze_1_1IsMatVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dd3/structblaze_1_1IsMultExpr.html">blaze::IsMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a multiplication expression template (i.e. an expression representing an element-wise vector multiplication, a matrix/vector multiplication, a vector/matrix multiplication, or a matrix multiplication). In order to qualify as a valid multiplication expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../df/dfd/structblaze_1_1MultExpr.html" title="Base class for all multiplication expression templates.The MultExpr class serves as a tag for all exp...">MultExpr</a> base class. In case the given type is a valid multiplication expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/dd3/structblaze_1_1IsMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9b/structblaze_1_1IsResizable.html">blaze::IsResizable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for resizable data types.This type trait tests whether the given data type is a resizable data type. In case the data type can be resized (via the <a class="el" href="../../dd/d7a/group__matrix.html#ga651c6be92e3a13425c42f3d92cf309fc" title="Changing the size of the matrix. ">resize()</a> function), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../db/d9b/structblaze_1_1IsResizable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/df0/structblaze_1_1IsRestricted.html">blaze::IsRestricted&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types with restricted data access.This type trait tests whether the given data type has a restricted data access. Examples are the <a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html" title="Matrix adapter for lower triangular  matrices. ">LowerMatrix</a> and <a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html" title="Matrix adapter for upper triangular  matrices. ">UpperMatrix</a> adaptors that don't allow write access to the elements in the upper or lower part of the matrix, respectively. In case the data type has a restricted data access, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>. Examples:  <a href="../../df/df0/structblaze_1_1IsRestricted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da2/structblaze_1_1IsRow.html">blaze::IsRow&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for rows.This type trait tests whether or not the given template parameter is a row (i.e. dense or sparse row). In case the type is a row, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/da2/structblaze_1_1IsRow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d0a/structblaze_1_1IsRowMajorMatrix.html">blaze::IsRowMajorMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for row-major matrix types.This type trait tests whether or not the given template argument is a row-major dense or sparse matrix type (i.e., a matrix whose storage order is set to <em>true</em>). In case the type is a row-major matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d0a/structblaze_1_1IsRowMajorMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d1c/structblaze_1_1IsRowVector.html">blaze::IsRowVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for row vector types.This type trait tests whether or not the given template argument is a row dense or sparse vector type (i.e. a vector whose transposition flag is set to <a class="el" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0" title="Transpose flag for row vectors. ">blaze::rowVector</a>). In case the type is a row vector type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d1c/structblaze_1_1IsRowVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d47/structblaze_1_1IsSerialExpr.html">blaze::IsSerialExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a serial evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is a serial evaluation expression template. In order to qualify as a valid serial evaluation expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d5/d7c/structblaze_1_1SerialExpr.html" title="Base class for all serial evaluation expression templates.The SerialExpr class serves as a tag for al...">SerialExpr</a> base class. In case the given type is a valid serial evaluation expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d47/structblaze_1_1IsSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de3/structblaze_1_1IsSMPAssignable.html">blaze::IsSMPAssignable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for data types.This type trait tests whether or not the given template parameter is an SMP-assignable data type (i.e. if it is a data type that can possibly and efficiently be assigned by several threads). In this context, built-in data types as well as complex numbers are non-SMP-assignable, whereas several vector and matrix types (as for instance <a class="el" href="../../da/d9e/classblaze_1_1DynamicVector.html" title="Efficient implementation of an arbitrary sized vector.The DynamicVector class template is the represe...">DynamicVector</a> and <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a>) can be SMP-assignable. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type is SMP-assignable, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/de3/structblaze_1_1IsSMPAssignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d39/structblaze_1_1IsSparseElement.html">blaze::IsSparseElement&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a sparse element type.This type trait class tests whether or not the given type <em>Type</em> is a Blaze sparse element type, i.e. if the type implements the sparse element concept by providing a value() and an index() member function. In order to qualify as a valid sparse element type, the given type has to derive (publicly or privately) from the <a class="el" href="../../db/db5/structblaze_1_1SparseElement.html" title="Base class for all sparse element types.The SparseElement class is the base class for all sparse elem...">SparseElement</a> base class. In case the given type is a valid sparse element, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d39/structblaze_1_1IsSparseElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d80/structblaze_1_1IsSparseMatrix.html">blaze::IsSparseMatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for sparse matrix types.This type trait tests whether or not the given template parameter is a sparse, N-dimensional matrix type. In case the type is a sparse matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d80/structblaze_1_1IsSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/de1/structblaze_1_1IsSparseVector.html">blaze::IsSparseVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for sparse vector types.This type trait tests whether or not the given template parameter is a sparse, N-dimensional vector type. In case the type is a sparse vector type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/de1/structblaze_1_1IsSparseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3b/structblaze_1_1IsSquare.html">blaze::IsSquare&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for square matrices.This type trait tests whether or not the given template parameter is a square matrix type (i.e. a matrix type that is guaranteed to be square at compile time). In case the type is a square matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d3b/structblaze_1_1IsSquare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d49/structblaze_1_1IsStrictlyLower.html">blaze::IsStrictlyLower&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for strictly lower triangular matrices.This type trait tests whether or not the given template parameter is a strictly lower triangular matrix type (i.e. a matrix type that is guaranteed to be strictly lower triangular at compile time). In case the type is a strictly lower triangular matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d3/d49/structblaze_1_1IsStrictlyLower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d32/structblaze_1_1IsStrictlyTriangular.html">blaze::IsStrictlyTriangular&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for strictly triangular matrix types.This type trait tests whether or not the given template parameter is a strictly lower or upper triangular matrix type. In case the type is a triangular matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d32/structblaze_1_1IsStrictlyTriangular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/db5/structblaze_1_1IsStrictlyUpper.html">blaze::IsStrictlyUpper&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for strictly upper triangular matrices.This type trait tests whether or not the given template parameter is a strictly upper triangular matrix type (i.e. a matrix type that is guaranteed to be strictly upper triangular at compile time). In case the type is a strictly upper triangular matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/db5/structblaze_1_1IsStrictlyUpper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d3f/structblaze_1_1IsSubExpr.html">blaze::IsSubExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a subtraction expression template.This type trait class tests whether or not the given type <em>Type</em> is a subtraction expression template (i.e. an expression representing a vector subtraction or a matrix subtraction). In order to qualify as a valid subtraction expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d0/d7a/structblaze_1_1SubExpr.html" title="Base class for all subtraction expression templates.The SubExpr class serves as a tag for all express...">SubExpr</a> base class. In case the given type is a valid subtraction expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d3f/structblaze_1_1IsSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d1c/structblaze_1_1IsSubmatrix.html">blaze::IsSubmatrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for submatrices.This type trait tests whether or not the given template parameter is a submatrix (i.e. dense or sparse submatrix). In case the type is a submatrix, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/d1c/structblaze_1_1IsSubmatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9a/structblaze_1_1IsSubvector.html">blaze::IsSubvector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for subvectors.This type trait tests whether or not the given template parameter is a subvector (i.e. dense or sparse subvector). In case the type is a subvector, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d9a/structblaze_1_1IsSubvector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/db5/structblaze_1_1IsSymmetric.html">blaze::IsSymmetric&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for symmetric matrices.This type trait tests whether or not the given template parameter is a symmetric matrix type (i.e. a matrix type that is guaranteed to be symmetric at compile time). In case the type is a symmetric matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/db5/structblaze_1_1IsSymmetric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dca/structblaze_1_1IsTemporary.html">blaze::IsTemporary&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a temporary vector or matrix type.This type trait class tests whether the given type is a temporary vector or matrix type, i.e. can be used for a temporary vector or matrix. In case the given type can be used as temporary, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/dca/structblaze_1_1IsTemporary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html">blaze::IsTransExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a transposition expression template.This type trait class tests whether or not the given type <em>Type</em> is a transposition expression template (i.e. an expression representing a vector transposition or a matrix transposition). In order to qualify as a valid transposition expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../dd/dfe/structblaze_1_1TransExpr.html" title="Base class for all transposition expression templates.The TransExpr class serves as a tag for all exp...">TransExpr</a> base class. In case the given type is a valid transposition expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/d04/structblaze_1_1IsTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d73/structblaze_1_1IsTriangular.html">blaze::IsTriangular&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for triangular matrix types.This type trait tests whether or not the given template parameter is a lower or upper triangular matrix type. In case the type is a triangular matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/d73/structblaze_1_1IsTriangular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d08/structblaze_1_1IsTVecMatMultExpr.html">blaze::IsTVecMatMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/matrix multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/matrix multiplication expression template. In order to qualify as a valid vector/matrix multiplication expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d3/d25/structblaze_1_1TVecMatMultExpr.html" title="Base class for all vector/matrix multiplication expression templates.The TVecMatMultExpr class serves...">TVecMatMultExpr</a> base class. In case the given type is a valid vector/matrix multiplication expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d08/structblaze_1_1IsTVecMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d77/structblaze_1_1IsUniLower.html">blaze::IsUniLower&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for lower unitriangular matrices.This type trait tests whether or not the given template parameter is a lower unitriangular matrix type (i.e. a matrix type that is guaranteed to be lower unitriangular at compile time). In case the type is a lower unitriangular matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d77/structblaze_1_1IsUniLower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d70/structblaze_1_1IsUniTriangular.html">blaze::IsUniTriangular&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for unitriangular matrix types.This type trait tests whether or not the given template parameter is a lower or upper unitriangular matrix type. In case the type is an unitriangular matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>yes</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/d70/structblaze_1_1IsUniTriangular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/ddc/structblaze_1_1IsUniUpper.html">blaze::IsUniUpper&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for upper unitriangular matrices.This type trait tests whether or not the given template parameter is an upper unitriangular matrix type (i.e. a matrix type that is guaranteed to be upper unitriangular at compile time). In case the type is an upper unitriangular matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/ddc/structblaze_1_1IsUniUpper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d0e/structblaze_1_1IsUpper.html">blaze::IsUpper&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for upper triangular matrices.This type trait tests whether or not the given template parameter is an upper triangular matrix type (i.e. a matrix type that is guaranteed to be upper triangular at compile time). This also includes upper unitriangular and strictly upper triangular matrices. In case the type is an upper triangular matrix type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d0e/structblaze_1_1IsUpper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d39/structblaze_1_1IsVecAbsExpr.html">blaze::IsVecAbsExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector absolute value expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector absolute value expression template. In order to qualify as a valid vector absolute value expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d7/d23/structblaze_1_1VecAbsExpr.html" title="Base class for all vector absolute value expression templates.The VecAbsExpr class serves as a tag fo...">VecAbsExpr</a> base class. In case the given type is a valid vector absolute value expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d39/structblaze_1_1IsVecAbsExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d05/structblaze_1_1IsVecEvalExpr.html">blaze::IsVecEvalExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector evaluation expression template. In order to qualify as a valid vector evaluation expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../da/d95/structblaze_1_1VecEvalExpr.html" title="Base class for all vector evaluation expression templates.The VecEvalExpr class serves as a tag for a...">VecEvalExpr</a> base class. In case the given type is a valid vector evaluation expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/d05/structblaze_1_1IsVecEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da6/structblaze_1_1IsVecScalarDivExpr.html">blaze::IsVecScalarDivExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/scalar division expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/scalar division expression template. In order to qualify as a valid vector/scalar division expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../da/dbf/structblaze_1_1VecScalarDivExpr.html" title="Base class for all vector/scalar division expression templates.The VecScalarDivExpr class serves as a...">VecScalarDivExpr</a> base class. In case the given type is a valid vector/scalar division expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/da6/structblaze_1_1IsVecScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da8/structblaze_1_1IsVecScalarMultExpr.html">blaze::IsVecScalarMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/scalar multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/scalar multiplication expression template. In order to qualify as a valid vector/scalar multiplication expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../df/d01/structblaze_1_1VecScalarMultExpr.html" title="Base class for all vector/scalar multiplication expression templates.The VecScalarMultExpr class serv...">VecScalarMultExpr</a> base class. In case the given type is a valid vector/scalar multiplication expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/da8/structblaze_1_1IsVecScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d59/structblaze_1_1IsVecSerialExpr.html">blaze::IsVecSerialExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector serial evaluation expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector serial evaluation expression template. In order to qualify as a valid vector serial evaluation expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d8/dfb/structblaze_1_1VecSerialExpr.html" title="Base class for all vector serial evaluation expression templates.The VecSerialExpr class serves as a ...">VecSerialExpr</a> base class. In case the given type is a valid vector serial evaluation expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d59/structblaze_1_1IsVecSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de4/structblaze_1_1IsVector.html">blaze::IsVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for vector types.This type trait tests whether or not the given template parameter is a N-dimensional dense or sparse vector type. In case the type is a vector type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/de4/structblaze_1_1IsVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d3d/structblaze_1_1IsVecTransExpr.html">blaze::IsVecTransExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector transposition expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector transposition expression template. In order to qualify as a valid vector transposition expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d0/dec/structblaze_1_1VecTransExpr.html" title="Base class for all vector transposition expression templates.The VecTransExpr class serves as a tag f...">VecTransExpr</a> base class. In case the given type is a valid vector transposition expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d3d/structblaze_1_1IsVecTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d17/structblaze_1_1IsVecTVecMultExpr.html">blaze::IsVecTVecMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is an outer product expression template.This type trait class tests whether or not the given type <em>Type</em> is an outer product expression template (i.e. an expression representing the multiplication between a column vector and a row vector). In order to qualify as a valid outer product expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../de/d08/structblaze_1_1VecTVecMultExpr.html" title="Base class for all outer product expression templates.The VecTVecMultExpr class serves as a tag for a...">VecTVecMultExpr</a> base class. In case the given type is a valid outer product expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d17/structblaze_1_1IsVecTVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dae/structblaze_1_1IsVecVecAddExpr.html">blaze::IsVecVecAddExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/vector addition expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/vector addition expression template. In order to qualify as a valid vector addition expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d0/d58/structblaze_1_1VecVecAddExpr.html" title="Base class for all vector/vector addition expression templates.The VecVecAddExpr class serves as a ta...">VecVecAddExpr</a> base class. In case the given type is a valid vector addition expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/dae/structblaze_1_1IsVecVecAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d79/structblaze_1_1IsVecVecMultExpr.html">blaze::IsVecVecMultExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/vector multiplication expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/vector multiplication expression template. In order to qualify as a valid vector multiplication expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../df/d10/structblaze_1_1VecVecMultExpr.html" title="Base class for all vector/vector multiplication expression templates.The VecVecMultExpr class serves ...">VecVecMultExpr</a> base class. In case the given type is a valid vector multiplication expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d79/structblaze_1_1IsVecVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d16/structblaze_1_1IsVecVecSubExpr.html">blaze::IsVecVecSubExpr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the given type is a vector/vector subtraction expression template.This type trait class tests whether or not the given type <em>Type</em> is a vector/vector subtraction expression template. In order to qualify as a valid vector subtraction expression template, the given type has to derive (publicly or privately) from the <a class="el" href="../../d1/d87/structblaze_1_1VecVecSubExpr.html" title="Base class for all vector/vector subtraction expression templates.The VecVecSubExpr class serves as a...">VecVecSubExpr</a> base class. In case the given type is a valid vector subtraction expression template, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d16/structblaze_1_1IsVecVecSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbb/structblaze_1_1IsView.html">blaze::IsView&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for views.This type trait tests whether or not the given template parameter is a view (i.e. subvector, submatrix, row, column, ...). In case the type is a view, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/dbb/structblaze_1_1IsView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d38/structblaze_1_1NumericElementType.html">blaze::NumericElementType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the numeric element type of a given data type.Via this type trait it is possible to evaluate the numeric (fundamental or complex) element type at the heart of a given data type. Examples:  <a href="../../da/d38/structblaze_1_1NumericElementType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html">blaze::RemoveAdaptor&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of top level adaptor types.In case the given type is an adaptor type (<a class="el" href="../../d4/dab/classblaze_1_1SymmetricMatrix.html" title="Matrix adapter for symmetric  matrices. ">SymmetricMatrix</a>, <a class="el" href="../../da/ddf/classblaze_1_1LowerMatrix.html" title="Matrix adapter for lower triangular  matrices. ">LowerMatrix</a>, <a class="el" href="../../d5/daf/classblaze_1_1UpperMatrix.html" title="Matrix adapter for upper triangular  matrices. ">UpperMatrix</a>, ...), the <a class="el" href="../../d2/d34/structblaze_1_1RemoveAdaptor.html" title="Removal of top level adaptor types.In case the given type is an adaptor type (SymmetricMatrix, LowerMatrix, UpperMatrix, ...), the RemoveAdaptor type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved. ">RemoveAdaptor</a> type trait removes the adaptor and extracts the contained general matrix type. Else the given type is returned as is. Note that cv-qualifiers are preserved.  <a href="../../d2/d34/structblaze_1_1RemoveAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df1/structblaze_1_1RequiresEvaluation.html">blaze::RequiresEvaluation&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check to query the requirement to evaluate an expression.Via this type trait it is possible to determine whether a given vector or matrix expression type requires an intermediate evaluation in the context of a compound expression. In case the given type requires an evaluation, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/df1/structblaze_1_1RequiresEvaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/structblaze_1_1Rows.html">blaze::Rows&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time evaluation of the number of rows of a matrix.The <a class="el" href="../../d2/d38/structblaze_1_1Rows.html" title="Compile time evaluation of the number of rows of a matrix.The Rows type trait evaluates the number of...">Rows</a> type trait evaluates the number of rows of the given matrix type at compile time. In case the given type <em>T</em> is a matrix type with a fixed number of rows (e.g. <a class="el" href="../../d3/dd3/classblaze_1_1StaticMatrix.html" title="Efficient implementation of a fixed-sized matrix.The StaticMatrix class template is the representatio...">StaticMatrix</a>), the <em>value</em> member constant is set to the according number of rows. In all other cases, <em>value</em> is set to 0.  <a href="../../d2/d38/structblaze_1_1Rows.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d5d/structblaze_1_1Size.html">blaze::Size&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time evaluation of the size of a vector.The <a class="el" href="../../df/d5d/structblaze_1_1Size.html" title="Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...">Size</a> type trait evaluates the size of the given vector type at compile time. In case the given type <em>T</em> is a vector type with a fixed size (e.g. <a class="el" href="../../d9/d3c/classblaze_1_1StaticVector.html" title="Efficient implementation of a fixed-sized vector.The StaticVector class template is the representatio...">StaticVector</a>), the <em>value</em> member constant is set to the according size. In all other cases, <em>value</em> is set to 0.  <a href="../../df/d5d/structblaze_1_1Size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae78e84ad2d4754c61849fea6f655bc3c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d7b/group__math__type__traits.html#gae78e84ad2d4754c61849fea6f655bc3c">BLAZE_CREATE_GET_TYPE_MEMBER_TYPE_TRAIT</a>(TYPE_TRAIT_NAME,  MEMBER_NAME,  FALLBACK_TYPE)</td></tr>
<tr class="memdesc:gae78e84ad2d4754c61849fea6f655bc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the creation of a type trait to acquire member types.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine a specified member type of a given type. The first macro parameter <em>TYPE_TRAIT_NAME</em> specifies the resulting name of the type trait. The second parameter <em>MEMBER_NAME</em> specifies the name of the member type to be acquired and the third parameter <em>FALLBACK_TYPE</em> specifies the type to acquire in case the given type doesn't contain the specified member type. The following example demonstrates the use of the macro and the resulting type trait:  <a href="#gae78e84ad2d4754c61849fea6f655bc3c">More...</a><br /></td></tr>
<tr class="separator:gae78e84ad2d4754c61849fea6f655bc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d6498ed642ed01877d13b18f0018f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d7b/group__math__type__traits.html#ga82d6498ed642ed01877d13b18f0018f3">BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT</a>(TYPE_TRAIT_NAME,  MEMBER_NAME)</td></tr>
<tr class="memdesc:ga82d6498ed642ed01877d13b18f0018f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the creation of a type trait for compile time checks for member data and functions.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine whether the specified element <em>MEMBER_NAME</em> is a data or function member of a given type. The following example demonstrates the use of the macro and the resulting type trait:  <a href="#ga82d6498ed642ed01877d13b18f0018f3">More...</a><br /></td></tr>
<tr class="separator:ga82d6498ed642ed01877d13b18f0018f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7fd093b1a136bd309fe16f1131cd696"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</a>(TYPE_TRAIT_NAME,  MEMBER_NAME)</td></tr>
<tr class="memdesc:gab7fd093b1a136bd309fe16f1131cd696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the creation of a type trait for compile time checks for member types.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine whether the specified element <em>MEMBER_NAME</em> is a type member of a given type. The following example demonstrates the use of the macro and the resulting type trait:  <a href="#gab7fd093b1a136bd309fe16f1131cd696">More...</a><br /></td></tr>
<tr class="separator:gab7fd093b1a136bd309fe16f1131cd696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9becd5ca22b660221bf10e0709f4c5f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d7b/group__math__type__traits.html#ga9becd5ca22b660221bf10e0709f4c5f9">BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT</a>(TYPE_TRAIT_NAME,  MEMBER_NAME)</td></tr>
<tr class="memdesc:ga9becd5ca22b660221bf10e0709f4c5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the creation of a type trait for compile time checks for members.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine whether the specified element <em>MEMBER_NAME</em> is a data, function, or type member of a given type. The following example demonstrates the use of the macro and the resulting type trait:  <a href="#ga9becd5ca22b660221bf10e0709f4c5f9">More...</a><br /></td></tr>
<tr class="separator:ga9becd5ca22b660221bf10e0709f4c5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gae78e84ad2d4754c61849fea6f655bc3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CREATE_GET_TYPE_MEMBER_TYPE_TRAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPE_TRAIT_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MEMBER_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FALLBACK_TYPE&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">\</div>
<div class="line">template&lt; typename Type1233 &gt;                                                                   \</div>
<div class="line">struct TYPE_TRAIT_NAME                                                                          \</div>
<div class="line">{                                                                                               \</div>
<div class="line"> private:                                                                                       \</div>
<div class="line">   struct SUCCESS { <span class="keyword">typedef</span> <span class="keyword">typename</span> Type1233::MEMBER_NAME  Type; };                            \</div>
<div class="line">   struct FAILURE { <span class="keyword">typedef</span> FALLBACK_TYPE  Type; };                                             <a class="code" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">\</a></div>
<div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">                                                                                                \</a></div>
<div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">   BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</a>( LOCAL_TYPE_TRAIT, MEMBER_NAME );                    \</div>
<div class="line">                                                                                                \</div>
<div class="line"> public:                                                                                        \</div>
<div class="line">   typedef <span class="keyword">typename</span> <a class="code" href="../../d7/d0c/structblaze_1_1If.html">blaze::If&lt; LOCAL_TYPE_TRAIT&lt;Type1233&gt;</a>                                       \</div>
<div class="line">                             , SUCCESS                                                          \</div>
<div class="line">                             , FAILURE                                                          \</div>
<div class="line">                             &gt;::Type::Type  Type;                                               \</div>
<div class="line">};</div>
<div class="ttc" id="structblaze_1_1If_html"><div class="ttname"><a href="../../d7/d0c/structblaze_1_1If.html">blaze::If</a></div><div class="ttdoc">Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...</div><div class="ttdef"><b>Definition:</b> If.h:112</div></div>
<div class="ttc" id="group__math__type__traits_html_gab7fd093b1a136bd309fe16f1131cd696"><div class="ttname"><a href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</a></div><div class="ttdeci">#define BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT(TYPE_TRAIT_NAME, MEMBER_NAME)</div><div class="ttdoc">Macro for the creation of a type trait for compile time checks for member types.This macro creates th...</div><div class="ttdef"><b>Definition:</b> HasMember.h:187</div></div>
</div><!-- fragment -->
<p>Macro for the creation of a type trait to acquire member types.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine a specified member type of a given type. The first macro parameter <em>TYPE_TRAIT_NAME</em> specifies the resulting name of the type trait. The second parameter <em>MEMBER_NAME</em> specifies the name of the member type to be acquired and the third parameter <em>FALLBACK_TYPE</em> specifies the type to acquire in case the given type doesn't contain the specified member type. The following example demonstrates the use of the macro and the resulting type trait: </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct MyType1 {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;   typedef float  ElementType;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;};</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;struct MyType2 {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   typedef double  ElementType;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;};</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;struct MyType3 {};</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;BLAZE_CREATE_GET_TYPE_MEMBER_TYPE_TRAIT( GetElementType, ElementType, int );</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;GetElementType&lt;MyType1&gt;::Type  // Results in &#39;float&#39;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;GetElementType&lt;MyType2&gt;::Type  // Results in &#39;double&#39;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;GetElementType&lt;MyType3&gt;::Type  // Results in &#39;int&#39;</div>
</div><!-- fragment --><p>The macro results in the definition of a new class with the specified name <em>TYPE_TRAIT_NAME</em> within the current namespace. This may cause name collisions with any other entity called <em>TYPE_TRAIT_NAME</em> in the same namespace. Therefore it is advisable to create the type trait as locally as possible to minimize the probability of name collisions. Note however that the macro cannot be used within function scope since a template declaration cannot appear at block scope.</p>
<p>Please note that due to an error in the Intel compilers prior to version 14.0 the type trait generated from this macro does NOT work properly, i.e. will not correctly determine whether the specified element is a type member of the given type! </p>

</div>
</div>
<a class="anchor" id="ga82d6498ed642ed01877d13b18f0018f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPE_TRAIT_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MEMBER_NAME&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the creation of a type trait for compile time checks for member data and functions.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine whether the specified element <em>MEMBER_NAME</em> is a data or function member of a given type. The following example demonstrates the use of the macro and the resulting type trait: </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;class MyType {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; public:</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   void publicCompute();</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; private:</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   void privateCompute();</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   int value_;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;};</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT( HasPublicCompute , publicCompute  );</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT( HasPrivateCompute, privateCompute );</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT( HasValue         , value_         );</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT( HasEvaluate , evalute   );</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT( HasDetermine, determine );</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT( HasData     , data_     );</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;HasPublicCompute&lt;MyType&gt;::value  // Evaluates to 1</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;HasPrivateCompute&lt;MyType&gt;::Type  // Results in TrueType</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;HasValue&lt;MyType&gt;                 // Is derived from TrueType</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;HasEvaluate&lt;MyType&gt;::value       // Evaluates to 0</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;HasDetermine&lt;MyType&gt;::Type       // Results in FalseType</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;HasData&lt;MyType&gt;                  // Is derived from FalseType</div>
</div><!-- fragment --><p>The macro results in the definition of a new class with the specified name <em>TYPE_TRAIT_NAME</em> within the current namespace. This may cause name collisions with any other entity called <em>TYPE_TRAIT_NAME</em> in the same namespace. Therefore it is advisable to create the type trait as locally as possible to minimize the probability of name collisions. Note however that the macro cannot be used within function scope since a template declaration cannot appear at block scope. </p>

</div>
</div>
<a class="anchor" id="ga9becd5ca22b660221bf10e0709f4c5f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPE_TRAIT_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MEMBER_NAME&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">\</div>
<div class="line">template&lt; typename Type1232 &gt;                                                                    \</div>
<div class="line">struct TYPE_TRAIT_NAME##HELPER                                                                   \</div>
<div class="line">{                                                                                                \</div>
<div class="line"> private:                                                                                        <a class="code" href="../../df/d7b/group__math__type__traits.html#ga82d6498ed642ed01877d13b18f0018f3">\</a></div>
<div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#ga82d6498ed642ed01877d13b18f0018f3">   BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT</a>( LOCAL_TYPE_TRAIT_1, MEMBER_NAME );       <a class="code" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">\</a></div>
<div class="line"><a class="code" href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">   BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</a>( LOCAL_TYPE_TRAIT_2, MEMBER_NAME );                   \</div>
<div class="line">                                                                                                 \</div>
<div class="line"> public:                                                                                         \</div>
<div class="line">   enum { value = LOCAL_TYPE_TRAIT_1&lt;Type1232&gt;::value || LOCAL_TYPE_TRAIT_2&lt;Type1232&gt;::value };  \</div>
<div class="line">   typedef <span class="keyword">typename</span> <a class="code" href="../../da/dc1/structblaze_1_1SelectType.html">blaze::SelectType&lt;value,blaze::TrueType,blaze::FalseType&gt;::Type</a>  Type;       \</div>
<div class="line">};                                                                                               \</div>
<div class="line">                                                                                                 \</div>
<div class="line">template&lt; typename Type1232 &gt;                                                                    \</div>
<div class="line">struct TYPE_TRAIT_NAME : <span class="keyword">public</span> TYPE_TRAIT_NAME##HELPER&lt;Type1232&gt;::Type                          \</div>
<div class="line">{                                                                                                \</div>
<div class="line"> public:                                                                                         \</div>
<div class="line">   enum { value = TYPE_TRAIT_NAME##HELPER&lt;Type1232&gt;::value };                                    \</div>
<div class="line">   typedef <span class="keyword">typename</span> TYPE_TRAIT_NAME##HELPER&lt;Type1232&gt;::Type  Type;                               \</div>
<div class="line">};</div>
<div class="ttc" id="group__math__type__traits_html_ga82d6498ed642ed01877d13b18f0018f3"><div class="ttname"><a href="../../df/d7b/group__math__type__traits.html#ga82d6498ed642ed01877d13b18f0018f3">BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT</a></div><div class="ttdeci">#define BLAZE_CREATE_HAS_DATA_OR_FUNCTION_MEMBER_TYPE_TRAIT(TYPE_TRAIT_NAME, MEMBER_NAME)</div><div class="ttdoc">Macro for the creation of a type trait for compile time checks for member data and functions...</div><div class="ttdef"><b>Definition:</b> HasMember.h:100</div></div>
<div class="ttc" id="group__math__type__traits_html_gab7fd093b1a136bd309fe16f1131cd696"><div class="ttname"><a href="../../df/d7b/group__math__type__traits.html#gab7fd093b1a136bd309fe16f1131cd696">BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</a></div><div class="ttdeci">#define BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT(TYPE_TRAIT_NAME, MEMBER_NAME)</div><div class="ttdoc">Macro for the creation of a type trait for compile time checks for member types.This macro creates th...</div><div class="ttdef"><b>Definition:</b> HasMember.h:187</div></div>
<div class="ttc" id="structblaze_1_1SelectType_html"><div class="ttname"><a href="../../da/dc1/structblaze_1_1SelectType.html">blaze::SelectType</a></div><div class="ttdoc">Compile time type selection.The SelectType class template selects one of the two given types T1 and T...</div><div class="ttdef"><b>Definition:</b> SelectType.h:59</div></div>
</div><!-- fragment -->
<p>Macro for the creation of a type trait for compile time checks for members.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine whether the specified element <em>MEMBER_NAME</em> is a data, function, or type member of a given type. The following example demonstrates the use of the macro and the resulting type trait: </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;class MyType {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; public:</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   void publicCompute();</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; protected:</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   typedef float  ProtectedType;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160; private:</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   int value_;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;};</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT( HasCompute      , publicCompute );</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT( HasProtectedType, ProtectedType );</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT( HasValue        , value_        );</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT( HasPublicType, PublicType );</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT( HasDetermine , determine  );</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;BLAZE_CREATE_HAS_MEMBER_TYPE_TRAIT( HasData      , data_      );</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;HasCompute&lt;MyType&gt;::value       // Evaluates to 1</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;HasProtectedType&lt;MyType&gt;::Type  // Results in TrueType</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;HasValue&lt;MyType&gt;                // Is derived from TrueType</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;HasPublicType&lt;MyType&gt;::value    // Evaluates to 0</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;HasDetermine&lt;MyType&gt;::Type      // Results in FalseType</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;HasData&lt;MyType&gt;                 // Is derived from FalseType</div>
</div><!-- fragment --><p>The macro results in the definition of a new class with the specified name <em>TYPE_TRAIT_NAME</em> within the current namespace. This may cause name collisions with any other entity called <em>TYPE_TRAIT_NAME</em> in the same namespace. Therefore it is advisable to create the type trait as locally as possible to minimize the probability of name collisions. Note however that the macro cannot be used within function scope since a template declaration cannot appear at block scope.</p>
<p>Please note that due to an error in the Intel compilers prior to version 14.0 the type trait generated from this macro does NOT work properly, i.e. will not correctly determine whether the specified element is a type member of the given type! </p>

</div>
</div>
<a class="anchor" id="gab7fd093b1a136bd309fe16f1131cd696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPE_TRAIT_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MEMBER_NAME&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the creation of a type trait for compile time checks for member types.This macro creates the definition of a type trait <em>TYPE_TRAIT_NAME</em> that can determine whether the specified element <em>MEMBER_NAME</em> is a type member of a given type. The following example demonstrates the use of the macro and the resulting type trait: </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;class MyType {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; public:</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   typedef int  PublicType;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; protected:</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   typedef float  ProtectedType;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160; private:</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   typedef double  PrivateType;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;};</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT( HasPublicType   , PublicType    );</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT( HasProtectedType, ProtectedType );</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT( HasPrivateType  , PrivateType   );</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT( HasValueType  , ValueType    );</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT( HasElementType, ElementTypeType );</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;BLAZE_CREATE_HAS_TYPE_MEMBER_TYPE_TRAIT( HasDataType   , DataType   );</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;HasPublicType&lt;MyType&gt;::value    // Evaluates to 1</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;HasProtectedType&lt;MyType&gt;::Type  // Results in TrueType</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;HasPrivateType&lt;MyType&gt;          // Is derived from TrueType</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;HasValueType&lt;MyType&gt;::value     // Evaluates to 0</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;HasElementType&lt;MyType&gt;::Type    // Results in FalseType</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;HasDataType&lt;MyType&gt;             // Is derived from FalseType</div>
</div><!-- fragment --><p>The macro results in the definition of a new class with the specified name <em>TYPE_TRAIT_NAME</em> within the current namespace. This may cause name collisions with any other entity called <em>TYPE_TRAIT_NAME</em> in the same namespace. Therefore it is advisable to create the type trait as locally as possible to minimize the probability of name collisions. Note however that the macro cannot be used within function scope since a template declaration cannot appear at block scope.</p>
<p>Please note that due to an error in the Intel compilers prior to version 14.0 the type trait generated from this macro does NOT work properly, i.e. will not correctly determine whether the specified element is a type member of the given type! </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:55:21 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
