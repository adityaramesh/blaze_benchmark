<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Dense Vectors</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Dense Vectors<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../dc/dcf/group__vector.html">Vectors</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:dd/da3/group__dynamic__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da3/group__dynamic__vector.html">DynamicVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/dc9/group__hybrid__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/group__hybrid__vector.html">HybridVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/d95/group__static__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d95/group__static__vector.html">StaticVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/d95/group__dense__vector__expression"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d95/group__dense__vector__expression.html">Expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">blaze::DenseVector&lt; VT, TF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for N-dimensional dense vectors.The <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html" title="Base class for N-dimensional dense vectors.The DenseVector class is a base class for all arbitrarily ...">DenseVector</a> class is a base class for all arbitrarily sized (N-dimensional) dense vectors. It provides an abstraction from the actual type of the dense vector, but enables a conversion back to this type via the <a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> base class.  <a href="../../d1/db2/structblaze_1_1DenseVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga772dd5fcf447845bc8fcc3ac8cf1ad86"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga772dd5fcf447845bc8fcc3ac8cf1ad86"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf&lt; IsMatMatMultExpr&lt; T1 &gt;, DMatDVecMultExpr&lt; T1, T2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga772dd5fcf447845bc8fcc3ac8cf1ad86">blaze::operator*</a> (const DenseMatrix&lt; T1, false &gt; &amp;mat, const DenseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga772dd5fcf447845bc8fcc3ac8cf1ad86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_113.png"/>).  <a href="#ga772dd5fcf447845bc8fcc3ac8cf1ad86">More...</a><br /></td></tr>
<tr class="separator:ga772dd5fcf447845bc8fcc3ac8cf1ad86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880d32b0bd1a512a5070da4a2c725b17"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga880d32b0bd1a512a5070da4a2c725b17"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsMatMatMultExpr&lt; T1 &gt;, typename MultExprTrait&lt; T1, T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga880d32b0bd1a512a5070da4a2c725b17">blaze::operator*</a> (const DenseMatrix&lt; T1, SO &gt; &amp;mat, const DenseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga880d32b0bd1a512a5070da4a2c725b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a dense matrix-matrix multiplication expression and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_114.png"/>).  <a href="#ga880d32b0bd1a512a5070da4a2c725b17">More...</a><br /></td></tr>
<tr class="separator:ga880d32b0bd1a512a5070da4a2c725b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb43cb214c53128145e6800bcf445a61"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gacb43cb214c53128145e6800bcf445a61"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf&lt; Or&lt; IsSymmetric&lt; T1 &gt;, IsMatMatMultExpr&lt; T1 &gt; &gt;, DMatSVecMultExpr&lt; T1, T2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gacb43cb214c53128145e6800bcf445a61">blaze::operator*</a> (const DenseMatrix&lt; T1, false &gt; &amp;mat, const SparseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gacb43cb214c53128145e6800bcf445a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_113.png"/>).  <a href="#gacb43cb214c53128145e6800bcf445a61">More...</a><br /></td></tr>
<tr class="separator:gacb43cb214c53128145e6800bcf445a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cc328e0a8995b75b93180c8dfbd2757"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga0cc328e0a8995b75b93180c8dfbd2757"><td class="memTemplItemLeft" align="right" valign="top">const DVecAbsExpr&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0cc328e0a8995b75b93180c8dfbd2757">blaze::abs</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga0cc328e0a8995b75b93180c8dfbd2757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the absolute values of each single element of <em>dv</em>.  <a href="#ga0cc328e0a8995b75b93180c8dfbd2757">More...</a><br /></td></tr>
<tr class="separator:ga0cc328e0a8995b75b93180c8dfbd2757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacade1745b146d7c63876fdd2bd755ce6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gacade1745b146d7c63876fdd2bd755ce6"><td class="memTemplItemLeft" align="right" valign="top">const DVecDVecAddExpr&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gacade1745b146d7c63876fdd2bd755ce6">blaze::operator+</a> (const DenseVector&lt; T1, TF &gt; &amp;lhs, const DenseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gacade1745b146d7c63876fdd2bd755ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_120.png"/>).  <a href="#gacade1745b146d7c63876fdd2bd755ce6">More...</a><br /></td></tr>
<tr class="separator:gacade1745b146d7c63876fdd2bd755ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa687a75e64beca784394faf86435249c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa687a75e64beca784394faf86435249c"><td class="memTemplItemLeft" align="right" valign="top">const DVecDVecCrossExpr&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa687a75e64beca784394faf86435249c">blaze::operator%</a> (const DenseVector&lt; T1, false &gt; &amp;lhs, const DenseVector&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa687a75e64beca784394faf86435249c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_121.png"/>).  <a href="#gaa687a75e64beca784394faf86435249c">More...</a><br /></td></tr>
<tr class="separator:gaa687a75e64beca784394faf86435249c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a0127d216ecef466edad068782d9e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaf6a0127d216ecef466edad068782d9e4"><td class="memTemplItemLeft" align="right" valign="top">const DVecDVecMultExpr&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaf6a0127d216ecef466edad068782d9e4">blaze::operator*</a> (const DenseVector&lt; T1, TF &gt; &amp;lhs, const DenseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf6a0127d216ecef466edad068782d9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the componentwise product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_123.png"/>).  <a href="#gaf6a0127d216ecef466edad068782d9e4">More...</a><br /></td></tr>
<tr class="separator:gaf6a0127d216ecef466edad068782d9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0d441ba5993e9b6df62c534cec34c9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gafd0d441ba5993e9b6df62c534cec34c9"><td class="memTemplItemLeft" align="right" valign="top">const DVecDVecSubExpr&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gafd0d441ba5993e9b6df62c534cec34c9">blaze::operator-</a> (const DenseVector&lt; T1, TF &gt; &amp;lhs, const DenseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gafd0d441ba5993e9b6df62c534cec34c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_124.png"/>).  <a href="#gafd0d441ba5993e9b6df62c534cec34c9">More...</a><br /></td></tr>
<tr class="separator:gafd0d441ba5993e9b6df62c534cec34c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9e162d0ea6b3e4493b9666c6730d690"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gab9e162d0ea6b3e4493b9666c6730d690"><td class="memTemplItemLeft" align="right" valign="top">const DVecEvalExpr&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gab9e162d0ea6b3e4493b9666c6730d690">blaze::eval</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gab9e162d0ea6b3e4493b9666c6730d690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the evaluation of the given dense vector expression <em>dv</em>.  <a href="#gab9e162d0ea6b3e4493b9666c6730d690">More...</a><br /></td></tr>
<tr class="separator:gab9e162d0ea6b3e4493b9666c6730d690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf999762b08a3bd281375b5e900ebfac8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaf999762b08a3bd281375b5e900ebfac8"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsNumeric&lt; T2 &gt;, typename DivExprTrait&lt; T1, T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaf999762b08a3bd281375b5e900ebfac8">blaze::operator/</a> (const DenseVector&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:gaf999762b08a3bd281375b5e900ebfac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for the divison of a dense vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_125.png"/>).  <a href="#gaf999762b08a3bd281375b5e900ebfac8">More...</a><br /></td></tr>
<tr class="separator:gaf999762b08a3bd281375b5e900ebfac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74b6a05f757de44c4daf52b23538cfaf"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga74b6a05f757de44c4daf52b23538cfaf"><td class="memTemplItemLeft" align="right" valign="top">const DVecScalarMultExpr&lt; VT, typename BaseElementType&lt; VT &gt;::Type, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga74b6a05f757de44c4daf52b23538cfaf">blaze::operator-</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga74b6a05f757de44c4daf52b23538cfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator for the negation of a dense vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_126.png"/>).  <a href="#ga74b6a05f757de44c4daf52b23538cfaf">More...</a><br /></td></tr>
<tr class="separator:ga74b6a05f757de44c4daf52b23538cfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a5cc3fa262a06eeba8ab4f0d4c3777e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga4a5cc3fa262a06eeba8ab4f0d4c3777e"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsNumeric&lt; T2 &gt;, typename MultExprTrait&lt; T1, T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4a5cc3fa262a06eeba8ab4f0d4c3777e">blaze::operator*</a> (const DenseVector&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga4a5cc3fa262a06eeba8ab4f0d4c3777e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a dense vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_72.png"/>).  <a href="#ga4a5cc3fa262a06eeba8ab4f0d4c3777e">More...</a><br /></td></tr>
<tr class="separator:ga4a5cc3fa262a06eeba8ab4f0d4c3777e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6096b0a74a5fbf88317a167bc29fa61"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gac6096b0a74a5fbf88317a167bc29fa61"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsNumeric&lt; T1 &gt;, typename MultExprTrait&lt; T1, T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac6096b0a74a5fbf88317a167bc29fa61">blaze::operator*</a> (T1 scalar, const DenseVector&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:gac6096b0a74a5fbf88317a167bc29fa61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a scalar value and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_127.png"/>).  <a href="#gac6096b0a74a5fbf88317a167bc29fa61">More...</a><br /></td></tr>
<tr class="separator:gac6096b0a74a5fbf88317a167bc29fa61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a1d35bad76c6eb7ade972e00ffd6f27"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga1a1d35bad76c6eb7ade972e00ffd6f27"><td class="memTemplItemLeft" align="right" valign="top">const DVecSerialExpr&lt; VT, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga1a1d35bad76c6eb7ade972e00ffd6f27">blaze::serial</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga1a1d35bad76c6eb7ade972e00ffd6f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the serial evaluation of the given dense vector expression <em>dv</em>.  <a href="#ga1a1d35bad76c6eb7ade972e00ffd6f27">More...</a><br /></td></tr>
<tr class="separator:ga1a1d35bad76c6eb7ade972e00ffd6f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac46fecdd6785f66d7521f88db40dd1b9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gac46fecdd6785f66d7521f88db40dd1b9"><td class="memTemplItemLeft" align="right" valign="top">const DVecSVecAddExpr&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac46fecdd6785f66d7521f88db40dd1b9">blaze::operator+</a> (const DenseVector&lt; T1, TF &gt; &amp;lhs, const SparseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac46fecdd6785f66d7521f88db40dd1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_120.png"/>).  <a href="#gac46fecdd6785f66d7521f88db40dd1b9">More...</a><br /></td></tr>
<tr class="separator:gac46fecdd6785f66d7521f88db40dd1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga362d09a6d64deafb689d21a6f7559c78"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga362d09a6d64deafb689d21a6f7559c78"><td class="memTemplItemLeft" align="right" valign="top">const DVecSVecAddExpr&lt; T2, T1, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga362d09a6d64deafb689d21a6f7559c78">blaze::operator+</a> (const SparseVector&lt; T1, TF &gt; &amp;lhs, const DenseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga362d09a6d64deafb689d21a6f7559c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for the addition of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_120.png"/>).  <a href="#ga362d09a6d64deafb689d21a6f7559c78">More...</a><br /></td></tr>
<tr class="separator:ga362d09a6d64deafb689d21a6f7559c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff63460a43ecf99ed5dc7c51cd505f04"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaff63460a43ecf99ed5dc7c51cd505f04"><td class="memTemplItemLeft" align="right" valign="top">const DVecSVecCrossExpr&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaff63460a43ecf99ed5dc7c51cd505f04">blaze::operator%</a> (const DenseVector&lt; T1, false &gt; &amp;lhs, const SparseVector&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaff63460a43ecf99ed5dc7c51cd505f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_121.png"/>).  <a href="#gaff63460a43ecf99ed5dc7c51cd505f04">More...</a><br /></td></tr>
<tr class="separator:gaff63460a43ecf99ed5dc7c51cd505f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="memTemplItemLeft" align="right" valign="top">const DVecSVecSubExpr&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4d9d2740625e6b7d83d77e0284ae21e4">blaze::operator-</a> (const DenseVector&lt; T1, TF &gt; &amp;lhs, const SparseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_124.png"/>).  <a href="#ga4d9d2740625e6b7d83d77e0284ae21e4">More...</a><br /></td></tr>
<tr class="separator:ga4d9d2740625e6b7d83d77e0284ae21e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e5a90bbef3aed0d646c7658e9130252"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga6e5a90bbef3aed0d646c7658e9130252"><td class="memTemplItemLeft" align="right" valign="top">const DVecTransExpr&lt; VT,!TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga6e5a90bbef3aed0d646c7658e9130252">blaze::trans</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga6e5a90bbef3aed0d646c7658e9130252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the transpose of the given dense vector.  <a href="#ga6e5a90bbef3aed0d646c7658e9130252">More...</a><br /></td></tr>
<tr class="separator:ga6e5a90bbef3aed0d646c7658e9130252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e3b97cb2cb32f3037b4cb0b82d30bb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa2e3b97cb2cb32f3037b4cb0b82d30bb"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf&lt; IsMatMatMultExpr&lt; T1 &gt;, SMatDVecMultExpr&lt; T1, T2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa2e3b97cb2cb32f3037b4cb0b82d30bb">blaze::operator*</a> (const SparseMatrix&lt; T1, false &gt; &amp;mat, const DenseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gaa2e3b97cb2cb32f3037b4cb0b82d30bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a row-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_113.png"/>).  <a href="#gaa2e3b97cb2cb32f3037b4cb0b82d30bb">More...</a><br /></td></tr>
<tr class="separator:gaa2e3b97cb2cb32f3037b4cb0b82d30bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga718165dc7d2fdb2157449fc3753d8990"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool SO, typename T2 &gt; </td></tr>
<tr class="memitem:ga718165dc7d2fdb2157449fc3753d8990"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsMatMatMultExpr&lt; T1 &gt;, typename MultExprTrait&lt; T1, T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga718165dc7d2fdb2157449fc3753d8990">blaze::operator*</a> (const SparseMatrix&lt; T1, SO &gt; &amp;mat, const DenseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga718165dc7d2fdb2157449fc3753d8990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a sparse matrix-matrix multiplication expression and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_114.png"/>).  <a href="#ga718165dc7d2fdb2157449fc3753d8990">More...</a><br /></td></tr>
<tr class="separator:ga718165dc7d2fdb2157449fc3753d8990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26f9406627cf1059b01755eb635e1f2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae26f9406627cf1059b01755eb635e1f2"><td class="memTemplItemLeft" align="right" valign="top">const SVecDVecCrossExpr&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae26f9406627cf1059b01755eb635e1f2">blaze::operator%</a> (const SparseVector&lt; T1, false &gt; &amp;lhs, const DenseVector&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gae26f9406627cf1059b01755eb635e1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_121.png"/>).  <a href="#gae26f9406627cf1059b01755eb635e1f2">More...</a><br /></td></tr>
<tr class="separator:gae26f9406627cf1059b01755eb635e1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e490c7a24853b803499ba9e3becaa50"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga5e490c7a24853b803499ba9e3becaa50"><td class="memTemplItemLeft" align="right" valign="top">const SVecDVecSubExpr&lt; T1, T2, TF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5e490c7a24853b803499ba9e3becaa50">blaze::operator-</a> (const SparseVector&lt; T1, TF &gt; &amp;lhs, const DenseVector&lt; T2, TF &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5e490c7a24853b803499ba9e3becaa50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for the subtraction of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_124.png"/>).  <a href="#ga5e490c7a24853b803499ba9e3becaa50">More...</a><br /></td></tr>
<tr class="separator:ga5e490c7a24853b803499ba9e3becaa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29a3e2901fb6e319d4792001d250b9b0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga29a3e2901fb6e319d4792001d250b9b0"><td class="memTemplItemLeft" align="right" valign="top">const SVecSVecCrossExpr&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga29a3e2901fb6e319d4792001d250b9b0">blaze::operator%</a> (const SparseVector&lt; T1, false &gt; &amp;lhs, const SparseVector&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga29a3e2901fb6e319d4792001d250b9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for the cross product of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_121.png"/>).  <a href="#ga29a3e2901fb6e319d4792001d250b9b0">More...</a><br /></td></tr>
<tr class="separator:ga29a3e2901fb6e319d4792001d250b9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae70d2b23499b4e8bee9ca6ef02ec0c91"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae70d2b23499b4e8bee9ca6ef02ec0c91"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf&lt; IsMatMatMultExpr&lt; T1 &gt;, TDMatDVecMultExpr&lt; T1, T2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae70d2b23499b4e8bee9ca6ef02ec0c91">blaze::operator*</a> (const DenseMatrix&lt; T1, true &gt; &amp;mat, const DenseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:gae70d2b23499b4e8bee9ca6ef02ec0c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_113.png"/>).  <a href="#gae70d2b23499b4e8bee9ca6ef02ec0c91">More...</a><br /></td></tr>
<tr class="separator:gae70d2b23499b4e8bee9ca6ef02ec0c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c99693a856adeaec5e4a50baf3d72d7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0c99693a856adeaec5e4a50baf3d72d7"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf&lt; IsMatMatMultExpr&lt; T1 &gt;, TDMatSVecMultExpr&lt; T1, T2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0c99693a856adeaec5e4a50baf3d72d7">blaze::operator*</a> (const DenseMatrix&lt; T1, true &gt; &amp;mat, const SparseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga0c99693a856adeaec5e4a50baf3d72d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_113.png"/>).  <a href="#ga0c99693a856adeaec5e4a50baf3d72d7">More...</a><br /></td></tr>
<tr class="separator:ga0c99693a856adeaec5e4a50baf3d72d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga545f87ad5a7df86714ebf79fa949ac9a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga545f87ad5a7df86714ebf79fa949ac9a"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf&lt; IsMatMatMultExpr&lt; T2 &gt;, TDVecDMatMultExpr&lt; T1, T2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga545f87ad5a7df86714ebf79fa949ac9a">blaze::operator*</a> (const DenseVector&lt; T1, true &gt; &amp;vec, const DenseMatrix&lt; T2, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga545f87ad5a7df86714ebf79fa949ac9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a row-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>).  <a href="#ga545f87ad5a7df86714ebf79fa949ac9a">More...</a><br /></td></tr>
<tr class="separator:ga545f87ad5a7df86714ebf79fa949ac9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495835ccdcd033ded217279c2ed170a0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:ga495835ccdcd033ded217279c2ed170a0"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsMatMatMultExpr&lt; T2 &gt;, typename MultExprTrait&lt; T1, T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga495835ccdcd033ded217279c2ed170a0">blaze::operator*</a> (const DenseVector&lt; T1, true &gt; &amp;vec, const DenseMatrix&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga495835ccdcd033ded217279c2ed170a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a dense matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_133.png"/>).  <a href="#ga495835ccdcd033ded217279c2ed170a0">More...</a><br /></td></tr>
<tr class="separator:ga495835ccdcd033ded217279c2ed170a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b356d4adc97cccfc79d453c0dd42d28"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5b356d4adc97cccfc79d453c0dd42d28"><td class="memTemplItemLeft" align="right" valign="top">DisableIf&lt; TDVecDVecMultExprHelper&lt; T1, T2 &gt;, const typename MultTrait&lt; typename T1::ElementType, typename T2::ElementType &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5b356d4adc97cccfc79d453c0dd42d28">blaze::operator*</a> (const DenseVector&lt; T1, true &gt; &amp;lhs, const DenseVector&lt; T2, false &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga5b356d4adc97cccfc79d453c0dd42d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default multiplication operator for the scalar product (inner product) of two dense vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_135.png"/>).  <a href="#ga5b356d4adc97cccfc79d453c0dd42d28">More...</a><br /></td></tr>
<tr class="separator:ga5b356d4adc97cccfc79d453c0dd42d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6235a3dfff0210a56f9c6339fa65e080"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga6235a3dfff0210a56f9c6339fa65e080"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf&lt; Or&lt; IsSymmetric&lt; T2 &gt;, IsMatMatMultExpr&lt; T2 &gt; &gt;, TDVecSMatMultExpr&lt; T1, T2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga6235a3dfff0210a56f9c6339fa65e080">blaze::operator*</a> (const DenseVector&lt; T1, true &gt; &amp;vec, const SparseMatrix&lt; T2, false &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga6235a3dfff0210a56f9c6339fa65e080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>).  <a href="#ga6235a3dfff0210a56f9c6339fa65e080">More...</a><br /></td></tr>
<tr class="separator:ga6235a3dfff0210a56f9c6339fa65e080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf6e2d9c45ad3b9b00c12010a7df09d3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gacf6e2d9c45ad3b9b00c12010a7df09d3"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsMatMatMultExpr&lt; T2 &gt;, typename MultExprTrait&lt; T1, T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gacf6e2d9c45ad3b9b00c12010a7df09d3">blaze::operator*</a> (const DenseVector&lt; T1, true &gt; &amp;vec, const SparseMatrix&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:gacf6e2d9c45ad3b9b00c12010a7df09d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose dense vector and a sparse matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_133.png"/>).  <a href="#gacf6e2d9c45ad3b9b00c12010a7df09d3">More...</a><br /></td></tr>
<tr class="separator:gacf6e2d9c45ad3b9b00c12010a7df09d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d36043aaa1ccf85fd59fa783de3be89"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5d36043aaa1ccf85fd59fa783de3be89"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf&lt; Or&lt; IsSymmetric&lt; T1 &gt;, IsMatMatMultExpr&lt; T1 &gt; &gt;, TSMatDVecMultExpr&lt; T1, T2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5d36043aaa1ccf85fd59fa783de3be89">blaze::operator*</a> (const SparseMatrix&lt; T1, true &gt; &amp;mat, const DenseVector&lt; T2, false &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga5d36043aaa1ccf85fd59fa783de3be89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a column-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_113.png"/>).  <a href="#ga5d36043aaa1ccf85fd59fa783de3be89">More...</a><br /></td></tr>
<tr class="separator:ga5d36043aaa1ccf85fd59fa783de3be89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1c0c17fad0d662b539fce81eefd3125"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool SO&gt; </td></tr>
<tr class="memitem:gae1c0c17fad0d662b539fce81eefd3125"><td class="memTemplItemLeft" align="right" valign="top">const EnableIf&lt; IsMatMatMultExpr&lt; T2 &gt;, typename MultExprTrait&lt; T1, T2 &gt;::Type &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae1c0c17fad0d662b539fce81eefd3125">blaze::operator*</a> (const SparseVector&lt; T1, true &gt; &amp;vec, const DenseMatrix&lt; T2, SO &gt; &amp;mat)</td></tr>
<tr class="memdesc:gae1c0c17fad0d662b539fce81eefd3125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a dense matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_133.png"/>).  <a href="#gae1c0c17fad0d662b539fce81eefd3125">More...</a><br /></td></tr>
<tr class="separator:gae1c0c17fad0d662b539fce81eefd3125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3787807c654938b83e9ba22dec2c41"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga4e3787807c654938b83e9ba22dec2c41"><td class="memTemplItemLeft" align="right" valign="top">const DisableIf&lt; Or&lt; IsSymmetric&lt; T2 &gt;, IsMatMatMultExpr&lt; T2 &gt; &gt;, TSVecTDMatMultExpr&lt; T1, T2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4e3787807c654938b83e9ba22dec2c41">blaze::operator*</a> (const SparseVector&lt; T1, true &gt; &amp;vec, const DenseMatrix&lt; T2, true &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga4e3787807c654938b83e9ba22dec2c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for the multiplication of a transpose sparse vector and a column-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>).  <a href="#ga4e3787807c654938b83e9ba22dec2c41">More...</a><br /></td></tr>
<tr class="separator:ga4e3787807c654938b83e9ba22dec2c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:gab71c44fc69da24aa7302f79fe8e94c94"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gab71c44fc69da24aa7302f79fe8e94c94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gab71c44fc69da24aa7302f79fe8e94c94">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::assign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:gab71c44fc69da24aa7302f79fe8e94c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>).  <a href="#gab71c44fc69da24aa7302f79fe8e94c94">More...</a><br /></td></tr>
<tr class="separator:gab71c44fc69da24aa7302f79fe8e94c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeddb101c9648191274078dd4cd1ec782"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gaeddb101c9648191274078dd4cd1ec782"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaeddb101c9648191274078dd4cd1ec782">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::assign</a> (SparseVector&lt; VT2, true &gt; &amp;lhs, const TDVecSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:gaeddb101c9648191274078dd4cd1ec782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of a transpose dense vector-sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>).  <a href="#gaeddb101c9648191274078dd4cd1ec782">More...</a><br /></td></tr>
<tr class="separator:gaeddb101c9648191274078dd4cd1ec782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5cbae5a2188a3a84d0585371e6110c1"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gab5cbae5a2188a3a84d0585371e6110c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gab5cbae5a2188a3a84d0585371e6110c1">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::addAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:gab5cbae5a2188a3a84d0585371e6110c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>).  <a href="#gab5cbae5a2188a3a84d0585371e6110c1">More...</a><br /></td></tr>
<tr class="separator:gab5cbae5a2188a3a84d0585371e6110c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9737bc07f38a7e9144dc3fcb1c7114b"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gaa9737bc07f38a7e9144dc3fcb1c7114b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaa9737bc07f38a7e9144dc3fcb1c7114b">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::subAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:gaa9737bc07f38a7e9144dc3fcb1c7114b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>).  <a href="#gaa9737bc07f38a7e9144dc3fcb1c7114b">More...</a><br /></td></tr>
<tr class="separator:gaa9737bc07f38a7e9144dc3fcb1c7114b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e3422dd6679538dce1a983ad6f0682"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga24e3422dd6679538dce1a983ad6f0682"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga24e3422dd6679538dce1a983ad6f0682">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::multAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga24e3422dd6679538dce1a983ad6f0682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>).  <a href="#ga24e3422dd6679538dce1a983ad6f0682">More...</a><br /></td></tr>
<tr class="separator:ga24e3422dd6679538dce1a983ad6f0682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ba0e9664a8167cd38e324a08d237ee0"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga6ba0e9664a8167cd38e324a08d237ee0"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga6ba0e9664a8167cd38e324a08d237ee0">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::smpAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga6ba0e9664a8167cd38e324a08d237ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>).  <a href="#ga6ba0e9664a8167cd38e324a08d237ee0">More...</a><br /></td></tr>
<tr class="separator:ga6ba0e9664a8167cd38e324a08d237ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga839146a557d218f2bb241868e14b610a"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga839146a557d218f2bb241868e14b610a"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga839146a557d218f2bb241868e14b610a">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::smpAssign</a> (SparseVector&lt; VT2, true &gt; &amp;lhs, const TDVecSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga839146a557d218f2bb241868e14b610a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP assignment of a transpose dense vector-sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>).  <a href="#ga839146a557d218f2bb241868e14b610a">More...</a><br /></td></tr>
<tr class="separator:ga839146a557d218f2bb241868e14b610a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ef7f36795587bd4c99b9aaf4e919230"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga5ef7f36795587bd4c99b9aaf4e919230"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5ef7f36795587bd4c99b9aaf4e919230">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::smpAddAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga5ef7f36795587bd4c99b9aaf4e919230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>).  <a href="#ga5ef7f36795587bd4c99b9aaf4e919230">More...</a><br /></td></tr>
<tr class="separator:ga5ef7f36795587bd4c99b9aaf4e919230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d7e98710512255aced624f7e3f66ef2"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga0d7e98710512255aced624f7e3f66ef2"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0d7e98710512255aced624f7e3f66ef2">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::smpSubAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga0d7e98710512255aced624f7e3f66ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP subtraction assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>).  <a href="#ga0d7e98710512255aced624f7e3f66ef2">More...</a><br /></td></tr>
<tr class="separator:ga0d7e98710512255aced624f7e3f66ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaad3022aedfec3c5585b31b9321857dc"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gaaad3022aedfec3c5585b31b9321857dc"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaaad3022aedfec3c5585b31b9321857dc">blaze::TDVecSMatMultExpr&lt; VT, MT &gt;::smpMultAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:gaaad3022aedfec3c5585b31b9321857dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP multiplication assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>).  <a href="#gaaad3022aedfec3c5585b31b9321857dc">More...</a><br /></td></tr>
<tr class="separator:gaaad3022aedfec3c5585b31b9321857dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aba8ea15c113036a6394b083f1df30c"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga2aba8ea15c113036a6394b083f1df30c"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga2aba8ea15c113036a6394b083f1df30c">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::assign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecTSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga2aba8ea15c113036a6394b083f1df30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>).  <a href="#ga2aba8ea15c113036a6394b083f1df30c">More...</a><br /></td></tr>
<tr class="separator:ga2aba8ea15c113036a6394b083f1df30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6eead65aff5e0a2523eb364e8ec6038"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gad6eead65aff5e0a2523eb364e8ec6038"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gad6eead65aff5e0a2523eb364e8ec6038">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::assign</a> (SparseVector&lt; VT2, true &gt; &amp;lhs, const TDVecTSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:gad6eead65aff5e0a2523eb364e8ec6038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment of a transpose dense vector-transpose sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>).  <a href="#gad6eead65aff5e0a2523eb364e8ec6038">More...</a><br /></td></tr>
<tr class="separator:gad6eead65aff5e0a2523eb364e8ec6038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c05663dd2c32a18e765e9c810c717c"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gac8c05663dd2c32a18e765e9c810c717c"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac8c05663dd2c32a18e765e9c810c717c">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::addAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecTSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:gac8c05663dd2c32a18e765e9c810c717c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>).  <a href="#gac8c05663dd2c32a18e765e9c810c717c">More...</a><br /></td></tr>
<tr class="separator:gac8c05663dd2c32a18e765e9c810c717c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b97a817205a7666e3a591ae4b327e0b"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga4b97a817205a7666e3a591ae4b327e0b"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4b97a817205a7666e3a591ae4b327e0b">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::subAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecTSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga4b97a817205a7666e3a591ae4b327e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>).  <a href="#ga4b97a817205a7666e3a591ae4b327e0b">More...</a><br /></td></tr>
<tr class="separator:ga4b97a817205a7666e3a591ae4b327e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6d196d9ef990086dd810b1faefa572f"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gac6d196d9ef990086dd810b1faefa572f"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gac6d196d9ef990086dd810b1faefa572f">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::multAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecTSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:gac6d196d9ef990086dd810b1faefa572f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>).  <a href="#gac6d196d9ef990086dd810b1faefa572f">More...</a><br /></td></tr>
<tr class="separator:gac6d196d9ef990086dd810b1faefa572f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38f0eb2dc01576f29d6b8993897e8b70"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga38f0eb2dc01576f29d6b8993897e8b70"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga38f0eb2dc01576f29d6b8993897e8b70">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::smpAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecTSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga38f0eb2dc01576f29d6b8993897e8b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>).  <a href="#ga38f0eb2dc01576f29d6b8993897e8b70">More...</a><br /></td></tr>
<tr class="separator:ga38f0eb2dc01576f29d6b8993897e8b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f81149d9e724e60d161a7f370ffa263"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga5f81149d9e724e60d161a7f370ffa263"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga5f81149d9e724e60d161a7f370ffa263">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::smpAssign</a> (SparseVector&lt; VT2, true &gt; &amp;lhs, const TDVecTSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga5f81149d9e724e60d161a7f370ffa263"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP assignment of a transpose dense vector-transpose sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>).  <a href="#ga5f81149d9e724e60d161a7f370ffa263">More...</a><br /></td></tr>
<tr class="separator:ga5f81149d9e724e60d161a7f370ffa263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24bd93308fdd31baca776036b1f5f2f7"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga24bd93308fdd31baca776036b1f5f2f7"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga24bd93308fdd31baca776036b1f5f2f7">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::smpAddAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecTSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga24bd93308fdd31baca776036b1f5f2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP addition assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>).  <a href="#ga24bd93308fdd31baca776036b1f5f2f7">More...</a><br /></td></tr>
<tr class="separator:ga24bd93308fdd31baca776036b1f5f2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71bc64cfb6265ae66eb73b6c2063450"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gab71bc64cfb6265ae66eb73b6c2063450"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gab71bc64cfb6265ae66eb73b6c2063450">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::smpSubAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecTSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:gab71bc64cfb6265ae66eb73b6c2063450"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP subtraction assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>).  <a href="#gab71bc64cfb6265ae66eb73b6c2063450">More...</a><br /></td></tr>
<tr class="separator:gab71bc64cfb6265ae66eb73b6c2063450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad14c40190e7bc9a5c953171fc95c9fb3"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gad14c40190e7bc9a5c953171fc95c9fb3"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gad14c40190e7bc9a5c953171fc95c9fb3">blaze::TDVecTSMatMultExpr&lt; VT, MT &gt;::smpMultAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TDVecTSMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:gad14c40190e7bc9a5c953171fc95c9fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP multiplication assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>).  <a href="#gad14c40190e7bc9a5c953171fc95c9fb3">More...</a><br /></td></tr>
<tr class="separator:gad14c40190e7bc9a5c953171fc95c9fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6868cf3b70208eed023b4e722066815"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gae6868cf3b70208eed023b4e722066815"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae6868cf3b70208eed023b4e722066815">blaze::TSVecDMatMultExpr&lt; VT, MT &gt;::addAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TSVecDMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:gae6868cf3b70208eed023b4e722066815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>).  <a href="#gae6868cf3b70208eed023b4e722066815">More...</a><br /></td></tr>
<tr class="separator:gae6868cf3b70208eed023b4e722066815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbe8a27b763bf7716c313756494e54dd"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gabbe8a27b763bf7716c313756494e54dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gabbe8a27b763bf7716c313756494e54dd">blaze::TSVecDMatMultExpr&lt; VT, MT &gt;::subAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TSVecDMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:gabbe8a27b763bf7716c313756494e54dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>).  <a href="#gabbe8a27b763bf7716c313756494e54dd">More...</a><br /></td></tr>
<tr class="separator:gabbe8a27b763bf7716c313756494e54dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga050da3682f47907ce839ebaff145168a"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga050da3682f47907ce839ebaff145168a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga050da3682f47907ce839ebaff145168a">blaze::TSVecDMatMultExpr&lt; VT, MT &gt;::multAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TSVecDMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga050da3682f47907ce839ebaff145168a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>).  <a href="#ga050da3682f47907ce839ebaff145168a">More...</a><br /></td></tr>
<tr class="separator:ga050da3682f47907ce839ebaff145168a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga353c3f22a6b641ae76eddc1924b8032a"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga353c3f22a6b641ae76eddc1924b8032a"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga353c3f22a6b641ae76eddc1924b8032a">blaze::TSVecDMatMultExpr&lt; VT, MT &gt;::smpAddAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TSVecDMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga353c3f22a6b641ae76eddc1924b8032a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP addition assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>).  <a href="#ga353c3f22a6b641ae76eddc1924b8032a">More...</a><br /></td></tr>
<tr class="separator:ga353c3f22a6b641ae76eddc1924b8032a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafac111e4c78a60c9d2d4a6f51300a82"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gaafac111e4c78a60c9d2d4a6f51300a82"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaafac111e4c78a60c9d2d4a6f51300a82">blaze::TSVecDMatMultExpr&lt; VT, MT &gt;::smpSubAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TSVecDMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:gaafac111e4c78a60c9d2d4a6f51300a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP subtraction assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>).  <a href="#gaafac111e4c78a60c9d2d4a6f51300a82">More...</a><br /></td></tr>
<tr class="separator:gaafac111e4c78a60c9d2d4a6f51300a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae118c2d6ef8ff4227a198fa0a00d3858"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gae118c2d6ef8ff4227a198fa0a00d3858"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gae118c2d6ef8ff4227a198fa0a00d3858">blaze::TSVecDMatMultExpr&lt; VT, MT &gt;::smpMultAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TSVecDMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:gae118c2d6ef8ff4227a198fa0a00d3858"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP multiplication assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>).  <a href="#gae118c2d6ef8ff4227a198fa0a00d3858">More...</a><br /></td></tr>
<tr class="separator:gae118c2d6ef8ff4227a198fa0a00d3858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34640b05b20497228d7a5d04075675f8"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga34640b05b20497228d7a5d04075675f8"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga34640b05b20497228d7a5d04075675f8">blaze::TSVecTDMatMultExpr&lt; VT, MT &gt;::addAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TSVecTDMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga34640b05b20497228d7a5d04075675f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>).  <a href="#ga34640b05b20497228d7a5d04075675f8">More...</a><br /></td></tr>
<tr class="separator:ga34640b05b20497228d7a5d04075675f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga813e0b0dd4ee7871c51c420cefb1ac2b"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga813e0b0dd4ee7871c51c420cefb1ac2b"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga813e0b0dd4ee7871c51c420cefb1ac2b">blaze::TSVecTDMatMultExpr&lt; VT, MT &gt;::subAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TSVecTDMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga813e0b0dd4ee7871c51c420cefb1ac2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>).  <a href="#ga813e0b0dd4ee7871c51c420cefb1ac2b">More...</a><br /></td></tr>
<tr class="separator:ga813e0b0dd4ee7871c51c420cefb1ac2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1e8bdcac00b251731d9ecac15f407e"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga7f1e8bdcac00b251731d9ecac15f407e"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga7f1e8bdcac00b251731d9ecac15f407e">blaze::TSVecTDMatMultExpr&lt; VT, MT &gt;::multAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TSVecTDMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga7f1e8bdcac00b251731d9ecac15f407e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>).  <a href="#ga7f1e8bdcac00b251731d9ecac15f407e">More...</a><br /></td></tr>
<tr class="separator:ga7f1e8bdcac00b251731d9ecac15f407e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga120fdb8759199c49ab874bc5a159532d"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga120fdb8759199c49ab874bc5a159532d"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga120fdb8759199c49ab874bc5a159532d">blaze::TSVecTDMatMultExpr&lt; VT, MT &gt;::smpAddAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TSVecTDMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga120fdb8759199c49ab874bc5a159532d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP addition assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>).  <a href="#ga120fdb8759199c49ab874bc5a159532d">More...</a><br /></td></tr>
<tr class="separator:ga120fdb8759199c49ab874bc5a159532d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dcfca06778c7fc69ec57ee837e9f14d"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:ga6dcfca06778c7fc69ec57ee837e9f14d"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga6dcfca06778c7fc69ec57ee837e9f14d">blaze::TSVecTDMatMultExpr&lt; VT, MT &gt;::smpSubAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TSVecTDMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:ga6dcfca06778c7fc69ec57ee837e9f14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP subtraction assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>).  <a href="#ga6dcfca06778c7fc69ec57ee837e9f14d">More...</a><br /></td></tr>
<tr class="separator:ga6dcfca06778c7fc69ec57ee837e9f14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb093caf695bf4f0e5b79a7d6647461b"><td class="memTemplParams" colspan="2">template&lt;typename VT2 &gt; </td></tr>
<tr class="memitem:gabb093caf695bf4f0e5b79a7d6647461b"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; UseSMPAssign&lt; VT2 &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gabb093caf695bf4f0e5b79a7d6647461b">blaze::TSVecTDMatMultExpr&lt; VT, MT &gt;::smpMultAssign</a> (DenseVector&lt; VT2, true &gt; &amp;lhs, const TSVecTDMatMultExpr &amp;rhs)</td></tr>
<tr class="memdesc:gabb093caf695bf4f0e5b79a7d6647461b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMP multiplication assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>).  <a href="#gabb093caf695bf4f0e5b79a7d6647461b">More...</a><br /></td></tr>
<tr class="separator:gabb093caf695bf4f0e5b79a7d6647461b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DenseVector operators</h2></td></tr>
<tr class="memitem:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga7718438f21d78c1c5cd61e11b620f3ac">blaze::operator==</a> (const DenseVector&lt; T1, TF1 &gt; &amp;lhs, const DenseVector&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of two dense vectors.  <a href="#ga7718438f21d78c1c5cd61e11b620f3ac">More...</a><br /></td></tr>
<tr class="separator:ga7718438f21d78c1c5cd61e11b620f3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga521be975d8edae170b5f159468392be7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga521be975d8edae170b5f159468392be7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga521be975d8edae170b5f159468392be7">blaze::operator==</a> (const DenseVector&lt; T1, TF1 &gt; &amp;lhs, const SparseVector&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga521be975d8edae170b5f159468392be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense vector and a sparse vector.  <a href="#ga521be975d8edae170b5f159468392be7">More...</a><br /></td></tr>
<tr class="separator:ga521be975d8edae170b5f159468392be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga90afa4cbe670f292f01e0a8c0989bcb4">blaze::operator==</a> (const SparseVector&lt; T1, TF1 &gt; &amp;lhs, const DenseVector&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a sparse vector and a dense vector.  <a href="#ga90afa4cbe670f292f01e0a8c0989bcb4">More...</a><br /></td></tr>
<tr class="separator:ga90afa4cbe670f292f01e0a8c0989bcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb6253dd234e9b48e75e0ec02050b959"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gacb6253dd234e9b48e75e0ec02050b959"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; IsNumeric&lt; T2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gacb6253dd234e9b48e75e0ec02050b959">blaze::operator==</a> (const DenseVector&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:gacb6253dd234e9b48e75e0ec02050b959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a dense vector and a scalar value.  <a href="#gacb6253dd234e9b48e75e0ec02050b959">More...</a><br /></td></tr>
<tr class="separator:gacb6253dd234e9b48e75e0ec02050b959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab20536da4445fc400927e431fbdf331"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gaab20536da4445fc400927e431fbdf331"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; IsNumeric&lt; T1 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaab20536da4445fc400927e431fbdf331">blaze::operator==</a> (T1 scalar, const DenseVector&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:gaab20536da4445fc400927e431fbdf331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for the comparison of a scalar value and a dense vector.  <a href="#gaab20536da4445fc400927e431fbdf331">More...</a><br /></td></tr>
<tr class="separator:gaab20536da4445fc400927e431fbdf331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga1d006cc08bc800f749d0cffb9ddbb9a7">blaze::operator!=</a> (const DenseVector&lt; T1, TF1 &gt; &amp;lhs, const DenseVector&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of two dense vectors.  <a href="#ga1d006cc08bc800f749d0cffb9ddbb9a7">More...</a><br /></td></tr>
<tr class="separator:ga1d006cc08bc800f749d0cffb9ddbb9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga8c4f3ccbb0ab4cdb1d85ce597cba43bb">blaze::operator!=</a> (const DenseVector&lt; T1, TF1 &gt; &amp;lhs, const SparseVector&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense vector and a sparse vector.  <a href="#ga8c4f3ccbb0ab4cdb1d85ce597cba43bb">More...</a><br /></td></tr>
<tr class="separator:ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde27bb0ee7f998bef03dceca10cdce3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </td></tr>
<tr class="memitem:gabde27bb0ee7f998bef03dceca10cdce3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gabde27bb0ee7f998bef03dceca10cdce3">blaze::operator!=</a> (const SparseVector&lt; T1, TF1 &gt; &amp;lhs, const DenseVector&lt; T2, TF2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabde27bb0ee7f998bef03dceca10cdce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a sparse vector and a dense vector.  <a href="#gabde27bb0ee7f998bef03dceca10cdce3">More...</a><br /></td></tr>
<tr class="separator:gabde27bb0ee7f998bef03dceca10cdce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c595fd68d81ec3c4fd30eb74bbcee95"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:ga2c595fd68d81ec3c4fd30eb74bbcee95"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; IsNumeric&lt; T2 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga2c595fd68d81ec3c4fd30eb74bbcee95">blaze::operator!=</a> (const DenseVector&lt; T1, TF &gt; &amp;vec, T2 scalar)</td></tr>
<tr class="memdesc:ga2c595fd68d81ec3c4fd30eb74bbcee95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a dense vector and a scalar value.  <a href="#ga2c595fd68d81ec3c4fd30eb74bbcee95">More...</a><br /></td></tr>
<tr class="separator:ga2c595fd68d81ec3c4fd30eb74bbcee95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd6f670282d5c2e8ee9f118f71f894a3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , bool TF&gt; </td></tr>
<tr class="memitem:gafd6f670282d5c2e8ee9f118f71f894a3"><td class="memTemplItemLeft" align="right" valign="top">EnableIf&lt; IsNumeric&lt; T1 &gt;, bool &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gafd6f670282d5c2e8ee9f118f71f894a3">blaze::operator!=</a> (T1 scalar, const DenseVector&lt; T2, TF &gt; &amp;vec)</td></tr>
<tr class="memdesc:gafd6f670282d5c2e8ee9f118f71f894a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for the comparison of a scalar value and a dense vector.  <a href="#gafd6f670282d5c2e8ee9f118f71f894a3">More...</a><br /></td></tr>
<tr class="separator:gafd6f670282d5c2e8ee9f118f71f894a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DenseVector functions</h2></td></tr>
<tr class="memitem:gaee69fc388ff36a0cd55c36b24e6556f6"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:gaee69fc388ff36a0cd55c36b24e6556f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#gaee69fc388ff36a0cd55c36b24e6556f6">blaze::isnan</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:gaee69fc388ff36a0cd55c36b24e6556f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the given dense vector for not-a-number elements.  <a href="#gaee69fc388ff36a0cd55c36b24e6556f6">More...</a><br /></td></tr>
<tr class="separator:gaee69fc388ff36a0cd55c36b24e6556f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga527e3c01fa1ccc42fae90bb95cc50082"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga527e3c01fa1ccc42fae90bb95cc50082"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga527e3c01fa1ccc42fae90bb95cc50082">blaze::isUniform</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga527e3c01fa1ccc42fae90bb95cc50082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given dense vector is a uniform vector.  <a href="#ga527e3c01fa1ccc42fae90bb95cc50082">More...</a><br /></td></tr>
<tr class="separator:ga527e3c01fa1ccc42fae90bb95cc50082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0643d4e96e0b9f11356f4d28589963c3"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga0643d4e96e0b9f11356f4d28589963c3"><td class="memTemplItemLeft" align="right" valign="top">CMathTrait&lt; typename VT::ElementType &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga0643d4e96e0b9f11356f4d28589963c3">blaze::length</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga0643d4e96e0b9f11356f4d28589963c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the dense vector length <img class="formulaInl" alt="$|\vec{a}|$" src="../../form_46.png"/>.  <a href="#ga0643d4e96e0b9f11356f4d28589963c3">More...</a><br /></td></tr>
<tr class="separator:ga0643d4e96e0b9f11356f4d28589963c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b68c5a39cd2fd6fb9fd91caea1747d1"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga7b68c5a39cd2fd6fb9fd91caea1747d1"><td class="memTemplItemLeft" align="right" valign="top">const VT::ElementType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga7b68c5a39cd2fd6fb9fd91caea1747d1">blaze::sqrLength</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga7b68c5a39cd2fd6fb9fd91caea1747d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the dense vector square length <img class="formulaInl" alt="$|\vec{a}|^2$" src="../../form_47.png"/>.  <a href="#ga7b68c5a39cd2fd6fb9fd91caea1747d1">More...</a><br /></td></tr>
<tr class="separator:ga7b68c5a39cd2fd6fb9fd91caea1747d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4da64f9a5a93b1db2af56e66ade1cd9d"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga4da64f9a5a93b1db2af56e66ade1cd9d"><td class="memTemplItemLeft" align="right" valign="top">const VT::ElementType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga4da64f9a5a93b1db2af56e66ade1cd9d">blaze::min</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga4da64f9a5a93b1db2af56e66ade1cd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest element of the dense vector.  <a href="#ga4da64f9a5a93b1db2af56e66ade1cd9d">More...</a><br /></td></tr>
<tr class="separator:ga4da64f9a5a93b1db2af56e66ade1cd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89281c892b6ca297f5450ed0e3948c81"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool TF&gt; </td></tr>
<tr class="memitem:ga89281c892b6ca297f5450ed0e3948c81"><td class="memTemplItemLeft" align="right" valign="top">const VT::ElementType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d90/group__dense__vector.html#ga89281c892b6ca297f5450ed0e3948c81">blaze::max</a> (const DenseVector&lt; VT, TF &gt; &amp;dv)</td></tr>
<tr class="memdesc:ga89281c892b6ca297f5450ed0e3948c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest element of the dense vector.  <a href="#ga89281c892b6ca297f5450ed0e3948c81">More...</a><br /></td></tr>
<tr class="separator:ga89281c892b6ca297f5450ed0e3948c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0cc328e0a8995b75b93180c8dfbd2757"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecAbsExpr&lt;VT,TF&gt; blaze::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the absolute values of each single element of <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of each single element of <em>dv</em>.</dd></dl>
<p>The <em>abs</em> function calculates the absolute value of each element of the input vector <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>abs</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaaf0f17914afcea53bd79d0da9b5ae863">abs</a>( a );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gab9e162d0ea6b3e4493b9666c6730d690"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecEvalExpr&lt;VT,TF&gt; blaze::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the evaluation of the given dense vector expression <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated dense vector.</dd></dl>
<p>The <em>eval</em> function forces the evaluation of the given dense vector expression <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>eval</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gacb9f8190d38edb0e52d9c376da5486d6">eval</a>( a );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaee69fc388ff36a0cd55c36b24e6556f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the given dense vector for not-a-number elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The vector to be checked for not-a-number elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the vector is not-a-number, <em>false</em> otherwise.</dd></dl>
<p>This function checks the N-dimensional dense vector for not-a-number (NaN) elements. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> at least one element of the vector is not-a-number, the function returns <em>true</em>, otherwise it returns <em>false</em>.</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga99ba6a5b32152077ba7d013be1add4dc">isnan</a>( a ) ) { ... }</div>
</div><!-- fragment --><p>Note that this function only works for vectors with floating point elements. The attempt to use it for a vector with a non-floating point element type results in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga527e3c01fa1ccc42fae90bb95cc50082"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isUniform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given dense vector is a uniform vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The dense vector to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the vector is a uniform vector, <em>false</em> if not.</dd></dl>
<p>This function checks if the given dense vector is a uniform vector. The vector is considered to be uniform if all its elements are identical. The following code example demonstrates the use of the function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;int,blaze::columnVector&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Initialization</span></div>
<div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7aafd1dd369f715e523850f4adb36696">isUniform</a>( a ) ) { ... }</div>
</div><!-- fragment --><p>It is also possible to check if a vector expression results in a uniform vector:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../db/df0/group__dense__matrix.html#ga7aafd1dd369f715e523850f4adb36696">isUniform</a>( a + b ) ) { ... }</div>
</div><!-- fragment --><p>However, note that this might require the complete evaluation of the expression, including the generation of a temporary vector. </p>

</div>
</div>
<a class="anchor" id="ga0643d4e96e0b9f11356f4d28589963c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CMathTrait&lt; typename VT::ElementType &gt;::Type blaze::length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the dense vector length <img class="formulaInl" alt="$|\vec{a}|$" src="../../form_46.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The given dense vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the dense vector.</dd></dl>
<p>This function calculates the actual length of the dense vector. The return type of the <a class="el" href="../../de/d90/group__dense__vector.html#ga0643d4e96e0b9f11356f4d28589963c3" title="Calculation of the dense vector length . ">length()</a> function depends on the actual element type of the vector instance:</p>
<table  border="0" cellspacing="0" cellpadding="1">
<tr>
<td width="250px"><b>ElementType</b>  </td><td width="100px"><b>LengthType</b>   </td></tr>
<tr>
<td>float </td><td>float  </td></tr>
<tr>
<td>integral data types and double </td><td>double  </td></tr>
<tr>
<td>long double </td><td>long double  </td></tr>
</table>
<p><b>Note:</b> This operation is only defined for numeric data types. In case the element type is not a numeric data type (i.e. a user defined data type or boolean) the attempt to use the <a class="el" href="../../de/d90/group__dense__vector.html#ga0643d4e96e0b9f11356f4d28589963c3" title="Calculation of the dense vector length . ">length()</a> function results in a compile time error! </p>

</div>
</div>
<a class="anchor" id="ga89281c892b6ca297f5450ed0e3948c81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VT::ElementType blaze::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the largest element of the dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The given dense vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest dense vector element.</dd></dl>
<p>This function returns the largest element of the given dense vector. This function can only be used for element types that support the smaller-than relationship. In case the vector currently has a size of 0, the returned value is the default value (e.g. 0 in case of fundamental data types). </p>

</div>
</div>
<a class="anchor" id="ga4da64f9a5a93b1db2af56e66ade1cd9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VT::ElementType blaze::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smallest element of the dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The given dense vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest dense vector element.</dd></dl>
<p>This function returns the smallest element of the given dense vector. This function can only be used for element types that support the smaller-than relationship. In case the vector currently has a size of 0, the returned value is the default value (e.g. 0 in case of fundamental data types). </p>

</div>
</div>
<a class="anchor" id="ga1d006cc08bc800f749d0cffb9ddbb9a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of two dense vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8c4f3ccbb0ab4cdb1d85ce597cba43bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a dense vector and a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="gabde27bb0ee7f998bef03dceca10cdce3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a sparse vector and a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are not equal, <em>false</em> if they are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c595fd68d81ec3c4fd30eb74bbcee95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; IsNumeric&lt; T2 &gt;, bool &gt;::Type blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a dense vector and a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the vector is different from the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> one value of the vector is inequal to the scalar value, the inequality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a class="anchor" id="gafd6f670282d5c2e8ee9f118f71f894a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; IsNumeric&lt; T1 &gt;, bool &gt;::Type blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for the comparison of a scalar value and a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the comparison. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if at least one element of the vector is different from the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> one value of the vector is inequal to the scalar value, the inequality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a class="anchor" id="ga29a3e2901fb6e319d4792001d250b9b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SVecSVecCrossExpr&lt;T1,T2&gt; blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the cross product of two sparse vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_121.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two sparse vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the cross product of two sparse vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a( 3UL ), b( 3UL );</div>
<div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a % b;</div>
</div><!-- fragment --><p>The operator returns a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gaa687a75e64beca784394faf86435249c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecDVecCrossExpr&lt;T1,T2&gt; blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the cross product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_121.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the cross product of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a( 3UL ), b( 3UL );</div>
<div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a % b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gaff63460a43ecf99ed5dc7c51cd505f04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecSVecCrossExpr&lt;T1,T2&gt; blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the cross product of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_121.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the cross product of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a( 3UL );</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> b( 3UL );</div>
<div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a % b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gae26f9406627cf1059b01755eb635e1f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SVecDVecCrossExpr&lt;T1,T2&gt; blaze::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for the cross product of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b} \times \vec{c} $" src="../../form_121.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the cross product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the cross product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid vector size for cross product.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the cross product of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a( 3UL );</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> b( 3UL );</div>
<div class="line"><a class="code" href="../../d9/d3c/classblaze_1_1StaticVector.html">blaze::StaticVector&lt;double,3UL&gt;</a> c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a % b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga5b356d4adc97cccfc79d453c0dd42d28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DisableIf&lt; TDVecDVecMultExprHelper&lt;T1,T2&gt;, const typename MultTrait&lt;typename T1::ElementType,typename T2::ElementType&gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default multiplication operator for the scalar product (inner product) of two dense vectors ( <img class="formulaInl" alt="$ s=\vec{a}*\vec{b} $" src="../../form_135.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the inner product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar product. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the scalar product (inner product) of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div>
<div class="line">blaze::double res;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">res = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>(a) * b;</div>
</div><!-- fragment --><p>The operator returns a scalar value of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga4e3787807c654938b83e9ba22dec2c41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; Or&lt; IsSymmetric&lt;T2&gt;, IsMatMatMultExpr&lt;T2&gt; &gt; , TSVecTDMatMultExpr&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a column-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side column-major dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose sparse vector and a column-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> x, y;</div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = x * A;</div>
</div><!-- fragment --><p>The operator returns an expression representing a transpose sparse vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the dense matrix type <em>T1</em> and the dense vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gacb43cb214c53128145e6800bcf445a61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; Or&lt; IsSymmetric&lt;T1&gt;, IsMatMatMultExpr&lt;T1&gt; &gt; , DMatSVecMultExpr&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side row-major dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a row-major dense matrix and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> x;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the dense matrix type <em>T1</em> and the sparse vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga6235a3dfff0210a56f9c6339fa65e080"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; Or&lt; IsSymmetric&lt;T2&gt;, IsMatMatMultExpr&lt;T2&gt; &gt; , TDVecSMatMultExpr&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose dense vector and a row-major sparse matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side row-major sparse matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose dense vector and a row-major sparse matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a> x, y;</div>
<div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = x * A;</div>
</div><!-- fragment --><p>The operator returns an expression representing a transpose dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse matrix type <em>T1</em> and the dense vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gaa2e3b97cb2cb32f3037b4cb0b82d30bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T1&gt;, SMatDVecMultExpr&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side row-major sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a row-major sparse matrix and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,rowMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> x, y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse matrix type <em>T1</em> and the dense vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga5d36043aaa1ccf85fd59fa783de3be89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; Or&lt; IsSymmetric&lt;T1&gt;, IsMatMatMultExpr&lt;T1&gt; &gt; , TSMatDVecMultExpr&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major sparse matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side column-major sparse matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a column-major sparse matrix and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix&lt;double,columnMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> x, y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the sparse matrix type <em>T1</em> and the dense vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga718165dc7d2fdb2157449fc3753d8990"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO, typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsMatMatMultExpr&lt;T1&gt;, typename MultExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a sparse matrix-matrix multiplication expression and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_114.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side sparse matrix-matrix multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector.</dd></dl>
<p>This operator implements a performance optimized treatment of the multiplication of a sparse matrix-matrix multiplication expression and a dense vector. It restructures the expression <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_114.png"/> to the expression <img class="formulaInl" alt="$ \vec{y}=A*(B*\vec{x}) $" src="../../form_116.png"/>. </p>

</div>
</div>
<a class="anchor" id="gacf6e2d9c45ad3b9b00c12010a7df09d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsMatMatMultExpr&lt;T2&gt;, typename MultExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose dense vector and a sparse matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_133.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side sparse matrix-matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector.</dd></dl>
<p>This operator implements a performance optimized treatment of the multiplication of a dense vector and a sparse matrix-matrix multiplication expression. It restructures the expression <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_133.png"/> to the expression <img class="formulaInl" alt="$ \vec{y}^T=(\vec{x}^T*A)*B $" src="../../form_134.png"/>. </p>

</div>
</div>
<a class="anchor" id="ga4a5cc3fa262a06eeba8ab4f0d4c3777e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsNumeric&lt;T2&gt;, typename MultExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a dense vector and a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*s $" src="../../form_72.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the multiplication between a dense vector and a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = a * 1.25;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Both data types <em>T1::ElementType</em> and <em>T2</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a class="anchor" id="gaf6a0127d216ecef466edad068782d9e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecDVecMultExpr&lt;T1,T2,TF&gt; blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the componentwise product of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}*\vec{c} $" src="../../form_123.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the component product. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the component product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the component product of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a * b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gac6096b0a74a5fbf88317a167bc29fa61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsNumeric&lt;T1&gt;, typename MultExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a scalar value and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=s*\vec{b} $" src="../../form_127.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the multiplication between a a scalar value and dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = 1.25 * a;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Both data types <em>T1</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template. Note that this operator only works for scalar values of built-in data type. </p>

</div>
</div>
<a class="anchor" id="ga0c99693a856adeaec5e4a50baf3d72d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T1&gt;, TDMatSVecMultExpr&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major dense matrix and a sparse vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side column-major dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side sparse vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a column-major dense matrix and a sparse vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,columnVector&gt;</a> x;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the dense matrix type <em>T1</em> and the sparse vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gae1c0c17fad0d662b539fce81eefd3125"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsMatMatMultExpr&lt;T2&gt;, typename MultExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose sparse vector and a dense matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_133.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side sparse vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side dense matrix-matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector.</dd></dl>
<p>This operator implements a performance optimized treatment of the multiplication of a sparse vector and a dense matrix-matrix multiplication expression. It restructures the expression <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_133.png"/> to the expression <img class="formulaInl" alt="$ \vec{y}^T=(\vec{x}^T*A)*B $" src="../../form_134.png"/>. </p>

</div>
</div>
<a class="anchor" id="gae70d2b23499b4e8bee9ca6ef02ec0c91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T1&gt;, TDMatDVecMultExpr&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a column-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side column-major dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a column-major dense matrix and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,columnMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> x, y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the dense matrix type <em>T1</em> and the dense vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga545f87ad5a7df86714ebf79fa949ac9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T2&gt;, TDVecDMatMultExpr&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose dense vector and a row-major dense matrix ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side transpose dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side row-major dense matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting transpose vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> and matrix sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a transpose dense vector and a row-major dense matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a> x, y;</div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = x * A;</div>
</div><!-- fragment --><p>The operator returns an expression representing a transpose dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the dense matrix type <em>T1</em> and the dense vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of rows of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga495835ccdcd033ded217279c2ed170a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsMatMatMultExpr&lt;T2&gt;, typename MultExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T2, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a transpose dense vector and a dense matrix-matrix multiplication expression ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_133.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the multiplication. </td></tr>
    <tr><td class="paramname">mat</td><td>The right-hand side dense matrix-matrix multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector.</dd></dl>
<p>This operator implements a performance optimized treatment of the multiplication of a dense vector and a dense matrix-matrix multiplication expression. It restructures the expression <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*(A*B) $" src="../../form_133.png"/> to the expression <img class="formulaInl" alt="$ \vec{y}^T=(\vec{x}^T*A)*B $" src="../../form_134.png"/>. </p>

</div>
</div>
<a class="anchor" id="ga772dd5fcf447845bc8fcc3ac8cf1ad86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DisableIf&lt; IsMatMatMultExpr&lt;T1&gt;, DMatDVecMultExpr&lt;T1,T2&gt; &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a row-major dense matrix and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=A*\vec{x} $" src="../../form_113.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side row-major dense matrix for the multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> and vector sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the multiplication between a row-major dense matrix and a dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;double,rowMajor&gt;</a> A;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> x, y;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">y = A * x;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both the dense matrix type <em>T1</em> and the dense vector type <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class template.<br />
In case the current size of the vector <em>vec</em> doesn't match the current number of columns of the matrix <em>mat</em>, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga880d32b0bd1a512a5070da4a2c725b17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool SO, typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsMatMatMultExpr&lt;T1&gt;, typename MultExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; T1, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, false &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for the multiplication of a dense matrix-matrix multiplication expression and a dense vector ( <img class="formulaInl" alt="$ \vec{y}=(A*B)*\vec{x} $" src="../../form_114.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The left-hand side dense matrix-matrix multiplication. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting vector.</dd></dl>
<p>This operator implements a performance optimized treatment of the multiplication of a dense matrix-matrix multiplication expression and a dense vector. It restructures the expression <img class="formulaInl" alt="$ \vec{x}=(A*B)*\vec{x} $" src="../../form_115.png"/> to the expression <img class="formulaInl" alt="$ \vec{y}=A*(B*\vec{x}) $" src="../../form_116.png"/>. </p>

</div>
</div>
<a class="anchor" id="gac46fecdd6785f66d7521f88db40dd1b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecSVecAddExpr&lt;T1,T2,TF&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_120.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the vector addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the vector addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, c;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a + b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga362d09a6d64deafb689d21a6f7559c78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecSVecAddExpr&lt;T2,T1,TF&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_120.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the vector addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the vector addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a + b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gacade1745b146d7c63876fdd2bd755ce6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecDVecAddExpr&lt;T1,T2,TF&gt; blaze::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator for the addition of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}+\vec{c} $" src="../../form_120.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the vector addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the vector addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the addition of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a + b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga5e490c7a24853b803499ba9e3becaa50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SVecDVecSubExpr&lt;T1,T2,TF&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a sparse vector and a dense vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_124.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the vector subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted from the sparse vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a sparse vector and a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> a;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a - b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga4d9d2740625e6b7d83d77e0284ae21e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecSVecSubExpr&lt;T1,T2,TF&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of a dense vector and a sparse vector ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_124.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the vector subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector to be subtracted from the dense vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of a dense vector and a sparse vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, c;</div>
<div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double&gt;</a> b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a - b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="ga74b6a05f757de44c4daf52b23538cfaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecScalarMultExpr&lt;VT,typename BaseElementType&lt;VT&gt;::Type,TF&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus operator for the negation of a dense vector ( <img class="formulaInl" alt="$ \vec{a} = -\vec{b} $" src="../../form_126.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The dense vector to be negated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The negation of the vector.</dd></dl>
<p>This operator represents the negation of a dense vector:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = -a;</div>
</div><!-- fragment --><p>The operator returns an expression representing the negation of the given dense vector. </p>

</div>
</div>
<a class="anchor" id="gafd0d441ba5993e9b6df62c534cec34c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecDVecSubExpr&lt;T1,T2,TF&gt; blaze::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator for the subtraction of two dense vectors ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}-\vec{c} $" src="../../form_124.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the vector subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector to be subtracted from the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the two vectors. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../da/d86/structblaze_1_1Vector.html" title="Base class for N-dimensional vectors.The Vector class is a base class for all arbitrarily sized (N-di...">Vector</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator represents the subtraction of two dense vectors:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b, c;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">c = a - b;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the two involved vector element types <em>T1::ElementType</em> and <em>T2::ElementType</em>. Both vector types <em>T1</em> and <em>T2</em> as well as the two element types <em>T1::ElementType</em> and <em>T2::ElementType</em> have to be supported by the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class template.<br />
In case the current sizes of the two given vectors don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="gaf999762b08a3bd281375b5e900ebfac8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EnableIf&lt; IsNumeric&lt;T2&gt;, typename DivExprTrait&lt;T1,T2&gt;::Type &gt;::Type blaze::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division operator for the divison of a dense vector by a scalar value ( <img class="formulaInl" alt="$ \vec{a}=\vec{b}/s $" src="../../form_125.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the division. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled result vector.</dd></dl>
<p>This operator represents the division of a dense vector by a scalar value:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = a / 0.24;</div>
</div><!-- fragment --><p>The operator returns an expression representing a dense vector of the higher-order element type of the involved data types <em>T1::ElementType</em> and <em>T2</em>. Both data types <em>T1::ElementType</em> and <em>T2</em> have to be supported by the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class. ">DivTrait</a> class template. Note that this operator only works for scalar values of built-in data type.</p>
<p><b>Note:</b> A division by zero is only checked by an user assert. </p>

</div>
</div>
<a class="anchor" id="ga7718438f21d78c1c5cd61e11b620f3ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of two dense vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga521be975d8edae170b5f159468392be7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a dense vector and a sparse vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga90afa4cbe670f292f01e0a8c0989bcb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , bool TF1, typename T2 , bool TF2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; T1, TF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a sparse vector and a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side sparse vector for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the two vectors are equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb6253dd234e9b48e75e0ec02050b959"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; IsNumeric&lt; T2 &gt;, bool &gt;::Type blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T1, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a dense vector and a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The left-hand side dense vector for the comparison. </td></tr>
    <tr><td class="paramname">scalar</td><td>The right-hand side scalar value for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if all elements of the vector are equal to the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> all values of the vector are equal to the scalar value, the equality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a class="anchor" id="gaab20536da4445fc400927e431fbdf331"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; IsNumeric&lt; T1 &gt;, bool &gt;::Type blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; T2, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for the comparison of a scalar value and a dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The left-hand side scalar value for the comparison. </td></tr>
    <tr><td class="paramname">vec</td><td>The right-hand side dense vector for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if all elements of the vector are equal to the scalar, <em>false</em> if not.</dd></dl>
<p><a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> all values of the vector are equal to the scalar value, the equality test returns <em>true</em>, otherwise <em>false</em>. Note that this function can only be used with built-in, numerical data types! </p>

</div>
</div>
<a class="anchor" id="ga1a1d35bad76c6eb7ade972e00ffd6f27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecSerialExpr&lt; VT, TF &gt; blaze::serial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the serial evaluation of the given dense vector expression <em>dv</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluated dense vector.</dd></dl>
<p>The <em>serial</em> function forces the serial evaluation of the given dense vector expression <em>dv</em>. The function returns an expression representing this operation.<br />
The following example demonstrates the use of the <em>serial</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double&gt;</a> a, b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#gaeac3b9aff5df5e547819e485321f4762">serial</a>( a );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga7b68c5a39cd2fd6fb9fd91caea1747d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VT::ElementType blaze::sqrLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the dense vector square length <img class="formulaInl" alt="$|\vec{a}|^2$" src="../../form_47.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The given dense vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square length of the dense vector.</dd></dl>
<p>This function calculates the actual square length of the dense vector.</p>
<p><b>Note:</b> This operation is only defined for numeric data types. In case the element type is not a numeric data type (i.e. a user defined data type or boolean) the attempt to use the <a class="el" href="../../de/d90/group__dense__vector.html#ga7b68c5a39cd2fd6fb9fd91caea1747d1" title="Calculation of the dense vector square length . ">sqrLength()</a> function results in a compile time error! </p>

</div>
</div>
<a class="anchor" id="ga6e5a90bbef3aed0d646c7658e9130252"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DVecTransExpr&lt; VT,!TF &gt; blaze::trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the transpose of the given dense vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dv</td><td>The dense vector to be transposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transpose of the dense vector.</dd></dl>
<p>This function returns an expression representing the transpose of the given dense vector:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#acee466faebcaba59afde0fbfe22041aa">blaze::columnVector</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a006b6328815f2632d2c5ab8b869c5cf0">blaze::rowVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,columnVector&gt;</a> a;</div>
<div class="line"><a class="code" href="../../da/d9e/classblaze_1_1DynamicVector.html">blaze::DynamicVector&lt;double,rowVector&gt;</a>    b;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line">b = <a class="code" href="../../db/df0/group__dense__matrix.html#ga33cedfb37c70d3758406251f2389ecac">trans</a>( a );</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Friends</h2>
<a class="anchor" id="gab5cbae5a2188a3a84d0585371e6110c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized addition assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. </p>

</div>
</div>
<a class="anchor" id="gac8c05663dd2c32a18e765e9c810c717c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseAssign&lt;VT2&gt; &gt;::Type addAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized addition assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
<a class="anchor" id="ga34640b05b20497228d7a5d04075675f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseAssign&lt;VT2&gt; &gt;::Type addAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized addition assignment of a transpose sparse vector-transpose dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side matrix operand requires an intermediate evaluation or the right-hand side vector operand is a compound expression. </p>

</div>
</div>
<a class="anchor" id="gae6868cf3b70208eed023b4e722066815"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized addition assignment of a transpose sparse vector-dense matrix multiplication expression to a dense vector. </p>

</div>
</div>
<a class="anchor" id="gab71c44fc69da24aa7302f79fe8e94c94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized assignment of a transpose dense vector- sparse matrix multiplication expression to a dense vector. </p>

</div>
</div>
<a class="anchor" id="ga2aba8ea15c113036a6394b083f1df30c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseAssign&lt;VT2&gt; &gt;::Type assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized assignment of a transpose dense vector- transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
<a class="anchor" id="gaeddb101c9648191274078dd4cd1ec782"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment of a transpose dense vector-sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized assignment of a transpose dense vector- sparse matrix multiplication expression to a sparse vector. </p>

</div>
</div>
<a class="anchor" id="gad6eead65aff5e0a2523eb364e8ec6038"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseAssign&lt;VT2&gt; &gt;::Type assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment of a transpose dense vector-transpose sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized assignment of a transpose dense vector- transpose sparse matrix multiplication expression to a sparse vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
<a class="anchor" id="gac6d196d9ef990086dd810b1faefa572f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseAssign&lt;VT2&gt; &gt;::Type multAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized multiplication assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
<a class="anchor" id="ga7f1e8bdcac00b251731d9ecac15f407e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseAssign&lt;VT2&gt; &gt;::Type multAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized multiplication assignment of a transpose sparse vector-transpose dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side matrix operand requires an intermediate evaluation or the right-hand side vector operand is a compound expression. </p>

</div>
</div>
<a class="anchor" id="ga24e3422dd6679538dce1a983ad6f0682"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void multAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized multiplication assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. </p>

</div>
</div>
<a class="anchor" id="ga050da3682f47907ce839ebaff145168a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void multAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized multiplication assignment of a transpose sparse vector-dense matrix multiplication expression to a dense vector. </p>

</div>
</div>
<a class="anchor" id="ga24bd93308fdd31baca776036b1f5f2f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpAddAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP addition assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP addition assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="ga120fdb8759199c49ab874bc5a159532d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpAddAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP addition assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP addition assignment of a transpose sparse vector-transpose dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="ga5ef7f36795587bd4c99b9aaf4e919230"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpAddAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP addition assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="ga353c3f22a6b641ae76eddc1924b8032a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpAddAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP addition assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T+=\vec{x}^T*A $" src="../../form_136.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP addition assignment of a transpose sparse vector-dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="ga38f0eb2dc01576f29d6b8993897e8b70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="ga5f81149d9e724e60d161a7f370ffa263"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP assignment of a transpose dense vector-transpose sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a sparse vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="ga6ba0e9664a8167cd38e324a08d237ee0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="ga839146a557d218f2bb241868e14b610a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP assignment of a transpose dense vector-sparse matrix multiplication to a sparse vector ( <img class="formulaInl" alt="$ \vec{y}^T=\vec{x}^T*A $" src="../../form_132.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side sparse vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP assignment of a transpose dense vector-sparse matrix multiplication expression to a sparse vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="gad14c40190e7bc9a5c953171fc95c9fb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpMultAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP multiplication assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP multiplication assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="gabb093caf695bf4f0e5b79a7d6647461b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpMultAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP multiplication assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP multiplication assignment of a transpose sparse vector-transpose dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="gaaad3022aedfec3c5585b31b9321857dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpMultAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP multiplication assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP multiplication assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="gae118c2d6ef8ff4227a198fa0a00d3858"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpMultAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP multiplication assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T*=\vec{x}^T*A $" src="../../form_138.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP multiplication assignment of a transpose sparse vector-dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="gab71bc64cfb6265ae66eb73b6c2063450"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpSubAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP subtraction assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP subtraction assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="ga6dcfca06778c7fc69ec57ee837e9f14d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpSubAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP subtraction assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP subtraction assignment of a transpose sparse vector-transpose dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="ga0d7e98710512255aced624f7e3f66ef2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpSubAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP subtraction assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP subtraction assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="gaafac111e4c78a60c9d2d4a6f51300a82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseSMPAssign&lt;VT2&gt; &gt;::Type smpSubAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SMP subtraction assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized SMP subtraction assignment of a transpose sparse vector-dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case the expression specific parallel evaluation strategy is selected. </p>

</div>
</div>
<a class="anchor" id="ga4b97a817205a7666e3a591ae4b327e0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseAssign&lt;VT2&gt; &gt;::Type subAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d4b/classblaze_1_1TDVecTSMatMultExpr.html">TDVecTSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment of a transpose dense vector-transpose sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized subtraction assignment of a transpose dense vector-transpose sparse matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side vector operand is a compound expression or the right-hand side matrix operand requires an intermediate evaluation. </p>

</div>
</div>
<a class="anchor" id="ga813e0b0dd4ee7871c51c420cefb1ac2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; UseAssign&lt;VT2&gt; &gt;::Type subAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d4f/classblaze_1_1TSVecTDMatMultExpr.html">TSVecTDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment of a transpose sparse vector-transpose dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized subtraction assignment of a transpose sparse vector-transpose dense matrix multiplication expression to a dense vector. Due to the explicit application of the SFINAE principle, this function can only be selected by the compiler in case either the left-hand side matrix operand requires an intermediate evaluation or the right-hand side vector operand is a compound expression. </p>

</div>
</div>
<a class="anchor" id="gaa9737bc07f38a7e9144dc3fcb1c7114b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void subAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d42/classblaze_1_1TDVecSMatMultExpr.html">TDVecSMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment of a transpose dense vector-sparse matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized subtraction assignment of a transpose dense vector-sparse matrix multiplication expression to a dense vector. </p>

</div>
</div>
<a class="anchor" id="gabbe8a27b763bf7716c313756494e54dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename MT &gt; </div>
<div class="memtemplate">
template&lt;typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void subAssign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/db2/structblaze_1_1DenseVector.html">DenseVector</a>&lt; VT2, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d61/classblaze_1_1TSVecDMatMultExpr.html">TSVecDMatMultExpr</a>&lt; VT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment of a transpose sparse vector-dense matrix multiplication to a dense vector ( <img class="formulaInl" alt="$ \vec{y}^T-=\vec{x}^T*A $" src="../../form_137.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The target left-hand side dense vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side multiplication expression to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function implements the performance optimized subtraction assignment of a transpose sparse vector-dense matrix multiplication expression to a dense vector. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:55:21 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
