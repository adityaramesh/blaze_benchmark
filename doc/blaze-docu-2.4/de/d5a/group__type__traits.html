<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Type traits</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Type traits<div class="ingroups"><a class="el" href="../../d4/d3a/group__util.html">Utility module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da6/structblaze_1_1AddConst.html">blaze::AddConst&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level 'const' qualifier.The <a class="el" href="../../d7/da6/structblaze_1_1AddConst.html" title="Addition of a top level &#39;const&#39; qualifier.The AddConst type trait adds a top level &#39;const&#39; qualifier ...">AddConst</a> type trait adds a top level 'const' qualifier to the given type <em>T</em>.  <a href="../../d7/da6/structblaze_1_1AddConst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d58/structblaze_1_1AddCV.html">blaze::AddCV&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level 'const' and 'volatile' qualifier.The <a class="el" href="../../df/d58/structblaze_1_1AddCV.html" title="Addition of a top level &#39;const&#39; and &#39;volatile&#39; qualifier.The AddCV type trait adds both a top level &#39;...">AddCV</a> type trait adds both a top level 'const' and 'volatile' qualifier to the given type <em>T</em>.  <a href="../../df/d58/structblaze_1_1AddCV.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html">blaze::AddPointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level pointer.The <a class="el" href="../../d4/da6/structblaze_1_1AddPointer.html" title="Addition of a top level pointer.The AddPointer type trait adds a top level pointer to the given type ...">AddPointer</a> type trait adds a top level pointer to the given type <em>T</em>. It has the same effect as <code>blaze::RemoveReference&lt;T&gt;::Type*</code>.  <a href="../../d4/da6/structblaze_1_1AddPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d30/structblaze_1_1AddReference.html">blaze::AddReference&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level reference.In case the given type <em>T</em> is not a reference type, the <a class="el" href="../../dd/d30/structblaze_1_1AddReference.html" title="Addition of a top level reference.In case the given type T is not a reference type, the AddReference type trait adds a top level reference to the given type T. Else the resulting type Type is T. ">AddReference</a> type trait adds a top level reference to the given type <em>T</em>. Else the resulting type <em>Type</em> is <em>T</em>.  <a href="../../dd/d30/structblaze_1_1AddReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html">blaze::AddVolatile&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of a top level 'volatile' qualifier.The <a class="el" href="../../d2/df0/structblaze_1_1AddVolatile.html" title="Addition of a top level &#39;volatile&#39; qualifier.The AddVolatile type trait adds a top level &#39;volatile&#39; q...">AddVolatile</a> type trait adds a top level 'volatile' qualifier to the given type <em>T</em>.  <a href="../../d2/df0/structblaze_1_1AddVolatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc6/structblaze_1_1AlignmentOf.html">blaze::AlignmentOf&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of the required alignment of the given data type.The <a class="el" href="../../d5/dc6/structblaze_1_1AlignmentOf.html" title="Evaluation of the required alignment of the given data type.The AlignmentOf type trait template evalu...">AlignmentOf</a> type trait template evaluates the required alignment for the given data type. For instance, for fundamental data types that can be vectorized via SSE or AVX instructions, the proper alignment is 16 or 32 bytes, respectively. For all other data types, a multiple of the alignment chosen by the compiler is returned. The evaluated alignment can be queried via the nested <em>value</em> member.  <a href="../../d5/dc6/structblaze_1_1AlignmentOf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d50/structblaze_1_1Extent.html">blaze::Extent&lt; T, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the size of array bounds.Via this type trait it is possible to query at compile time for the size of a particular array extent. In case the given template argument is an array type with a rank greater than N, the <em>value</em> member enumeration is set to the number of elements of the N'th array dimension. In all other cases, and especially in case the N'th array dimension is incomplete, <em>value</em> is set to 0.  <a href="../../d2/d50/structblaze_1_1Extent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d90/structblaze_1_1HasSize.html">blaze::HasSize&lt; T, Size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This class offers the possibility to test the size of a type at compile time. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> is exactly <em><a class="el" href="../../df/d5d/structblaze_1_1Size.html" title="Compile time evaluation of the size of a vector.The Size type trait evaluates the size of the given v...">Size</a></em> bytes large, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/d90/structblaze_1_1HasSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d94/structblaze_1_1Has1Byte.html">blaze::Has1Byte&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly one byte. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has one byte, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d94/structblaze_1_1Has1Byte.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d49/structblaze_1_1Has2Bytes.html">blaze::Has2Bytes&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly two bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has two bytes, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d49/structblaze_1_1Has2Bytes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d99/structblaze_1_1Has4Bytes.html">blaze::Has4Bytes&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly four bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has four bytes, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d99/structblaze_1_1Has4Bytes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df1/structblaze_1_1Has8Bytes.html">blaze::Has8Bytes&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This type trait offers the possibility to test whether a given type has a size of exactly four bytes. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the type <em>T</em> has four bytes, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/df1/structblaze_1_1Has8Bytes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d76/classblaze_1_1HaveSameSize.html">blaze::HaveSameSize&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time size check.This class offers the possibility to test the size of two types at compile time. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> an object of type <em>T1</em> has the same size as an object of type <em>T2</em>, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d76/classblaze_1_1HaveSameSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/daf/structblaze_1_1IsArithmetic.html">blaze::IsArithmetic&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for arithmetic data types.This type trait tests whether or not the given template parameter is a (possibly cv-qualified) arithmetic (integral or floating point) data type. In case the type is an arithmetic type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../dc/daf/structblaze_1_1IsArithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d2c/structblaze_1_1IsArray.html">blaze::IsArray&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../d9/d2c/structblaze_1_1IsArray.html" title="Compile time type check.The IsArray type trait tests whether or not the given template parameter is a...">IsArray</a> type trait tests whether or not the given template parameter is an array type. In case the given data type is an array type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is set to <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../d9/d2c/structblaze_1_1IsArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d07/classblaze_1_1IsBaseOf.html">blaze::IsBaseOf&lt; Base, Derived &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time analysis of an inheritance relationship.This type trait tests for an inheritance relationship between the two types <em>Base</em> and <em>Derived</em>. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>Derived</em> is a type derived from <em>Base</em> or the same type as <em>Base</em> the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d07/classblaze_1_1IsBaseOf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d48/structblaze_1_1IsBoolean.html">blaze::IsBoolean&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for boolean types.This type trait tests whether or not the given template parameter is of boolean type. In case the type is a boolean (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d7/d48/structblaze_1_1IsBoolean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1c/structblaze_1_1IsBuiltin.html">blaze::IsBuiltin&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for built-in data types.This type trait tests whether or not the given template parameter is a built-in/fundamental data type. In case the type is a built-in type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d1c/structblaze_1_1IsBuiltin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d32/structblaze_1_1IsCharacter.html">blaze::IsCharacter&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for character types.This type trait tests whether or not the given template parameter is a character type (i.e., either char, signed char, unsigned char, or wchar_t, possibly cv-qualified). In case the type is a character type (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d32/structblaze_1_1IsCharacter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d97/structblaze_1_1IsClass.html">blaze::IsClass&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.The <a class="el" href="../../dd/d97/structblaze_1_1IsClass.html" title="Compile time type check.The IsClass type trait tests whether or not the given template parameter is a...">IsClass</a> type trait tests whether or not the given template parameter is a (possibly cv-qualified) class type. In case the given data type is a class type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is set to <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em> and the class derives from <em>FalseType</em>.  <a href="../../dd/d97/structblaze_1_1IsClass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da9/structblaze_1_1IsComplex.html">blaze::IsComplex&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for complex types.This type trait tests whether or not the given template parameter is a complex data type. In case the type is a complex data type (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/da9/structblaze_1_1IsComplex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html">blaze::IsConst&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for constant data types.The <a class="el" href="../../d4/d5f/structblaze_1_1IsConst.html" title="Compile time check for constant data types.The IsConst type trait tests whether or not the given temp...">IsConst</a> type trait tests whether or not the given template parameter is a (top level) const-qualified data type. In case the given data type is const-qualified, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/d5f/structblaze_1_1IsConst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d98/structblaze_1_1IsConvertible.html">blaze::IsConvertible&lt; From, To &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time pointer relationship constraint.This type traits tests whether the first given template argument can be converted to the second template argument via copy construction. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> the first argument can be converted to the second argument, the <em>value</em> member enumeration is set to 1, the nested type definition <em>type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/d98/structblaze_1_1IsConvertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d60/structblaze_1_1IsDouble.html">blaze::IsDouble&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for double precision floating point types.This type trait tests whether or not the given template parameter is of double type. In case the type is double (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d60/structblaze_1_1IsDouble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d47/structblaze_1_1IsEmpty.html">blaze::IsEmpty&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter is an empty class type, i.e. a type without member data and virtual functions. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> it is an empty class type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d47/structblaze_1_1IsEmpty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d07/structblaze_1_1IsFloat.html">blaze::IsFloat&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for single precision floating point types.This type trait tests whether or not the given template parameter is of float type. In case the type is float (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../db/d07/structblaze_1_1IsFloat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html">blaze::IsFloatingPoint&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for floating point data types.This type trait tests whether or not the given template parameter is a floating point data type (ignoring the cv-qualifiers). In case the type is a floating point data type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d6/dc0/structblaze_1_1IsFloatingPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d5e/structblaze_1_1IsInteger.html">blaze::IsInteger&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for integer types.This type trait tests whether or not the given template parameter is an integer type (i.e., either (signed) int or unsigned int, possibly cv-qualified). In case the type is an integer type (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/d5e/structblaze_1_1IsInteger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d73/structblaze_1_1IsIntegral.html">blaze::IsIntegral&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for integral data types.This type trait tests whether or not the given template parameter is an integral data type. In case the type is an integral data type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d73/structblaze_1_1IsIntegral.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d40/structblaze_1_1IsLong.html">blaze::IsLong&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for long integer types.This type trait tests whether or not the given template parameter is a long integer type (i.e., either (signed) long or unsigned long, possibly cv-qualified). In case the type is a long integer type (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d5/d40/structblaze_1_1IsLong.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d34/structblaze_1_1IsLongDouble.html">blaze::IsLongDouble&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for extended precision floating point types.This type trait tests whether or not the given template parameter is of long double type. In case the type is long double (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d2/d34/structblaze_1_1IsLongDouble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">blaze::IsNumeric&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for numeric types.This type trait tests whether or not the given template parameter is a numeric data type. Blaze considers all integral (except <em>bool</em>), floating point, and complex data types as numeric data types. In case the type is a numeric type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d8/dea/structblaze_1_1IsNumeric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db8/structblaze_1_1IsObject.html">blaze::IsObject&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter <em>T</em> is an object type. All types are considered object types except references, <em>void</em>, and function types. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>T</em> is an object type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/db8/structblaze_1_1IsObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db0/structblaze_1_1IsPod.html">blaze::IsPod&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for pod data types.This type trait tests whether or not the given template parameter is a POD (Plain Old Data). In case the type is a POD, the <em>value</em> member enumeration is set o 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/db0/structblaze_1_1IsPod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0f/structblaze_1_1IsPointer.html">blaze::IsPointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter is a pointer type (including function pointers, but excluding pointers to members) or not. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> it is a pointer type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d0f/structblaze_1_1IsPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dad/structblaze_1_1IsReference.html">blaze::IsReference&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type check.This class tests whether the given template parameter <em>T</em> is a reference type (including references to functions). <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> it is a reference type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d1/dad/structblaze_1_1IsReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df1/structblaze_1_1IsStrictlySame.html">blaze::IsStrictlySame&lt; A, B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type relationship analysis.This class tests if the two data types <em>A</em> and <em>B</em> are equal. For this type comparison, the cv-qualifiers of both data types are not ignored. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>A</em> and <em>B</em> are the same data type, then the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d4/df1/structblaze_1_1IsStrictlySame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d89/structblaze_1_1IsSame.html">blaze::IsSame&lt; A, B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type relationship analysis.This class tests if the two data types <em>A</em> and <em>B</em> are equal. For this type comparison, the cv-qualifiers of both data types are ignored. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>A</em> and <em>B</em> are the same data type (ignoring the cv-qualifiers), then the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dc/d89/structblaze_1_1IsSame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d59/structblaze_1_1IsShort.html">blaze::IsShort&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for short integer types.This type trait tests whether or not the given template parameter is a short integer type (i.e., either (signed) short or unsigned short, possibly cv-qualified). In case the type is a short integer type (ignoring the cv-qualifiers), the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d0/d59/structblaze_1_1IsShort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/def/structblaze_1_1IsSigned.html">blaze::IsSigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for signed data types.This type trait tests whether or not the given template parameter is a signed integral data type. In case the type is a signed (possibly cv-qualified) data type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../dd/def/structblaze_1_1IsSigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc7/structblaze_1_1IsUnion.html">blaze::IsUnion&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for union data types.This type trait tests whether or not the given template parameter is a union data type. In case the type is a union, the <em>value</em> member enumeration is set o 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/dc7/structblaze_1_1IsUnion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d8c/structblaze_1_1IsUnsigned.html">blaze::IsUnsigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for unsigned data types.This type trait tests whether or not the given template parameter is an unsigned, integral data type. In case the type is an unsigned (possibly cv-qualified) data type, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../de/d8c/structblaze_1_1IsUnsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0e/structblaze_1_1IsVectorizable.html">blaze::IsVectorizable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for vectorizable types.Depending on the available instruction set (SSE, SSE2, SSE3, SSE4, AVX, AVX2, MIC, ...), this type trait tests whether or not the given template parameter is a vectorizable type, i.e. a type for which intrinsic vector operations and optimizations can be used. Currently, only signed/unsigned short, signed/unsigned int, signed/unsigned long, float, double, complex&lt;float&gt;, and complex&lt;double&gt; are considered to be vectorizable types. In case the type is vectorizable, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../da/d0e/structblaze_1_1IsVectorizable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6b/structblaze_1_1IsVoid.html">blaze::IsVoid&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for the <em>void</em> data type.This type trait tests whether or not the given template parameter is of type <em>void</em> (ignoring the cv-qualifiers). In case the type is of type <em>void</em>, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../d9/d6b/structblaze_1_1IsVoid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html">blaze::IsVolatile&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for volatile data types.The <a class="el" href="../../df/db9/structblaze_1_1IsVolatile.html" title="Compile time check for volatile data types.The IsVolatile type trait tests whether or not the given t...">IsVolatile</a> type trait tests whether or not the given template parameter is a (top level) volatile-qualified data type. In case the given data type is volatile, the <em>value</em> member enumeration is set to 1, the nested type definition <em>Type</em> is <em>TrueType</em>, and the class derives from <em>TrueType</em>. Otherwise <em>value</em> is set to 0, <em>Type</em> is <em>FalseType</em>, and the class derives from <em>FalseType</em>.  <a href="../../df/db9/structblaze_1_1IsVolatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/da3/structblaze_1_1MakeSigned.html">blaze::MakeSigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type conversion into a signed integral type.This type trait provides the feature to convert the given integral or enumeration type <em>T</em> to the corresponding signed integral data type with the same size and with the same cv-qualifiers. Note that in case <em>T</em> is bool or a non-integral data type, a compilation error is created.  <a href="../../da/da3/structblaze_1_1MakeSigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd7/structblaze_1_1MakeUnsigned.html">blaze::MakeUnsigned&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time type conversion into an unsigned integral type.This type trait provides the feature to convert the given integral or enumeration type <em>T</em> to the corresponding unsigned integral data type with the same size and with the same cv-qualifiers. Note that in case <em>T</em> is bool or a non-integral data type, a compilation error is created.  <a href="../../d9/dd7/structblaze_1_1MakeUnsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db0/structblaze_1_1Rank.html">blaze::Rank&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for array ranks.This type trait determines the rank of the given template argument. In case the given type is an array type, the nested <em>value</em> member enumeration is set to the number of dimensions of <em>T</em>. Otherwise <em>value</em> is set to 0.  <a href="../../df/db0/structblaze_1_1Rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html">blaze::RemoveAllExtents&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of all array extents.The <a class="el" href="../../de/d59/structblaze_1_1RemoveAllExtents.html" title="Removal of all array extents.The RemoveAllExtents type trait removes all array extents from the given...">RemoveAllExtents</a> type trait removes all array extents from the given type <em>T</em>.  <a href="../../de/d59/structblaze_1_1RemoveAllExtents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html">blaze::RemoveConst&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of const-qualifiers.The <a class="el" href="../../d9/d25/structblaze_1_1RemoveConst.html" title="Removal of const-qualifiers.The RemoveConst type trait removes all top level &#39;const&#39; qualifiers from ...">RemoveConst</a> type trait removes all top level 'const' qualifiers from the given type <em>T</em>.  <a href="../../d9/d25/structblaze_1_1RemoveConst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html">blaze::RemoveCV&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of top level cv-qualifiers.The <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait removes all top level cv-qualifiers from the given type <em>T</em>.  <a href="../../d0/d1c/structblaze_1_1RemoveCV.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html">blaze::RemoveExtent&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of the top level array extent.The <a class="el" href="../../d7/d88/structblaze_1_1RemoveExtent.html" title="Removal of the top level array extent.The RemoveExtent type trait removes the top level array extent ...">RemoveExtent</a> type trait removes the top level array extent from the given type <em>T</em>.  <a href="../../d7/d88/structblaze_1_1RemoveExtent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d04/structblaze_1_1RemovePointer.html">blaze::RemovePointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of pointer modifiers.The <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait removes any pointer modifiers from the given type <em>T</em>.  <a href="../../df/d04/structblaze_1_1RemovePointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/df4/structblaze_1_1RemoveReference.html">blaze::RemoveReference&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of reference modifiers.The <a class="el" href="../../d0/d1c/structblaze_1_1RemoveCV.html" title="Removal of top level cv-qualifiers.The RemoveCV type trait removes all top level cv-qualifiers from t...">RemoveCV</a> type trait removes any reference modifiers from the given type <em>T</em>.  <a href="../../d5/df4/structblaze_1_1RemoveReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html">blaze::RemoveVolatile&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removal of volatile-qualifiers.The <a class="el" href="../../d9/de6/structblaze_1_1RemoveVolatile.html" title="Removal of volatile-qualifiers.The RemoveVolatile type trait removes all top level &#39;volatile&#39; qualifi...">RemoveVolatile</a> type trait removes all top level 'volatile' qualifiers from the given type <em>T</em>.  <a href="../../d9/de6/structblaze_1_1RemoveVolatile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:55:22 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
