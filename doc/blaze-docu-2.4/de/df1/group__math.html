<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Math module</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Math module</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:d3/d7d/group__adaptors"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7d/group__adaptors.html">Adaptors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d95/group__math__constraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d95/group__math__constraints.html">Compile time constraints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/d7a/group__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7a/group__matrix.html">Matrices</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/dcf/group__vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcf/group__vector.html">Vectors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:df/daa/group__intrinsics"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daa/group__intrinsics.html">Intrinsics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/d9b/group__math__serialization"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d9b/group__math__serialization.html">Serialization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:da/d5b/group__math__shims"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d5b/group__math__shims.html">Shims</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d00/group__smp"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d00/group__smp.html">Shared memory parallelization module</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d8/d92/group__math__traits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d92/group__math__traits.html">Expression traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:df/d7b/group__math__type__traits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d7b/group__math__type__traits.html">Type traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/d48/group__views"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d48/group__views.html">Views</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">blaze::NegativeAccuracy&lt; A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative computation accuracy for floating point data types.The <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the negative computation accuracy of the Blaze library for any floating point data type. In order to assign a negative accuracy value, the <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.  <a href="../../da/d32/classblaze_1_1NegativeAccuracy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">blaze::Accuracy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> accuracy for floating point data types.The <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the computation accuracy of the Blaze library for any floating point data type. In order to assign an accuracy value, the <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.<br />
In order to handle accuracy values conveniently, the global <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> instance <a class="el" href="../../de/df1/group__math.html#ga625b0b7ac3b908bc3266c6d834630806" title="Global Accuracy instance.The blaze::accuracy instance can be used wherever a floating point data type...">blaze::accuracy</a> is provided, which can be used wherever a floating point data value is required.  <a href="../../d6/d75/classblaze_1_1Accuracy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">blaze::DenseIterator&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a generic iterator for dense vectors and matrices.The <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html" title="Implementation of a generic iterator for dense vectors and matrices.The DenseIterator represents a ge...">DenseIterator</a> represents a generic random-access iterator that can be used for dense vectors and specific rows/columns of dense matrices.  <a href="../../dc/de8/classblaze_1_1DenseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">blaze::NegativeEpsilon&lt; E &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative epsilon value for floating point data types.The <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the negative smallest difference between two values of any floating point data type. In order to assign a negative epsilon value, the <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.  <a href="../../d9/d70/classblaze_1_1NegativeEpsilon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">blaze::Epsilon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical epsilon value for floating point data types.The <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class. It represents the smallest difference between two values of any floating point data type. In order to assign an epsilon value, the <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> class can be implicitly converted to the three built-in floating point data types float, double and long double.<br />
In order to handle epsilon values conveniently, the global <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> instance <a class="el" href="../../de/df1/group__math.html#ga9a02d7d60cd864ce158adb1cdf17989c" title="Global Epsilon instance.The blaze::epsilon instance can be used wherever a floating point data type i...">blaze::epsilon</a> is provided, which can be used wherever a floating point data type is required.  <a href="../../dd/d28/classblaze_1_1Epsilon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3f/structblaze_1_1AbsExpr.html">blaze::AbsExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all absolute value expression templates.The <a class="el" href="../../dc/d3f/structblaze_1_1AbsExpr.html" title="Base class for all absolute value expression templates.The AbsExpr class serves as a tag for all expr...">AbsExpr</a> class serves as a tag for all expression templates that implement an absolute value operation. All classes, that represent an absolute value operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as absolute value expression template. Only in case a class is derived from the <a class="el" href="../../dc/d3f/structblaze_1_1AbsExpr.html" title="Base class for all absolute value expression templates.The AbsExpr class serves as a tag for all expr...">AbsExpr</a> base class, the <a class="el" href="../../dd/dba/structblaze_1_1IsAbsExpr.html" title="Compile time check whether the given type is an absolute value expression template.This type trait class tests whether or not the given type Type is an absolute value expression template. In order to qualify as a valid absolute value expression template, the given type has to derive (publicly or privately) from the AbsExpr base class. In case the given type is a valid absolute value expression template, the value member enumeration is set to 1, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to 0, Type is FalseType, and the class derives from FalseType. ">IsAbsExpr</a> type trait recognizes the class as valid absolute value expression template.  <a href="../../dc/d3f/structblaze_1_1AbsExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d2f/structblaze_1_1AddExpr.html">blaze::AddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all addition expression templates.The <a class="el" href="../../d5/d2f/structblaze_1_1AddExpr.html" title="Base class for all addition expression templates.The AddExpr class serves as a tag for all expression...">AddExpr</a> class serves as a tag for all expression templates that implement mathematical additions. All classes, that represent a mathematical addition (vector additions and matrix additions) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as addition expression template. Only in case a class is derived from the <a class="el" href="../../d5/d2f/structblaze_1_1AddExpr.html" title="Base class for all addition expression templates.The AddExpr class serves as a tag for all expression...">AddExpr</a> base class, the <a class="el" href="../../da/d0e/structblaze_1_1IsAddExpr.html" title="Compile time check whether the given type is an addition expression template.This type trait class te...">IsAddExpr</a> type trait recognizes the class as valid addition expression template.  <a href="../../d5/d2f/structblaze_1_1AddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/deb/structblaze_1_1Column.html">blaze::Column</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all columns.The <a class="el" href="../../d2/deb/structblaze_1_1Column.html" title="Base class for all columns.The Column class serves as a tag for all columns (i.e. dense and sparse co...">Column</a> class serves as a tag for all columns (i.e. dense and sparse columns). All classes that represent a column and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a column. Only in case a class is derived from the <a class="el" href="../../d2/deb/structblaze_1_1Column.html" title="Base class for all columns.The Column class serves as a tag for all columns (i.e. dense and sparse co...">Column</a> base class, the <a class="el" href="../../d6/d61/structblaze_1_1IsColumn.html" title="Compile time check for columns.This type trait tests whether or not the given template parameter is a...">IsColumn</a> type trait recognizes the class as valid column.  <a href="../../d2/deb/structblaze_1_1Column.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dd5/structblaze_1_1Computation.html">blaze::Computation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all compute expression templates.The <a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> class serves as a tag for all computational expression templates. All classes, that represent a mathematical computation (addition, subtraction, multiplication, division, absolute value calculation, ...) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as computational expression template. Only in case a class is derived from the <a class="el" href="../../de/dd5/structblaze_1_1Computation.html" title="Base class for all compute expression templates.The Computation class serves as a tag for all computa...">Computation</a> base class, the <a class="el" href="../../db/daf/structblaze_1_1IsComputation.html" title="Compile time check whether the given type is a computational expression template.This type trait clas...">IsComputation</a> type trait recognizes the class as valid computational expression template.  <a href="../../de/dd5/structblaze_1_1Computation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc0/structblaze_1_1CrossExpr.html">blaze::CrossExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all cross product expression templates.The <a class="el" href="../../dc/dc0/structblaze_1_1CrossExpr.html" title="Base class for all cross product expression templates.The CrossExpr class serves as a tag for all exp...">CrossExpr</a> class serves as a tag for all expression templates that implement mathematical cross products. All classes, that represent a mathematical cross product and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as cross product expression template. Only in case a class is derived from the <a class="el" href="../../dc/dc0/structblaze_1_1CrossExpr.html" title="Base class for all cross product expression templates.The CrossExpr class serves as a tag for all exp...">CrossExpr</a> base class, the <a class="el" href="../../dc/d43/structblaze_1_1IsCrossExpr.html" title="Compile time check whether the given type is a cross product expression template.This type trait clas...">IsCrossExpr</a> type trait recognizes the class as valid cross product expression template.  <a href="../../dc/dc0/structblaze_1_1CrossExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d46/structblaze_1_1DivExpr.html">blaze::DivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all division expression templates.The <a class="el" href="../../dd/d46/structblaze_1_1DivExpr.html" title="Base class for all division expression templates.The DivExpr class serves as a tag for all expression...">DivExpr</a> class serves as a tag for all expression templates that implement mathematical divisions. All classes, that represent a mathematical division (vector/scalar divisions and matrix/scalar division) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as division expression template. Only in case a class is derived from the <a class="el" href="../../dd/d46/structblaze_1_1DivExpr.html" title="Base class for all division expression templates.The DivExpr class serves as a tag for all expression...">DivExpr</a> base class, the <a class="el" href="../../d7/d13/structblaze_1_1IsDivExpr.html" title="Compile time check whether the given type is a division expression template.This type trait class tes...">IsDivExpr</a> type trait recognizes the class as valid division expression template.  <a href="../../dd/d46/structblaze_1_1DivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d24/structblaze_1_1EvalExpr.html">blaze::EvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all evaluation expression templates.The <a class="el" href="../../db/d24/structblaze_1_1EvalExpr.html" title="Base class for all evaluation expression templates.The EvalExpr class serves as a tag for all express...">EvalExpr</a> class serves as a tag for all expression templates that implement an evaluation operation. All classes, that represent an evaluation operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as evaluation expression template. Only in case a class is derived from the <a class="el" href="../../db/d24/structblaze_1_1EvalExpr.html" title="Base class for all evaluation expression templates.The EvalExpr class serves as a tag for all express...">EvalExpr</a> base class, the <a class="el" href="../../d6/d62/structblaze_1_1IsEvalExpr.html" title="Compile time check whether the given type is an evaluation expression template.This type trait class ...">IsEvalExpr</a> type trait recognizes the class as valid evaluation expression template.  <a href="../../db/d24/structblaze_1_1EvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d2e/structblaze_1_1Expression.html">blaze::Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all expression templates.The <a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> class is the base class for all expression templates. All classes, that represent a mathematical operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as expression template. Only in case a class is derived from the <a class="el" href="../../d5/d2e/structblaze_1_1Expression.html" title="Base class for all expression templates.The Expression class is the base class for all expression tem...">Expression</a> base class, the <a class="el" href="../../d2/d44/structblaze_1_1IsExpression.html" title="Compile time check whether the given type is an expression template.This type trait class tests wheth...">IsExpression</a> type trait recognizes the class as valid expression template.  <a href="../../d5/d2e/structblaze_1_1Expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d67/structblaze_1_1MatAbsExpr.html">blaze::MatAbsExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix absolute value expression templates.The <a class="el" href="../../d3/d67/structblaze_1_1MatAbsExpr.html" title="Base class for all matrix absolute value expression templates.The MatAbsExpr class serves as a tag fo...">MatAbsExpr</a> class serves as a tag for all expression templates that implement a matrix absolute value operation. All classes, that represent a matrix absolute value operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix absolute value expression template. Only in case a class is derived from the <a class="el" href="../../d3/d67/structblaze_1_1MatAbsExpr.html" title="Base class for all matrix absolute value expression templates.The MatAbsExpr class serves as a tag fo...">MatAbsExpr</a> base class, the <a class="el" href="../../d2/d69/structblaze_1_1IsMatAbsExpr.html" title="Compile time check whether the given type is a matrix absolute value expression template.This type trait class tests whether or not the given type Type is a matrix absolute value expression template. In order to qualify as a valid matrix absolute value expression template, the given type has to derive (publicly or privately) from the MatAbsExpr base class. In case the given type is a valid matrix absolute value expression template, the value member enumeration is set to 1, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to 0, Type is FalseType, and the class derives from FalseType. ">IsMatAbsExpr</a> type trait recognizes the class as valid matrix absolute value expression template.  <a href="../../d3/d67/structblaze_1_1MatAbsExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d77/structblaze_1_1MatEvalExpr.html">blaze::MatEvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix evaluation expression templates.The <a class="el" href="../../d5/d77/structblaze_1_1MatEvalExpr.html" title="Base class for all matrix evaluation expression templates.The MatEvalExpr class serves as a tag for a...">MatEvalExpr</a> class serves as a tag for all expression templates that implement a matrix evaluation operation. All classes, that represent a matrix evaluation operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix evaluation expression template. Only in case a class is derived from the <a class="el" href="../../d5/d77/structblaze_1_1MatEvalExpr.html" title="Base class for all matrix evaluation expression templates.The MatEvalExpr class serves as a tag for a...">MatEvalExpr</a> base class, the <a class="el" href="../../da/d49/structblaze_1_1IsMatEvalExpr.html" title="Compile time check whether the given type is a matrix evaluation expression template.This type trait class tests whether or not the given type Type is a matrix evaluation expression template. In order to qualify as a valid matrix evaluation expression template, the given type has to derive (publicly or privately) from the MatEvalExpr base class. In case the given type is a valid matrix evaluation expression template, the value member enumeration is set to 1, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to 0, Type is FalseType, and the class derives from FalseType. ">IsMatEvalExpr</a> type trait recognizes the class as valid matrix evaluation expression template.  <a href="../../d5/d77/structblaze_1_1MatEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dea/structblaze_1_1MatMatAddExpr.html">blaze::MatMatAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/matrix addition expression templates.The <a class="el" href="../../d0/dea/structblaze_1_1MatMatAddExpr.html" title="Base class for all matrix/matrix addition expression templates.The MatMatAddExpr class serves as a ta...">MatMatAddExpr</a> class serves as a tag for all expression templates that implement a matrix/matrix addition. All classes, that represent a matrix addition and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix addition expression template. Only in case a class is derived from the <a class="el" href="../../d0/dea/structblaze_1_1MatMatAddExpr.html" title="Base class for all matrix/matrix addition expression templates.The MatMatAddExpr class serves as a ta...">MatMatAddExpr</a> base class, the <a class="el" href="../../db/d11/structblaze_1_1IsMatMatAddExpr.html" title="Compile time check whether the given type is a matrix/matrix addition expression template.This type trait class tests whether or not the given type Type is a matrix/matrix addition expression template. In order to qualify as a valid matrix addition expression template, the given type has to derive (publicly or privately) from the MatMatAddExpr base class. In case the given type is a valid matrix addition expression template, the value member enumeration is set to 1, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to 0, Type is FalseType, and the class derives from FalseType. ">IsMatMatAddExpr</a> type trait recognizes the class as valid matrix addition expression template.  <a href="../../d0/dea/structblaze_1_1MatMatAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d0d/structblaze_1_1MatMatMultExpr.html">blaze::MatMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/matrix multiplication expression templates.The <a class="el" href="../../d5/d0d/structblaze_1_1MatMatMultExpr.html" title="Base class for all matrix/matrix multiplication expression templates.The MatMatMultExpr class serves ...">MatMatMultExpr</a> class serves as a tag for all expression templates that implement a matrix/matrix multiplication. All classes, that represent a matrix multiplication and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix multiplication expression template. Only in case a class is derived from the <a class="el" href="../../d5/d0d/structblaze_1_1MatMatMultExpr.html" title="Base class for all matrix/matrix multiplication expression templates.The MatMatMultExpr class serves ...">MatMatMultExpr</a> base class, the <a class="el" href="../../d2/db5/structblaze_1_1IsMatMatMultExpr.html" title="Compile time check whether the given type is a matrix/matrix multiplication expression template...">IsMatMatMultExpr</a> type trait recognizes the class as valid matrix multiplication expression template.  <a href="../../d5/d0d/structblaze_1_1MatMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dbd/structblaze_1_1MatMatSubExpr.html">blaze::MatMatSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/matrix subtraction expression templates.The <a class="el" href="../../db/dbd/structblaze_1_1MatMatSubExpr.html" title="Base class for all matrix/matrix subtraction expression templates.The MatMatSubExpr class serves as a...">MatMatSubExpr</a> class serves as a tag for all expression templates that implement a matrix/matrix subtraction. All classes, that represent a matrix subtraction and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix subtraction expression template. Only in case a class is derived from the <a class="el" href="../../db/dbd/structblaze_1_1MatMatSubExpr.html" title="Base class for all matrix/matrix subtraction expression templates.The MatMatSubExpr class serves as a...">MatMatSubExpr</a> base class, the <a class="el" href="../../dc/d07/structblaze_1_1IsMatMatSubExpr.html" title="Compile time check whether the given type is a matrix/matrix subtraction expression template...">IsMatMatSubExpr</a> type trait recognizes the class as valid matrix subtraction expression template.  <a href="../../db/dbd/structblaze_1_1MatMatSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dc1/structblaze_1_1MatScalarDivExpr.html">blaze::MatScalarDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/scalar divsion expression templates.The <a class="el" href="../../d2/dc1/structblaze_1_1MatScalarDivExpr.html" title="Base class for all matrix/scalar divsion expression templates.The MatScalarDivExpr class serves as a ...">MatScalarDivExpr</a> class serves as a tag for all expression templates that implement a matrix/scalar divsion. All classes, that represent a matrix/scalar divsion and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix/scalar divsion expression template. Only in case a class is derived from the <a class="el" href="../../d2/dc1/structblaze_1_1MatScalarDivExpr.html" title="Base class for all matrix/scalar divsion expression templates.The MatScalarDivExpr class serves as a ...">MatScalarDivExpr</a> base class, the <a class="el" href="../../df/dd2/structblaze_1_1IsMatScalarDivExpr.html" title="Compile time check whether the given type is a matrix/scalar division expression template.This type trait class tests whether or not the given type Type is a matrix/scalar division expression template. In order to qualify as a valid matrix/scalar division expression template, the given type has to derive (publicly or privately) from the MatScalarDivExpr base class. In case the given type is a valid matrix/scalar division expression template, the value member enumeration is set to 1, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to 0, Type is FalseType, and the class derives from FalseType. ">IsMatScalarDivExpr</a> type trait recognizes the class as valid matrix/scalar divsion expression template.  <a href="../../d2/dc1/structblaze_1_1MatScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0e/structblaze_1_1MatScalarMultExpr.html">blaze::MatScalarMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/scalar multiplication expression templates.The <a class="el" href="../../da/d0e/structblaze_1_1MatScalarMultExpr.html" title="Base class for all matrix/scalar multiplication expression templates.The MatScalarMultExpr class serv...">MatScalarMultExpr</a> class serves as a tag for all expression templates that implement a matrix/scalar multiplication. All classes, that represent a matrix/scalar multiplication and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix/scalar multiplication expression template. Only in case a class is derived from the <a class="el" href="../../da/d0e/structblaze_1_1MatScalarMultExpr.html" title="Base class for all matrix/scalar multiplication expression templates.The MatScalarMultExpr class serv...">MatScalarMultExpr</a> base class, the <a class="el" href="../../d5/db6/structblaze_1_1IsMatScalarMultExpr.html" title="Compile time check whether the given type is a matrix/scalar multiplication expression template...">IsMatScalarMultExpr</a> type trait recognizes the class as valid matrix/scalar multiplication expression template.  <a href="../../da/d0e/structblaze_1_1MatScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2f/structblaze_1_1MatSerialExpr.html">blaze::MatSerialExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix serial evaluation expression templates.The <a class="el" href="../../d6/d2f/structblaze_1_1MatSerialExpr.html" title="Base class for all matrix serial evaluation expression templates.The MatSerialExpr class serves as a ...">MatSerialExpr</a> class serves as a tag for all expression templates that enforce a serial evaluation of a matrix. All classes, that represent a matrix serialization operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix serial evaluation expression template. Only in case a class is derived from the <a class="el" href="../../d6/d2f/structblaze_1_1MatSerialExpr.html" title="Base class for all matrix serial evaluation expression templates.The MatSerialExpr class serves as a ...">MatSerialExpr</a> base class, the <a class="el" href="../../dc/dba/structblaze_1_1IsMatSerialExpr.html" title="Compile time check whether the given type is a matrix serial evaluation expression template...">IsMatSerialExpr</a> type trait recognizes the class as valid matrix serial evaluation expression template.  <a href="../../d6/d2f/structblaze_1_1MatSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d54/structblaze_1_1MatTransExpr.html">blaze::MatTransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix transposition expression templates.The <a class="el" href="../../d7/d54/structblaze_1_1MatTransExpr.html" title="Base class for all matrix transposition expression templates.The MatTransExpr class serves as a tag f...">MatTransExpr</a> class serves as a tag for all expression templates that implement a matrix transposition operation. All classes, that represent a matrix transposition operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix transposition expression template. Only in case a class is derived from the <a class="el" href="../../d7/d54/structblaze_1_1MatTransExpr.html" title="Base class for all matrix transposition expression templates.The MatTransExpr class serves as a tag f...">MatTransExpr</a> base class, the <a class="el" href="../../dd/da5/structblaze_1_1IsMatTransExpr.html" title="Compile time check whether the given type is a matrix transposition expression template.This type trait class tests whether or not the given type Type is a matrix transposition expression template. In order to qualify as a valid matrix transposition expression template, the given type has to derive (publicly or privately) from the MatTransExpr base class. In case the given type is a valid matrix transposition expression template, the value member enumeration is set to 1, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to 0, Type is FalseType, and the class derives from FalseType. ">IsMatTransExpr</a> type trait recognizes the class as valid matrix transposition expression template.  <a href="../../d7/d54/structblaze_1_1MatTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de7/structblaze_1_1MatVecMultExpr.html">blaze::MatVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all matrix/vector multiplication expression templates.The <a class="el" href="../../db/de7/structblaze_1_1MatVecMultExpr.html" title="Base class for all matrix/vector multiplication expression templates.The MatVecMultExpr class serves ...">MatVecMultExpr</a> class serves as a tag for all expression templates that implement a matrix/vector multiplication. All classes, that represent a matrix/vector multiplication and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as matrix/vector multiplication expression template. Only in case a class is derived from the <a class="el" href="../../db/de7/structblaze_1_1MatVecMultExpr.html" title="Base class for all matrix/vector multiplication expression templates.The MatVecMultExpr class serves ...">MatVecMultExpr</a> base class, the <a class="el" href="../../db/d84/structblaze_1_1IsMatVecMultExpr.html" title="Compile time check whether the given type is a matrix/vector multiplication expression template...">IsMatVecMultExpr</a> type trait recognizes the class as valid matrix/vector multiplication expression template.  <a href="../../db/de7/structblaze_1_1MatVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dfd/structblaze_1_1MultExpr.html">blaze::MultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all multiplication expression templates.The <a class="el" href="../../df/dfd/structblaze_1_1MultExpr.html" title="Base class for all multiplication expression templates.The MultExpr class serves as a tag for all exp...">MultExpr</a> class serves as a tag for all expression templates that implement mathematical multiplications. All classes, that represent a mathematical multiplication (element-wise vector multiplications, matrix/vector multiplications, vector/matrix multiplications and matrix/matrix multiplications) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as multiplication expression template. Only in case a class is derived from the <a class="el" href="../../df/dfd/structblaze_1_1MultExpr.html" title="Base class for all multiplication expression templates.The MultExpr class serves as a tag for all exp...">MultExpr</a> base class, the <a class="el" href="../../d0/dd3/structblaze_1_1IsMultExpr.html" title="Compile time check whether the given type is a multiplication expression template.This type trait class tests whether or not the given type Type is a multiplication expression template (i.e. an expression representing an element-wise vector multiplication, a matrix/vector multiplication, a vector/matrix multiplication, or a matrix multiplication). In order to qualify as a valid multiplication expression template, the given type has to derive (publicly or privately) from the MultExpr base class. In case the given type is a valid multiplication expression template, the value member enumeration is set to 1, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to 0, Type is FalseType, and the class derives from FalseType. ">IsMultExpr</a> type trait recognizes the class as valid multiplication expression template.  <a href="../../df/dfd/structblaze_1_1MultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/db7/structblaze_1_1Row.html">blaze::Row</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all rows.The <a class="el" href="../../d3/db7/structblaze_1_1Row.html" title="Base class for all rows.The Row class serves as a tag for all rows (i.e. dense and sparse rows)...">Row</a> class serves as a tag for all rows (i.e. dense and sparse rows). All classes that represent a row and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a row. Only in case a class is derived from the <a class="el" href="../../d3/db7/structblaze_1_1Row.html" title="Base class for all rows.The Row class serves as a tag for all rows (i.e. dense and sparse rows)...">Row</a> base class, the <a class="el" href="../../d0/da2/structblaze_1_1IsRow.html" title="Compile time check for rows.This type trait tests whether or not the given template parameter is a ro...">IsRow</a> type trait recognizes the class as valid row.  <a href="../../d3/db7/structblaze_1_1Row.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7c/structblaze_1_1SerialExpr.html">blaze::SerialExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all serial evaluation expression templates.The <a class="el" href="../../d5/d7c/structblaze_1_1SerialExpr.html" title="Base class for all serial evaluation expression templates.The SerialExpr class serves as a tag for al...">SerialExpr</a> class serves as a tag for all expression templates that enforce a serial evaluation. All classes, that represent a serialization operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as serial evaluation expression template. Only in case a class is derived from the <a class="el" href="../../d5/d7c/structblaze_1_1SerialExpr.html" title="Base class for all serial evaluation expression templates.The SerialExpr class serves as a tag for al...">SerialExpr</a> base class, the <a class="el" href="../../d8/d47/structblaze_1_1IsSerialExpr.html" title="Compile time check whether the given type is a serial evaluation expression template.This type trait class tests whether or not the given type Type is a serial evaluation expression template. In order to qualify as a valid serial evaluation expression template, the given type has to derive (publicly or privately) from the SerialExpr base class. In case the given type is a valid serial evaluation expression template, the value member enumeration is set to 1, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to 0, Type is FalseType, and the class derives from FalseType. ">IsSerialExpr</a> type trait recognizes the class as valid serial evaluation expression template.  <a href="../../d5/d7c/structblaze_1_1SerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d7a/structblaze_1_1SubExpr.html">blaze::SubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all subtraction expression templates.The <a class="el" href="../../d0/d7a/structblaze_1_1SubExpr.html" title="Base class for all subtraction expression templates.The SubExpr class serves as a tag for all express...">SubExpr</a> class serves as a tag for all expression templates that implement mathematical subtractions. All classes, that represent a mathematical subtraction (vector subtractions and matrix subtractions) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as subtraction expression template. Only in case a class is derived from the <a class="el" href="../../d0/d7a/structblaze_1_1SubExpr.html" title="Base class for all subtraction expression templates.The SubExpr class serves as a tag for all express...">SubExpr</a> base class, the <a class="el" href="../../da/d3f/structblaze_1_1IsSubExpr.html" title="Compile time check whether the given type is a subtraction expression template.This type trait class ...">IsSubExpr</a> type trait recognizes the class as valid subtraction expression template.  <a href="../../d0/d7a/structblaze_1_1SubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d6e/structblaze_1_1Submatrix.html">blaze::Submatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all submatrices.The <a class="el" href="../../d2/d6e/structblaze_1_1Submatrix.html" title="Base class for all submatrices.The Submatrix class serves as a tag for all submatrices (i...">Submatrix</a> class serves as a tag for all submatrices (i.e. dense and sparse submatrices). All classes that represent a submatrix and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a submatrix. Only in case a class is derived from the <a class="el" href="../../d2/d6e/structblaze_1_1Submatrix.html" title="Base class for all submatrices.The Submatrix class serves as a tag for all submatrices (i...">Submatrix</a> base class, the <a class="el" href="../../dd/d1c/structblaze_1_1IsSubmatrix.html" title="Compile time check for submatrices.This type trait tests whether or not the given template parameter ...">IsSubmatrix</a> type trait recognizes the class as valid submatrix.  <a href="../../d2/d6e/structblaze_1_1Submatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d66/structblaze_1_1Subvector.html">blaze::Subvector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all subvectors.The <a class="el" href="../../d6/d66/structblaze_1_1Subvector.html" title="Base class for all subvectors.The Subvector class serves as a tag for all subvectors (i...">Subvector</a> class serves as a tag for all subvectors (i.e. dense and sparse subvectors). All classes that represent a subvector and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a subvector. Only in case a class is derived from the <a class="el" href="../../d6/d66/structblaze_1_1Subvector.html" title="Base class for all subvectors.The Subvector class serves as a tag for all subvectors (i...">Subvector</a> base class, the <a class="el" href="../../db/d9a/structblaze_1_1IsSubvector.html" title="Compile time check for subvectors.This type trait tests whether or not the given template parameter i...">IsSubvector</a> type trait recognizes the class as valid subvector.  <a href="../../d6/d66/structblaze_1_1Subvector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dfe/structblaze_1_1TransExpr.html">blaze::TransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all transposition expression templates.The <a class="el" href="../../dd/dfe/structblaze_1_1TransExpr.html" title="Base class for all transposition expression templates.The TransExpr class serves as a tag for all exp...">TransExpr</a> class serves as a tag for all expression templates that implement mathematical transpositions. All classes, that represent a mathematical transposition (vector transpositions and matrix transpositions) and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as transposition expression template. Only in case a class is derived from the <a class="el" href="../../dd/dfe/structblaze_1_1TransExpr.html" title="Base class for all transposition expression templates.The TransExpr class serves as a tag for all exp...">TransExpr</a> base class, the <a class="el" href="../../df/d04/structblaze_1_1IsTransExpr.html" title="Compile time check whether the given type is a transposition expression template.This type trait clas...">IsTransExpr</a> type trait recognizes the class as valid transposition expression template.  <a href="../../dd/dfe/structblaze_1_1TransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d25/structblaze_1_1TVecMatMultExpr.html">blaze::TVecMatMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/matrix multiplication expression templates.The <a class="el" href="../../d3/d25/structblaze_1_1TVecMatMultExpr.html" title="Base class for all vector/matrix multiplication expression templates.The TVecMatMultExpr class serves...">TVecMatMultExpr</a> class serves as a tag for all expression templates that implement a vector/matrix multiplication. All classes, that represent a vector/matrix multiplication and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector/matrix multiplication expression template. Only in case a class is derived from the <a class="el" href="../../d3/d25/structblaze_1_1TVecMatMultExpr.html" title="Base class for all vector/matrix multiplication expression templates.The TVecMatMultExpr class serves...">TVecMatMultExpr</a> base class, the <a class="el" href="../../d8/d08/structblaze_1_1IsTVecMatMultExpr.html" title="Compile time check whether the given type is a vector/matrix multiplication expression template...">IsTVecMatMultExpr</a> type trait recognizes the class as valid vector/matrix multiplication expression template.  <a href="../../d3/d25/structblaze_1_1TVecMatMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d23/structblaze_1_1VecAbsExpr.html">blaze::VecAbsExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector absolute value expression templates.The <a class="el" href="../../d7/d23/structblaze_1_1VecAbsExpr.html" title="Base class for all vector absolute value expression templates.The VecAbsExpr class serves as a tag fo...">VecAbsExpr</a> class serves as a tag for all expression templates that implement a vector absolute value operation. All classes, that represent a vector absolute value operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector absolute value expression template. Only in case a class is derived from the <a class="el" href="../../d7/d23/structblaze_1_1VecAbsExpr.html" title="Base class for all vector absolute value expression templates.The VecAbsExpr class serves as a tag fo...">VecAbsExpr</a> base class, the <a class="el" href="../../d0/d39/structblaze_1_1IsVecAbsExpr.html" title="Compile time check whether the given type is a vector absolute value expression template.This type trait class tests whether or not the given type Type is a vector absolute value expression template. In order to qualify as a valid vector absolute value expression template, the given type has to derive (publicly or privately) from the VecAbsExpr base class. In case the given type is a valid vector absolute value expression template, the value member enumeration is set to 1, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to 0, Type is FalseType, and the class derives from FalseType. ">IsVecAbsExpr</a> type trait recognizes the class as valid vector absolute value expression template.  <a href="../../d7/d23/structblaze_1_1VecAbsExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d95/structblaze_1_1VecEvalExpr.html">blaze::VecEvalExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector evaluation expression templates.The <a class="el" href="../../da/d95/structblaze_1_1VecEvalExpr.html" title="Base class for all vector evaluation expression templates.The VecEvalExpr class serves as a tag for a...">VecEvalExpr</a> class serves as a tag for all expression templates that implement a vector evaluation operation. All classes, that represent a vector evaluation operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector evaluation expression template. Only in case a class is derived from the <a class="el" href="../../da/d95/structblaze_1_1VecEvalExpr.html" title="Base class for all vector evaluation expression templates.The VecEvalExpr class serves as a tag for a...">VecEvalExpr</a> base class, the <a class="el" href="../../d6/d05/structblaze_1_1IsVecEvalExpr.html" title="Compile time check whether the given type is a vector evaluation expression template.This type trait class tests whether or not the given type Type is a vector evaluation expression template. In order to qualify as a valid vector evaluation expression template, the given type has to derive (publicly or privately) from the VecEvalExpr base class. In case the given type is a valid vector evaluation expression template, the value member enumeration is set to 1, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to 0, Type is FalseType, and the class derives from FalseType. ">IsVecEvalExpr</a> type trait recognizes the class as valid vector evaluation expression template.  <a href="../../da/d95/structblaze_1_1VecEvalExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbf/structblaze_1_1VecScalarDivExpr.html">blaze::VecScalarDivExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/scalar division expression templates.The <a class="el" href="../../da/dbf/structblaze_1_1VecScalarDivExpr.html" title="Base class for all vector/scalar division expression templates.The VecScalarDivExpr class serves as a...">VecScalarDivExpr</a> class serves as a tag for all expression templates that implement a vector/scalar division. All classes, that represent a vector/scalar division and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector/scalar division expression template. Only in case a class is derived from the <a class="el" href="../../da/dbf/structblaze_1_1VecScalarDivExpr.html" title="Base class for all vector/scalar division expression templates.The VecScalarDivExpr class serves as a...">VecScalarDivExpr</a> base class, the <a class="el" href="../../d7/da6/structblaze_1_1IsVecScalarDivExpr.html" title="Compile time check whether the given type is a vector/scalar division expression template.This type trait class tests whether or not the given type Type is a vector/scalar division expression template. In order to qualify as a valid vector/scalar division expression template, the given type has to derive (publicly or privately) from the VecScalarDivExpr base class. In case the given type is a valid vector/scalar division expression template, the value member enumeration is set to 1, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to 0, Type is FalseType, and the class derives from FalseType. ">IsVecScalarDivExpr</a> type trait recognizes the class as valid vector/scalar division expression template.  <a href="../../da/dbf/structblaze_1_1VecScalarDivExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d01/structblaze_1_1VecScalarMultExpr.html">blaze::VecScalarMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/scalar multiplication expression templates.The <a class="el" href="../../df/d01/structblaze_1_1VecScalarMultExpr.html" title="Base class for all vector/scalar multiplication expression templates.The VecScalarMultExpr class serv...">VecScalarMultExpr</a> class serves as a tag for all expression templates that implement a vector/scalar multiplication. All classes, that represent a vector/scalar multiplication and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector/scalar multiplication expression template. Only in case a class is derived from the <a class="el" href="../../df/d01/structblaze_1_1VecScalarMultExpr.html" title="Base class for all vector/scalar multiplication expression templates.The VecScalarMultExpr class serv...">VecScalarMultExpr</a> base class, the <a class="el" href="../../d7/da8/structblaze_1_1IsVecScalarMultExpr.html" title="Compile time check whether the given type is a vector/scalar multiplication expression template...">IsVecScalarMultExpr</a> type trait recognizes the class as valid vector/scalar multiplication expression template.  <a href="../../df/d01/structblaze_1_1VecScalarMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dfb/structblaze_1_1VecSerialExpr.html">blaze::VecSerialExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector serial evaluation expression templates.The <a class="el" href="../../d8/dfb/structblaze_1_1VecSerialExpr.html" title="Base class for all vector serial evaluation expression templates.The VecSerialExpr class serves as a ...">VecSerialExpr</a> class serves as a tag for all expression templates that enforce a serial evaluation of a vector. All classes, that represent a vector serialization operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector serial evaluation expression template. Only in case a class is derived from the <a class="el" href="../../d8/dfb/structblaze_1_1VecSerialExpr.html" title="Base class for all vector serial evaluation expression templates.The VecSerialExpr class serves as a ...">VecSerialExpr</a> base class, the <a class="el" href="../../d2/d59/structblaze_1_1IsVecSerialExpr.html" title="Compile time check whether the given type is a vector serial evaluation expression template...">IsVecSerialExpr</a> type trait recognizes the class as valid vector serial evaluation expression template.  <a href="../../d8/dfb/structblaze_1_1VecSerialExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dec/structblaze_1_1VecTransExpr.html">blaze::VecTransExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector transposition expression templates.The <a class="el" href="../../d0/dec/structblaze_1_1VecTransExpr.html" title="Base class for all vector transposition expression templates.The VecTransExpr class serves as a tag f...">VecTransExpr</a> class serves as a tag for all expression templates that implement a vector transposition operation. All classes, that represent a vector transposition operation and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector transposition expression template. Only in case a class is derived from the <a class="el" href="../../d0/dec/structblaze_1_1VecTransExpr.html" title="Base class for all vector transposition expression templates.The VecTransExpr class serves as a tag f...">VecTransExpr</a> base class, the <a class="el" href="../../d9/d3d/structblaze_1_1IsVecTransExpr.html" title="Compile time check whether the given type is a vector transposition expression template.This type trait class tests whether or not the given type Type is a vector transposition expression template. In order to qualify as a valid vector transposition expression template, the given type has to derive (publicly or privately) from the VecTransExpr base class. In case the given type is a valid vector transposition expression template, the value member enumeration is set to 1, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to 0, Type is FalseType, and the class derives from FalseType. ">IsVecTransExpr</a> type trait recognizes the class as valid vector transposition expression template.  <a href="../../d0/dec/structblaze_1_1VecTransExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d08/structblaze_1_1VecTVecMultExpr.html">blaze::VecTVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all outer product expression templates.The <a class="el" href="../../de/d08/structblaze_1_1VecTVecMultExpr.html" title="Base class for all outer product expression templates.The VecTVecMultExpr class serves as a tag for a...">VecTVecMultExpr</a> class serves as a tag for all expression templates that implement mathematical outer products (i.e. multiplications between a column vector and a row vector). All classes, that represent a mathematical outer product and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as outer product expression template. Only in case a class is derived from the <a class="el" href="../../de/d08/structblaze_1_1VecTVecMultExpr.html" title="Base class for all outer product expression templates.The VecTVecMultExpr class serves as a tag for a...">VecTVecMultExpr</a> base class, the <a class="el" href="../../d7/d17/structblaze_1_1IsVecTVecMultExpr.html" title="Compile time check whether the given type is an outer product expression template.This type trait class tests whether or not the given type Type is an outer product expression template (i.e. an expression representing the multiplication between a column vector and a row vector). In order to qualify as a valid outer product expression template, the given type has to derive (publicly or privately) from the VecTVecMultExpr base class. In case the given type is a valid outer product expression template, the value member enumeration is set to 1, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to 0, Type is FalseType, and the class derives from FalseType. ">IsVecTVecMultExpr</a> type trait recognizes the class as valid outer product expression template.  <a href="../../de/d08/structblaze_1_1VecTVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d58/structblaze_1_1VecVecAddExpr.html">blaze::VecVecAddExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/vector addition expression templates.The <a class="el" href="../../d0/d58/structblaze_1_1VecVecAddExpr.html" title="Base class for all vector/vector addition expression templates.The VecVecAddExpr class serves as a ta...">VecVecAddExpr</a> class serves as a tag for all expression templates that implement a vector/vector addition. All classes, that represent a vector addition and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector addition expression template. Only in case a class is derived from the <a class="el" href="../../d0/d58/structblaze_1_1VecVecAddExpr.html" title="Base class for all vector/vector addition expression templates.The VecVecAddExpr class serves as a ta...">VecVecAddExpr</a> base class, the <a class="el" href="../../d5/dae/structblaze_1_1IsVecVecAddExpr.html" title="Compile time check whether the given type is a vector/vector addition expression template.This type trait class tests whether or not the given type Type is a vector/vector addition expression template. In order to qualify as a valid vector addition expression template, the given type has to derive (publicly or privately) from the VecVecAddExpr base class. In case the given type is a valid vector addition expression template, the value member enumeration is set to 1, the nested type definition Type is TrueType, and the class derives from TrueType. Otherwise value is set to 0, Type is FalseType, and the class derives from FalseType. ">IsVecVecAddExpr</a> type trait recognizes the class as valid vector addition expression template.  <a href="../../d0/d58/structblaze_1_1VecVecAddExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d10/structblaze_1_1VecVecMultExpr.html">blaze::VecVecMultExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/vector multiplication expression templates.The <a class="el" href="../../df/d10/structblaze_1_1VecVecMultExpr.html" title="Base class for all vector/vector multiplication expression templates.The VecVecMultExpr class serves ...">VecVecMultExpr</a> class serves as a tag for all expression templates that implement a vector/vector multiplication. All classes, that represent a vector multiplication and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector multiplication expression template. Only in case a class is derived from the <a class="el" href="../../df/d10/structblaze_1_1VecVecMultExpr.html" title="Base class for all vector/vector multiplication expression templates.The VecVecMultExpr class serves ...">VecVecMultExpr</a> base class, the <a class="el" href="../../dc/d79/structblaze_1_1IsVecVecMultExpr.html" title="Compile time check whether the given type is a vector/vector multiplication expression template...">IsVecVecMultExpr</a> type trait recognizes the class as valid vector multiplication expression template.  <a href="../../df/d10/structblaze_1_1VecVecMultExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d87/structblaze_1_1VecVecSubExpr.html">blaze::VecVecSubExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all vector/vector subtraction expression templates.The <a class="el" href="../../d1/d87/structblaze_1_1VecVecSubExpr.html" title="Base class for all vector/vector subtraction expression templates.The VecVecSubExpr class serves as a...">VecVecSubExpr</a> class serves as a tag for all expression templates that implement a vector/vector subtraction. All classes, that represent a vector subtraction and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as vector subtraction expression template. Only in case a class is derived from the <a class="el" href="../../d1/d87/structblaze_1_1VecVecSubExpr.html" title="Base class for all vector/vector subtraction expression templates.The VecVecSubExpr class serves as a...">VecVecSubExpr</a> base class, the <a class="el" href="../../d9/d16/structblaze_1_1IsVecVecSubExpr.html" title="Compile time check whether the given type is a vector/vector subtraction expression template...">IsVecVecSubExpr</a> type trait recognizes the class as valid vector subtraction expression template.  <a href="../../d1/d87/structblaze_1_1VecVecSubExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dae/structblaze_1_1View.html">blaze::View</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all views.The <a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the <a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> base class, the <a class="el" href="../../da/dbb/structblaze_1_1IsView.html" title="Compile time check for views.This type trait tests whether or not the given template parameter is a v...">IsView</a> type trait recognizes the class as valid view.  <a href="../../d4/dae/structblaze_1_1View.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">blaze::NegativeInfinity&lt; I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative infinity for built-in data types.The <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class to provide the possibility to assign negative infinity values to built-in data types. As negative infinity value, the largest possible negative value of the corresponding data type is used. In order to assign the negative infinity value, the <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> class can be implicitly converted to all signed integral and floating point data types:  <a href="../../db/da3/classblaze_1_1NegativeInfinity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dff/classblaze_1_1Infinity.html">blaze::Infinity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive infinity for built-in data types.The <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> class is a wrapper class around the functionality of the <a class="el" href="../../d9/dea/structblaze_1_1Limits.html" title="Numerical limits of built-in data types.The Limits class provides numerical limits for the following ...">blaze::Limits</a> class to provide the possiblity to assign a positive infinity value to built-in data types. As positive infinity value, the largest possible positive value of the corresponding data type is used. In order to assign the positive infinity value, the <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> class can be implicitly converted to the following 13 built-in integral and floating point data types:  <a href="../../da/dff/classblaze_1_1Infinity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d8e/classblaze_1_1ComplexProxy.html">blaze::ComplexProxy&lt; PT, CT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for complex types.The <a class="el" href="../../d3/d8e/classblaze_1_1ComplexProxy.html" title="Proxy backend for complex types.The ComplexProxy class serves as a backend for the Proxy class...">ComplexProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a complex number and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of complex numbers.  <a href="../../d3/d8e/classblaze_1_1ComplexProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d30/classblaze_1_1DefaultProxy.html">blaze::DefaultProxy&lt; PT, RT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default proxy backend for built-in and alternate user-specific class types.The <a class="el" href="../../df/d30/classblaze_1_1DefaultProxy.html" title="Default proxy backend for built-in and alternate user-specific class types.The DefaultProxy class ser...">DefaultProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a built-in or alternate user-specific class type. This proxy does not augment the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by any additional interface.  <a href="../../df/d30/classblaze_1_1DefaultProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">blaze::DenseMatrixProxy&lt; PT, MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for dense matrix types.The <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html" title="Proxy backend for dense matrix types.The DenseMatrixProxy class serves as a backend for the Proxy cla...">DenseMatrixProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a dense matrix and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of dense matrices.  <a href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">blaze::DenseVectorProxy&lt; PT, VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for dense vector types.The <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html" title="Proxy backend for dense vector types.The DenseVectorProxy class serves as a backend for the Proxy cla...">DenseVectorProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a dense vector and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of dense vectors.  <a href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html">blaze::Proxy&lt; PT, RT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> base class.The <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class is a base class for all proxy classes within the <b>Blaze</b> library that may represent non-numeric data types (vectors, matrices, ...). It augments the interface of the deriving proxy class depending on the data type represented by the proxy. In addition, it provides an abstraction from the actual type of the proxy, but enables a type-safe conversion back to this type via the 'Curiously Recurring Template Pattern' (CRTP).  <a href="../../de/df9/classblaze_1_1Proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">blaze::SparseMatrixProxy&lt; PT, MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for sparse matrix types.The <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html" title="Proxy backend for sparse matrix types.The SparseMatrixProxy class serves as a backend for the Proxy c...">SparseMatrixProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a sparse matrix and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of sparse matrices.  <a href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">blaze::SparseVectorProxy&lt; PT, VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> backend for sparse vector types.The <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html" title="Proxy backend for sparse vector types.The SparseVectorProxy class serves as a backend for the Proxy c...">SparseVectorProxy</a> class serves as a backend for the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> class. It is used in case the data type represented by the proxy is a sparse vector and augments the <a class="el" href="../../de/df9/classblaze_1_1Proxy.html" title="Proxy base class.The Proxy class is a base class for all proxy classes within the Blaze library that ...">Proxy</a> interface by the complete interface required of sparse vectors.  <a href="../../dc/df4/classblaze_1_1SparseVectorProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">blaze::MatrixAccessProxy&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for sparse, <img class="formulaInl" alt="$ M \times N $" src="../../form_48.png"/> matrices.The <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> provides safe access to the elements of a non-const sparse matrices.<br />
The proxied access to the elements of a sparse matrix is necessary since it may be possible that several insertion operations happen in the same statement. The following code illustrates this with two examples by means of the <a class="el" href="../../da/d7a/classblaze_1_1CompressedMatrix.html" title="Efficient implementation of a  compressed matrix.The CompressedMatrix class template is the represent...">CompressedMatrix</a> class:  <a href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/db5/structblaze_1_1SparseElement.html">blaze::SparseElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all sparse element types.The <a class="el" href="../../db/db5/structblaze_1_1SparseElement.html" title="Base class for all sparse element types.The SparseElement class is the base class for all sparse elem...">SparseElement</a> class is the base class for all sparse element types. All types that conceptually represent a sparse vector or matrix element and that provide a <code>value()</code> and an <code>index()</code> member function have to derive from this class in order to qualify as sparse element. Only in case a class is derived from the <a class="el" href="../../db/db5/structblaze_1_1SparseElement.html" title="Base class for all sparse element types.The SparseElement class is the base class for all sparse elem...">SparseElement</a> base class, the <a class="el" href="../../d5/d39/structblaze_1_1IsSparseElement.html" title="Compile time check whether the given type is a sparse element type.This type trait class tests whethe...">IsSparseElement</a> type trait recognizes the class as valid sparse element.  <a href="../../db/db5/structblaze_1_1SparseElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc7/classblaze_1_1ValueIndexPair.html">blaze::ValueIndexPair&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-value-pair for sparse vectors and matrices.The <a class="el" href="../../db/dc7/classblaze_1_1ValueIndexPair.html" title="Index-value-pair for sparse vectors and matrices.The ValueIndexPair class represents a single index-v...">ValueIndexPair</a> class represents a single index-value-pair of a sparse vector or sparse matrix.  <a href="../../db/dc7/classblaze_1_1ValueIndexPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">blaze::VectorAccessProxy&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for sparse, N-dimensional vectors.The <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> provides safe access to the elements of a non-const sparse vector.<br />
The proxied access to the elements of a sparse vector is necessary since it may be possible that several insertion operations happen in the same statement. The following code illustrates this with two examples by means of the <a class="el" href="../../d5/d35/classblaze_1_1CompressedVector.html" title="Efficient implementation of an arbitrary sized sparse vector.The CompressedVector class is the repres...">CompressedVector</a> class:  <a href="../../df/de3/classblaze_1_1VectorAccessProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d18/structblaze_1_1AddTrait.html">blaze::AddTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../db/d18/structblaze_1_1AddTrait.html" title="Base template for the AddTrait class. ">AddTrait</a> class.  <a href="../../db/d18/structblaze_1_1AddTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d19/structblaze_1_1CMathTrait.html">blaze::CMathTrait&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../de/d19/structblaze_1_1CMathTrait.html" title="Base template for the CMathTrait class.The CMathTrait template evaluates the return type of the mathe...">CMathTrait</a> class.The <a class="el" href="../../de/d19/structblaze_1_1CMathTrait.html" title="Base template for the CMathTrait class.The CMathTrait template evaluates the return type of the mathe...">CMathTrait</a> template evaluates the return type of the mathematical functions defined in the C++ header &lt;cmath&gt; depending on the type of the template argument. In case of an integral data type or double precision argument, the return value of the functions is double, whereas the return type is float for single precision arguments and long double for long double precision arguments.  <a href="../../de/d19/structblaze_1_1CMathTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html">blaze::ColumnTrait&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d5/d7f/structblaze_1_1ColumnTrait.html" title="Base template for the ColumnTrait class. ">ColumnTrait</a> class.  <a href="../../d5/d7f/structblaze_1_1ColumnTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html">blaze::CrossTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d4/d9c/structblaze_1_1CrossTrait.html" title="Base template for the CrossTrait class. ">CrossTrait</a> class.  <a href="../../d4/d9c/structblaze_1_1CrossTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html">blaze::DivTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d2/d67/structblaze_1_1DivTrait.html" title="Base template for the DivTrait class. ">DivTrait</a> class.  <a href="../../d2/d67/structblaze_1_1DivTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html">blaze::MathTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html" title="Base template for the MathTrait class. ">MathTrait</a> class.  <a href="../../d3/d6a/structblaze_1_1MathTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/daf/structblaze_1_1MultTrait.html">blaze::MultTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../df/daf/structblaze_1_1MultTrait.html" title="Base template for the MultTrait class. ">MultTrait</a> class.  <a href="../../df/daf/structblaze_1_1MultTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html">blaze::RowTrait&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../df/d8f/structblaze_1_1RowTrait.html" title="Base template for the RowTrait class. ">RowTrait</a> class.  <a href="../../df/d8f/structblaze_1_1RowTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html">blaze::SubmatrixTrait&lt; MT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../de/d83/structblaze_1_1SubmatrixTrait.html" title="Base template for the SubmatrixTrait class. ">SubmatrixTrait</a> class.  <a href="../../de/d83/structblaze_1_1SubmatrixTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html">blaze::SubTrait&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../dd/d27/structblaze_1_1SubTrait.html" title="Base template for the SubTrait class. ">SubTrait</a> class.  <a href="../../dd/d27/structblaze_1_1SubTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html">blaze::SubvectorTrait&lt; VT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for the <a class="el" href="../../df/d1b/structblaze_1_1SubvectorTrait.html" title="Base template for the SubvectorTrait class. ">SubvectorTrait</a> class.  <a href="../../df/d1b/structblaze_1_1SubvectorTrait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga26e95f4a9302b9f1fc76200bfa4cd4cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga26e95f4a9302b9f1fc76200bfa4cd4cb"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>rmm</b> = IsRowMajorMatrix&lt;MT&gt;::value
 }</td></tr>
<tr class="memdesc:ga26e95f4a9302b9f1fc76200bfa4cd4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time flag indicating whether the given matrix type is a row-major matrix. <br /></td></tr>
<tr class="separator:ga26e95f4a9302b9f1fc76200bfa4cd4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga625b0b7ac3b908bc3266c6d834630806"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga625b0b7ac3b908bc3266c6d834630806"></a>
const Accuracy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga625b0b7ac3b908bc3266c6d834630806">blaze::accuracy</a></td></tr>
<tr class="memdesc:ga625b0b7ac3b908bc3266c6d834630806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> instance.The <a class="el" href="../../de/df1/group__math.html#ga625b0b7ac3b908bc3266c6d834630806" title="Global Accuracy instance.The blaze::accuracy instance can be used wherever a floating point data type...">blaze::accuracy</a> instance can be used wherever a floating point data type is expected. It is implicitly converted to the corresponding floating point data type and represents the computation accuracy of the Blaze library for the according data type. <br /></td></tr>
<tr class="separator:ga625b0b7ac3b908bc3266c6d834630806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec2f6a797255a44b04f704ff548385d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaec2f6a797255a44b04f704ff548385d4"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaec2f6a797255a44b04f704ff548385d4">blaze::M_E</a> = 2.7182818284590452353602874713526625</td></tr>
<tr class="memdesc:gaec2f6a797255a44b04f704ff548385d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ e $" src="../../form_34.png"/>. <br /></td></tr>
<tr class="separator:gaec2f6a797255a44b04f704ff548385d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf858edb18cdfb5695345c47879be3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6bf858edb18cdfb5695345c47879be3f"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6bf858edb18cdfb5695345c47879be3f">blaze::M_LOG2E</a> = 1.4426950408889634073599246810018921</td></tr>
<tr class="memdesc:ga6bf858edb18cdfb5695345c47879be3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \log_2 e $" src="../../form_35.png"/>. <br /></td></tr>
<tr class="separator:ga6bf858edb18cdfb5695345c47879be3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ee7da2d612ffe0d0837a63ed9f4bff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf0ee7da2d612ffe0d0837a63ed9f4bff"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf0ee7da2d612ffe0d0837a63ed9f4bff">blaze::M_LOG10E</a> = 0.4342944819032518276511289189166051</td></tr>
<tr class="memdesc:gaf0ee7da2d612ffe0d0837a63ed9f4bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \log_{10} e $" src="../../form_36.png"/>. <br /></td></tr>
<tr class="separator:gaf0ee7da2d612ffe0d0837a63ed9f4bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1502d2dcd380b1eb5e56ffd898ceb5ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1502d2dcd380b1eb5e56ffd898ceb5ca"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1502d2dcd380b1eb5e56ffd898ceb5ca">blaze::M_LN2</a> = 0.6931471805599453094172321214581766</td></tr>
<tr class="memdesc:ga1502d2dcd380b1eb5e56ffd898ceb5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \ln 2 $" src="../../form_37.png"/>. <br /></td></tr>
<tr class="separator:ga1502d2dcd380b1eb5e56ffd898ceb5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b89d4af29804852eb0830a1481e9801"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9b89d4af29804852eb0830a1481e9801"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9b89d4af29804852eb0830a1481e9801">blaze::M_LN10</a> = 2.3025850929940456840179914546843642</td></tr>
<tr class="memdesc:ga9b89d4af29804852eb0830a1481e9801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \ln 10 $" src="../../form_38.png"/>. <br /></td></tr>
<tr class="separator:ga9b89d4af29804852eb0830a1481e9801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2600098236fe85a4d5e79e4d9de26318"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2600098236fe85a4d5e79e4d9de26318"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2600098236fe85a4d5e79e4d9de26318">blaze::M_PI</a> = 3.1415926535897932384626433832795029</td></tr>
<tr class="memdesc:ga2600098236fe85a4d5e79e4d9de26318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \pi $" src="../../form_39.png"/>. <br /></td></tr>
<tr class="separator:ga2600098236fe85a4d5e79e4d9de26318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad56db875675fe79ee8b7685673eb5c02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad56db875675fe79ee8b7685673eb5c02"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad56db875675fe79ee8b7685673eb5c02">blaze::M_SQRT2</a> = 1.4142135623730950488016887242096981</td></tr>
<tr class="memdesc:gad56db875675fe79ee8b7685673eb5c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \sqrt{2} $" src="../../form_40.png"/>. <br /></td></tr>
<tr class="separator:gad56db875675fe79ee8b7685673eb5c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b83fd428d08d322190fb8d09fb72eaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b83fd428d08d322190fb8d09fb72eaf"></a>
const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6b83fd428d08d322190fb8d09fb72eaf">blaze::M_SQRT3</a> = 1.7320508075688772935274463415058724</td></tr>
<tr class="memdesc:ga6b83fd428d08d322190fb8d09fb72eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the mathematical constant <img class="formulaInl" alt="$ \sqrt{3} $" src="../../form_41.png"/>. <br /></td></tr>
<tr class="separator:ga6b83fd428d08d322190fb8d09fb72eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a02d7d60cd864ce158adb1cdf17989c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a02d7d60cd864ce158adb1cdf17989c"></a>
const Epsilon&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9a02d7d60cd864ce158adb1cdf17989c">blaze::epsilon</a></td></tr>
<tr class="memdesc:ga9a02d7d60cd864ce158adb1cdf17989c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> instance.The <a class="el" href="../../de/df1/group__math.html#ga9a02d7d60cd864ce158adb1cdf17989c" title="Global Epsilon instance.The blaze::epsilon instance can be used wherever a floating point data type i...">blaze::epsilon</a> instance can be used wherever a floating point data type is expected. It is implicitly converted to the corresponding floating point data type and represents the smallest possible difference between two values of the according data type. <br /></td></tr>
<tr class="separator:ga9a02d7d60cd864ce158adb1cdf17989c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97926ed3b4199bea5635290031cfe38f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97926ed3b4199bea5635290031cfe38f"></a>
const Infinity&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga97926ed3b4199bea5635290031cfe38f">blaze::inf</a></td></tr>
<tr class="memdesc:ga97926ed3b4199bea5635290031cfe38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> instance.The <a class="el" href="../../de/df1/group__math.html#ga97926ed3b4199bea5635290031cfe38f" title="Global Infinity instance.The blaze::inf instance can be used wherever a built-in data type is expecte...">blaze::inf</a> instance can be used wherever a built-in data type is expected. It is implicitly converted to the corresponding built-in data type and represents its largest possible data value. <br /></td></tr>
<tr class="separator:ga97926ed3b4199bea5635290031cfe38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Accuracy operators</h2></td></tr>
<tr class="memitem:ga2eebfaf6382f255164a9cefa6ab8eb27"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga2eebfaf6382f255164a9cefa6ab8eb27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2eebfaf6382f255164a9cefa6ab8eb27">blaze::operator==</a> (const NegativeAccuracy&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga2eebfaf6382f255164a9cefa6ab8eb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="#ga2eebfaf6382f255164a9cefa6ab8eb27">More...</a><br /></td></tr>
<tr class="separator:ga2eebfaf6382f255164a9cefa6ab8eb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cf42a6c23efe1880899f5b89b265286"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga3cf42a6c23efe1880899f5b89b265286"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3cf42a6c23efe1880899f5b89b265286">blaze::operator==</a> (const T &amp;lhs, const NegativeAccuracy&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga3cf42a6c23efe1880899f5b89b265286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="#ga3cf42a6c23efe1880899f5b89b265286">More...</a><br /></td></tr>
<tr class="separator:ga3cf42a6c23efe1880899f5b89b265286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f6ac5831d994de1617100e79b409f78"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga5f6ac5831d994de1617100e79b409f78"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5f6ac5831d994de1617100e79b409f78">blaze::operator!=</a> (const NegativeAccuracy&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga5f6ac5831d994de1617100e79b409f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="#ga5f6ac5831d994de1617100e79b409f78">More...</a><br /></td></tr>
<tr class="separator:ga5f6ac5831d994de1617100e79b409f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22db42744b1d782e174dbcf6f2bf37e2"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga22db42744b1d782e174dbcf6f2bf37e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga22db42744b1d782e174dbcf6f2bf37e2">blaze::operator!=</a> (const T &amp;lhs, const NegativeAccuracy&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga22db42744b1d782e174dbcf6f2bf37e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="#ga22db42744b1d782e174dbcf6f2bf37e2">More...</a><br /></td></tr>
<tr class="separator:ga22db42744b1d782e174dbcf6f2bf37e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42be9e710c330d928604c4fe730661d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga42be9e710c330d928604c4fe730661d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga42be9e710c330d928604c4fe730661d5">blaze::operator==</a> (const Accuracy &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga42be9e710c330d928604c4fe730661d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="#ga42be9e710c330d928604c4fe730661d5">More...</a><br /></td></tr>
<tr class="separator:ga42be9e710c330d928604c4fe730661d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5362cd08bf302cd8f8272be634a5b435"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5362cd08bf302cd8f8272be634a5b435"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5362cd08bf302cd8f8272be634a5b435">blaze::operator==</a> (const T &amp;lhs, const Accuracy &amp;)</td></tr>
<tr class="memdesc:ga5362cd08bf302cd8f8272be634a5b435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="#ga5362cd08bf302cd8f8272be634a5b435">More...</a><br /></td></tr>
<tr class="separator:ga5362cd08bf302cd8f8272be634a5b435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81389b775ddd91717cc708fd4815b6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac81389b775ddd91717cc708fd4815b6a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac81389b775ddd91717cc708fd4815b6a">blaze::operator!=</a> (const Accuracy &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gac81389b775ddd91717cc708fd4815b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="#gac81389b775ddd91717cc708fd4815b6a">More...</a><br /></td></tr>
<tr class="separator:gac81389b775ddd91717cc708fd4815b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae116a92a519bc1a7faa511e50ebd3b90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae116a92a519bc1a7faa511e50ebd3b90"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae116a92a519bc1a7faa511e50ebd3b90">blaze::operator!=</a> (const T &amp;lhs, const Accuracy &amp;)</td></tr>
<tr class="memdesc:gae116a92a519bc1a7faa511e50ebd3b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="#gae116a92a519bc1a7faa511e50ebd3b90">More...</a><br /></td></tr>
<tr class="separator:gae116a92a519bc1a7faa511e50ebd3b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f6e6c059c34b31b67dfe6e6420398d"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:gab0f6e6c059c34b31b67dfe6e6420398d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab0f6e6c059c34b31b67dfe6e6420398d">blaze::operator&lt;</a> (const NegativeAccuracy&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gab0f6e6c059c34b31b67dfe6e6420398d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="#gab0f6e6c059c34b31b67dfe6e6420398d">More...</a><br /></td></tr>
<tr class="separator:gab0f6e6c059c34b31b67dfe6e6420398d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f80a558803f060623e0ac21763e989a"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga9f80a558803f060623e0ac21763e989a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9f80a558803f060623e0ac21763e989a">blaze::operator&lt;</a> (const T &amp;lhs, const NegativeAccuracy&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:ga9f80a558803f060623e0ac21763e989a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="#ga9f80a558803f060623e0ac21763e989a">More...</a><br /></td></tr>
<tr class="separator:ga9f80a558803f060623e0ac21763e989a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c3a3aa80c4823700946bfbcbf0e15a7"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:ga0c3a3aa80c4823700946bfbcbf0e15a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0c3a3aa80c4823700946bfbcbf0e15a7">blaze::operator&gt;</a> (const NegativeAccuracy&lt; A &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga0c3a3aa80c4823700946bfbcbf0e15a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value.  <a href="#ga0c3a3aa80c4823700946bfbcbf0e15a7">More...</a><br /></td></tr>
<tr class="separator:ga0c3a3aa80c4823700946bfbcbf0e15a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1147bca7c8d61c5705dd67a7bb37b72"><td class="memTemplParams" colspan="2">template&lt;typename A , typename T &gt; </td></tr>
<tr class="memitem:gad1147bca7c8d61c5705dd67a7bb37b72"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad1147bca7c8d61c5705dd67a7bb37b72">blaze::operator&gt;</a> (const T &amp;lhs, const NegativeAccuracy&lt; A &gt; &amp;)</td></tr>
<tr class="memdesc:gad1147bca7c8d61c5705dd67a7bb37b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object.  <a href="#gad1147bca7c8d61c5705dd67a7bb37b72">More...</a><br /></td></tr>
<tr class="separator:gad1147bca7c8d61c5705dd67a7bb37b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecb0cc5d9dcf5ed3c3a244b072b838ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaecb0cc5d9dcf5ed3c3a244b072b838ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaecb0cc5d9dcf5ed3c3a244b072b838ba">blaze::operator&lt;</a> (const Accuracy &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaecb0cc5d9dcf5ed3c3a244b072b838ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="#gaecb0cc5d9dcf5ed3c3a244b072b838ba">More...</a><br /></td></tr>
<tr class="separator:gaecb0cc5d9dcf5ed3c3a244b072b838ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbb1c3cbb179e0e86ef79b4ffa11dc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafdbb1c3cbb179e0e86ef79b4ffa11dc4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gafdbb1c3cbb179e0e86ef79b4ffa11dc4">blaze::operator&lt;</a> (const T &amp;lhs, const Accuracy &amp;)</td></tr>
<tr class="memdesc:gafdbb1c3cbb179e0e86ef79b4ffa11dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="#gafdbb1c3cbb179e0e86ef79b4ffa11dc4">More...</a><br /></td></tr>
<tr class="separator:gafdbb1c3cbb179e0e86ef79b4ffa11dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f7eea431aca4b1b3741d765cfe300e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga84f7eea431aca4b1b3741d765cfe300e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga84f7eea431aca4b1b3741d765cfe300e">blaze::operator&gt;</a> (const Accuracy &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga84f7eea431aca4b1b3741d765cfe300e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="#ga84f7eea431aca4b1b3741d765cfe300e">More...</a><br /></td></tr>
<tr class="separator:ga84f7eea431aca4b1b3741d765cfe300e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab2ec2c16b016e3ba86a076cee12001d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaab2ec2c16b016e3ba86a076cee12001d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaab2ec2c16b016e3ba86a076cee12001d">blaze::operator&gt;</a> (const T &amp;lhs, const Accuracy &amp;)</td></tr>
<tr class="memdesc:gaab2ec2c16b016e3ba86a076cee12001d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="#gaab2ec2c16b016e3ba86a076cee12001d">More...</a><br /></td></tr>
<tr class="separator:gaab2ec2c16b016e3ba86a076cee12001d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17abc6a6b11aecfc787e01c600e0546b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga17abc6a6b11aecfc787e01c600e0546b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga17abc6a6b11aecfc787e01c600e0546b">blaze::operator&lt;=</a> (const Accuracy &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga17abc6a6b11aecfc787e01c600e0546b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="#ga17abc6a6b11aecfc787e01c600e0546b">More...</a><br /></td></tr>
<tr class="separator:ga17abc6a6b11aecfc787e01c600e0546b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fa9b68879cea6b50867c5018151bee4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7fa9b68879cea6b50867c5018151bee4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7fa9b68879cea6b50867c5018151bee4">blaze::operator&lt;=</a> (const T &amp;lhs, const Accuracy &amp;)</td></tr>
<tr class="memdesc:ga7fa9b68879cea6b50867c5018151bee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="#ga7fa9b68879cea6b50867c5018151bee4">More...</a><br /></td></tr>
<tr class="separator:ga7fa9b68879cea6b50867c5018151bee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa46c931e3c38d084981c9ebe8611a3b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa46c931e3c38d084981c9ebe8611a3b6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa46c931e3c38d084981c9ebe8611a3b6">blaze::operator&gt;=</a> (const Accuracy &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaa46c931e3c38d084981c9ebe8611a3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value.  <a href="#gaa46c931e3c38d084981c9ebe8611a3b6">More...</a><br /></td></tr>
<tr class="separator:gaa46c931e3c38d084981c9ebe8611a3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd532f78625cbf286b84fa5d4d8b32ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadd532f78625cbf286b84fa5d4d8b32ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gadd532f78625cbf286b84fa5d4d8b32ce">blaze::operator&gt;=</a> (const T &amp;lhs, const Accuracy &amp;)</td></tr>
<tr class="memdesc:gadd532f78625cbf286b84fa5d4d8b32ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object.  <a href="#gadd532f78625cbf286b84fa5d4d8b32ce">More...</a><br /></td></tr>
<tr class="separator:gadd532f78625cbf286b84fa5d4d8b32ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
NonNumericProxy operators</h2></td></tr>
<tr class="memitem:gab3d5153c4fa9db305f78439a7893ed60"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gab3d5153c4fa9db305f78439a7893ed60"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab3d5153c4fa9db305f78439a7893ed60">blaze::operator==</a> (const NonNumericProxy&lt; MT1 &gt; &amp;lhs, const NonNumericProxy&lt; MT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab3d5153c4fa9db305f78439a7893ed60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> objects.  <a href="#gab3d5153c4fa9db305f78439a7893ed60">More...</a><br /></td></tr>
<tr class="separator:gab3d5153c4fa9db305f78439a7893ed60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga667fb1bc5b1eda64ec69ee1bb64b967a"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:ga667fb1bc5b1eda64ec69ee1bb64b967a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga667fb1bc5b1eda64ec69ee1bb64b967a">blaze::operator==</a> (const NonNumericProxy&lt; MT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga667fb1bc5b1eda64ec69ee1bb64b967a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object and an object of different type.  <a href="#ga667fb1bc5b1eda64ec69ee1bb64b967a">More...</a><br /></td></tr>
<tr class="separator:ga667fb1bc5b1eda64ec69ee1bb64b967a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b1056eb3e7b206a178b0ac0a03c794"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:ga93b1056eb3e7b206a178b0ac0a03c794"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga93b1056eb3e7b206a178b0ac0a03c794">blaze::operator==</a> (const T &amp;lhs, const NonNumericProxy&lt; MT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga93b1056eb3e7b206a178b0ac0a03c794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an object of different type and a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object.  <a href="#ga93b1056eb3e7b206a178b0ac0a03c794">More...</a><br /></td></tr>
<tr class="separator:ga93b1056eb3e7b206a178b0ac0a03c794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad67a505ca548cbc1024329aebc3483f8"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gad67a505ca548cbc1024329aebc3483f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad67a505ca548cbc1024329aebc3483f8">blaze::operator!=</a> (const NonNumericProxy&lt; MT1 &gt; &amp;lhs, const NonNumericProxy&lt; MT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad67a505ca548cbc1024329aebc3483f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> objects.  <a href="#gad67a505ca548cbc1024329aebc3483f8">More...</a><br /></td></tr>
<tr class="separator:gad67a505ca548cbc1024329aebc3483f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga777d32f7eda6e19099accb98afe83dff"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:ga777d32f7eda6e19099accb98afe83dff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga777d32f7eda6e19099accb98afe83dff">blaze::operator!=</a> (const NonNumericProxy&lt; MT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga777d32f7eda6e19099accb98afe83dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object and an object of different type.  <a href="#ga777d32f7eda6e19099accb98afe83dff">More...</a><br /></td></tr>
<tr class="separator:ga777d32f7eda6e19099accb98afe83dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae51b7c17eee2f3621d89eebafb9bc56a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:gae51b7c17eee2f3621d89eebafb9bc56a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae51b7c17eee2f3621d89eebafb9bc56a">blaze::operator!=</a> (const T &amp;lhs, const NonNumericProxy&lt; MT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gae51b7c17eee2f3621d89eebafb9bc56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquality comparison between an object of different type and a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object.  <a href="#gae51b7c17eee2f3621d89eebafb9bc56a">More...</a><br /></td></tr>
<tr class="separator:gae51b7c17eee2f3621d89eebafb9bc56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf04da1771663ba18774439eedbafd55"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaaf04da1771663ba18774439eedbafd55"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaaf04da1771663ba18774439eedbafd55">blaze::operator&lt;</a> (const NonNumericProxy&lt; MT1 &gt; &amp;lhs, const NonNumericProxy&lt; MT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaaf04da1771663ba18774439eedbafd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between two <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> objects.  <a href="#gaaf04da1771663ba18774439eedbafd55">More...</a><br /></td></tr>
<tr class="separator:gaaf04da1771663ba18774439eedbafd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5196586daa116ce37f80f917476e10a5"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:ga5196586daa116ce37f80f917476e10a5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5196586daa116ce37f80f917476e10a5">blaze::operator&lt;</a> (const NonNumericProxy&lt; MT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga5196586daa116ce37f80f917476e10a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object and an object of different type.  <a href="#ga5196586daa116ce37f80f917476e10a5">More...</a><br /></td></tr>
<tr class="separator:ga5196586daa116ce37f80f917476e10a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad664938020f72ac2a69d18f0df5762d0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:gad664938020f72ac2a69d18f0df5762d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad664938020f72ac2a69d18f0df5762d0">blaze::operator&lt;</a> (const T &amp;lhs, const NonNumericProxy&lt; MT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad664938020f72ac2a69d18f0df5762d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between an object of different type and a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object.  <a href="#gad664938020f72ac2a69d18f0df5762d0">More...</a><br /></td></tr>
<tr class="separator:gad664938020f72ac2a69d18f0df5762d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7248502d6a1a34c23aaa3a2d1310347"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaa7248502d6a1a34c23aaa3a2d1310347"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa7248502d6a1a34c23aaa3a2d1310347">blaze::operator&gt;</a> (const NonNumericProxy&lt; MT1 &gt; &amp;lhs, const NonNumericProxy&lt; MT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa7248502d6a1a34c23aaa3a2d1310347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between two <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> objects.  <a href="#gaa7248502d6a1a34c23aaa3a2d1310347">More...</a><br /></td></tr>
<tr class="separator:gaa7248502d6a1a34c23aaa3a2d1310347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga407f1aeebb6cf4cc4fa5a3778df0cc89"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:ga407f1aeebb6cf4cc4fa5a3778df0cc89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga407f1aeebb6cf4cc4fa5a3778df0cc89">blaze::operator&gt;</a> (const NonNumericProxy&lt; MT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga407f1aeebb6cf4cc4fa5a3778df0cc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object and an object of different type.  <a href="#ga407f1aeebb6cf4cc4fa5a3778df0cc89">More...</a><br /></td></tr>
<tr class="separator:ga407f1aeebb6cf4cc4fa5a3778df0cc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76f73becdb5e4d03e2942967686c93b0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:ga76f73becdb5e4d03e2942967686c93b0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga76f73becdb5e4d03e2942967686c93b0">blaze::operator&gt;</a> (const T &amp;lhs, const NonNumericProxy&lt; MT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga76f73becdb5e4d03e2942967686c93b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between an object of different type and a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object.  <a href="#ga76f73becdb5e4d03e2942967686c93b0">More...</a><br /></td></tr>
<tr class="separator:ga76f73becdb5e4d03e2942967686c93b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7d2ce5289464e8b270eb72a7a0dbff9"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gae7d2ce5289464e8b270eb72a7a0dbff9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae7d2ce5289464e8b270eb72a7a0dbff9">blaze::operator&lt;=</a> (const NonNumericProxy&lt; MT1 &gt; &amp;lhs, const NonNumericProxy&lt; MT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gae7d2ce5289464e8b270eb72a7a0dbff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between two <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> objects.  <a href="#gae7d2ce5289464e8b270eb72a7a0dbff9">More...</a><br /></td></tr>
<tr class="separator:gae7d2ce5289464e8b270eb72a7a0dbff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2408003649832cde727a2f52a45e650b"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:ga2408003649832cde727a2f52a45e650b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2408003649832cde727a2f52a45e650b">blaze::operator&lt;=</a> (const NonNumericProxy&lt; MT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga2408003649832cde727a2f52a45e650b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object and an object of different type.  <a href="#ga2408003649832cde727a2f52a45e650b">More...</a><br /></td></tr>
<tr class="separator:ga2408003649832cde727a2f52a45e650b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95ca142d4a5d140a85a4c7362a0eedab"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:ga95ca142d4a5d140a85a4c7362a0eedab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga95ca142d4a5d140a85a4c7362a0eedab">blaze::operator&lt;=</a> (const T &amp;lhs, const NonNumericProxy&lt; MT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga95ca142d4a5d140a85a4c7362a0eedab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between an object of different type and a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object.  <a href="#ga95ca142d4a5d140a85a4c7362a0eedab">More...</a><br /></td></tr>
<tr class="separator:ga95ca142d4a5d140a85a4c7362a0eedab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2918d6490730a00d5ed50c924d8cb1d"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gad2918d6490730a00d5ed50c924d8cb1d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad2918d6490730a00d5ed50c924d8cb1d">blaze::operator&gt;=</a> (const NonNumericProxy&lt; MT1 &gt; &amp;lhs, const NonNumericProxy&lt; MT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad2918d6490730a00d5ed50c924d8cb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between two <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> objects.  <a href="#gad2918d6490730a00d5ed50c924d8cb1d">More...</a><br /></td></tr>
<tr class="separator:gad2918d6490730a00d5ed50c924d8cb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07bf389a3d421a598a310e8177677d11"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:ga07bf389a3d421a598a310e8177677d11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga07bf389a3d421a598a310e8177677d11">blaze::operator&gt;=</a> (const NonNumericProxy&lt; MT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga07bf389a3d421a598a310e8177677d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object and an object of different type.  <a href="#ga07bf389a3d421a598a310e8177677d11">More...</a><br /></td></tr>
<tr class="separator:ga07bf389a3d421a598a310e8177677d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f7309bd8a23e37e2203999bd65ced4f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:ga8f7309bd8a23e37e2203999bd65ced4f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga8f7309bd8a23e37e2203999bd65ced4f">blaze::operator&gt;=</a> (const T &amp;lhs, const NonNumericProxy&lt; MT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga8f7309bd8a23e37e2203999bd65ced4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between an object of different type and a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object.  <a href="#ga8f7309bd8a23e37e2203999bd65ced4f">More...</a><br /></td></tr>
<tr class="separator:ga8f7309bd8a23e37e2203999bd65ced4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b6a6d6381391ab005834b05f3e36ba"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaa4b6a6d6381391ab005834b05f3e36ba"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa4b6a6d6381391ab005834b05f3e36ba">blaze::operator&lt;&lt;</a> (std::ostream &amp;os, const NonNumericProxy&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa4b6a6d6381391ab005834b05f3e36ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for the <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> class template.  <a href="#gaa4b6a6d6381391ab005834b05f3e36ba">More...</a><br /></td></tr>
<tr class="separator:gaa4b6a6d6381391ab005834b05f3e36ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
NonNumericProxy global functions</h2></td></tr>
<tr class="memitem:gaa0d8432e93c661038aabd4e1bda0af9b"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaa0d8432e93c661038aabd4e1bda0af9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa0d8432e93c661038aabd4e1bda0af9b">blaze::reset</a> (const NonNumericProxy&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa0d8432e93c661038aabd4e1bda0af9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="#gaa0d8432e93c661038aabd4e1bda0af9b">More...</a><br /></td></tr>
<tr class="separator:gaa0d8432e93c661038aabd4e1bda0af9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8060179ae7d8ee97914ecb0fae7d9d3"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaf8060179ae7d8ee97914ecb0fae7d9d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf8060179ae7d8ee97914ecb0fae7d9d3">blaze::clear</a> (const NonNumericProxy&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaf8060179ae7d8ee97914ecb0fae7d9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="#gaf8060179ae7d8ee97914ecb0fae7d9d3">More...</a><br /></td></tr>
<tr class="separator:gaf8060179ae7d8ee97914ecb0fae7d9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad427497af2146e20165927ebd1a0109a"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gad427497af2146e20165927ebd1a0109a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad427497af2146e20165927ebd1a0109a">blaze::isDefault</a> (const NonNumericProxy&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad427497af2146e20165927ebd1a0109a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="#gad427497af2146e20165927ebd1a0109a">More...</a><br /></td></tr>
<tr class="separator:gad427497af2146e20165927ebd1a0109a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
NegativeEpsilon operators</h2></td></tr>
<tr class="memitem:ga7b8b533b8e6a1bbcc85cbd8de67a07bd"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga7b8b533b8e6a1bbcc85cbd8de67a07bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7b8b533b8e6a1bbcc85cbd8de67a07bd">blaze::operator==</a> (const NegativeEpsilon&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga7b8b533b8e6a1bbcc85cbd8de67a07bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="#ga7b8b533b8e6a1bbcc85cbd8de67a07bd">More...</a><br /></td></tr>
<tr class="separator:ga7b8b533b8e6a1bbcc85cbd8de67a07bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cfe831bb614ba1d4a67eaea42c82998"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga3cfe831bb614ba1d4a67eaea42c82998"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3cfe831bb614ba1d4a67eaea42c82998">blaze::operator==</a> (const T &amp;lhs, const NegativeEpsilon&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga3cfe831bb614ba1d4a67eaea42c82998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="#ga3cfe831bb614ba1d4a67eaea42c82998">More...</a><br /></td></tr>
<tr class="separator:ga3cfe831bb614ba1d4a67eaea42c82998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc02f01b7d880ce7e0f5413746872b3d"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:gafc02f01b7d880ce7e0f5413746872b3d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gafc02f01b7d880ce7e0f5413746872b3d">blaze::operator!=</a> (const NegativeEpsilon&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gafc02f01b7d880ce7e0f5413746872b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="#gafc02f01b7d880ce7e0f5413746872b3d">More...</a><br /></td></tr>
<tr class="separator:gafc02f01b7d880ce7e0f5413746872b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46d93714b380cec87ee26da168f4a0e5"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga46d93714b380cec87ee26da168f4a0e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga46d93714b380cec87ee26da168f4a0e5">blaze::operator!=</a> (const T &amp;lhs, const NegativeEpsilon&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga46d93714b380cec87ee26da168f4a0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="#ga46d93714b380cec87ee26da168f4a0e5">More...</a><br /></td></tr>
<tr class="separator:ga46d93714b380cec87ee26da168f4a0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1d14e4e7b3ef42af647b7d92db0f6cc"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:gac1d14e4e7b3ef42af647b7d92db0f6cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac1d14e4e7b3ef42af647b7d92db0f6cc">blaze::operator&lt;</a> (const NegativeEpsilon&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gac1d14e4e7b3ef42af647b7d92db0f6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="#gac1d14e4e7b3ef42af647b7d92db0f6cc">More...</a><br /></td></tr>
<tr class="separator:gac1d14e4e7b3ef42af647b7d92db0f6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b86a750765429e61761ff7baee2b9d5"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga9b86a750765429e61761ff7baee2b9d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9b86a750765429e61761ff7baee2b9d5">blaze::operator&lt;</a> (const T &amp;lhs, const NegativeEpsilon&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:ga9b86a750765429e61761ff7baee2b9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="#ga9b86a750765429e61761ff7baee2b9d5">More...</a><br /></td></tr>
<tr class="separator:ga9b86a750765429e61761ff7baee2b9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22864fea6db8d1ca553b327194d0b9aa"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ga22864fea6db8d1ca553b327194d0b9aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga22864fea6db8d1ca553b327194d0b9aa">blaze::operator&gt;</a> (const NegativeEpsilon&lt; E &gt; &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga22864fea6db8d1ca553b327194d0b9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value.  <a href="#ga22864fea6db8d1ca553b327194d0b9aa">More...</a><br /></td></tr>
<tr class="separator:ga22864fea6db8d1ca553b327194d0b9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd63616a647a5c54dd3fc4d8061010b"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:gaedd63616a647a5c54dd3fc4d8061010b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaedd63616a647a5c54dd3fc4d8061010b">blaze::operator&gt;</a> (const T &amp;lhs, const NegativeEpsilon&lt; E &gt; &amp;)</td></tr>
<tr class="memdesc:gaedd63616a647a5c54dd3fc4d8061010b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object.  <a href="#gaedd63616a647a5c54dd3fc4d8061010b">More...</a><br /></td></tr>
<tr class="separator:gaedd63616a647a5c54dd3fc4d8061010b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Epsilon operators</h2></td></tr>
<tr class="memitem:gac3ec406b1801fa25c3f9ffa9144cee0b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac3ec406b1801fa25c3f9ffa9144cee0b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac3ec406b1801fa25c3f9ffa9144cee0b">blaze::operator==</a> (const Epsilon &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gac3ec406b1801fa25c3f9ffa9144cee0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="#gac3ec406b1801fa25c3f9ffa9144cee0b">More...</a><br /></td></tr>
<tr class="separator:gac3ec406b1801fa25c3f9ffa9144cee0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e7b4cf5af885cb431eb37281691fe4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8e7b4cf5af885cb431eb37281691fe4d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga8e7b4cf5af885cb431eb37281691fe4d">blaze::operator==</a> (const T &amp;lhs, const Epsilon &amp;)</td></tr>
<tr class="memdesc:ga8e7b4cf5af885cb431eb37281691fe4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="#ga8e7b4cf5af885cb431eb37281691fe4d">More...</a><br /></td></tr>
<tr class="separator:ga8e7b4cf5af885cb431eb37281691fe4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a50f57ff770309ebb61142b2a425d27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7a50f57ff770309ebb61142b2a425d27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7a50f57ff770309ebb61142b2a425d27">blaze::operator!=</a> (const Epsilon &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga7a50f57ff770309ebb61142b2a425d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="#ga7a50f57ff770309ebb61142b2a425d27">More...</a><br /></td></tr>
<tr class="separator:ga7a50f57ff770309ebb61142b2a425d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga927507337b7b6cdbe244112194218275"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga927507337b7b6cdbe244112194218275"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga927507337b7b6cdbe244112194218275">blaze::operator!=</a> (const T &amp;lhs, const Epsilon &amp;)</td></tr>
<tr class="memdesc:ga927507337b7b6cdbe244112194218275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="#ga927507337b7b6cdbe244112194218275">More...</a><br /></td></tr>
<tr class="separator:ga927507337b7b6cdbe244112194218275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad73847d144e9f3c172f5630175c05e28"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad73847d144e9f3c172f5630175c05e28"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad73847d144e9f3c172f5630175c05e28">blaze::operator&lt;</a> (const Epsilon &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:gad73847d144e9f3c172f5630175c05e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="#gad73847d144e9f3c172f5630175c05e28">More...</a><br /></td></tr>
<tr class="separator:gad73847d144e9f3c172f5630175c05e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b5ff3c3bb106998735574abd5a081b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga25b5ff3c3bb106998735574abd5a081b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga25b5ff3c3bb106998735574abd5a081b">blaze::operator&lt;</a> (const T &amp;lhs, const Epsilon &amp;)</td></tr>
<tr class="memdesc:ga25b5ff3c3bb106998735574abd5a081b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="#ga25b5ff3c3bb106998735574abd5a081b">More...</a><br /></td></tr>
<tr class="separator:ga25b5ff3c3bb106998735574abd5a081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19f217c7d16c2691b15c61bd5aef9cee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga19f217c7d16c2691b15c61bd5aef9cee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga19f217c7d16c2691b15c61bd5aef9cee">blaze::operator&gt;</a> (const Epsilon &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga19f217c7d16c2691b15c61bd5aef9cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="#ga19f217c7d16c2691b15c61bd5aef9cee">More...</a><br /></td></tr>
<tr class="separator:ga19f217c7d16c2691b15c61bd5aef9cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0cbca3f85e459a6b20902cb55daad67"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf0cbca3f85e459a6b20902cb55daad67"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf0cbca3f85e459a6b20902cb55daad67">blaze::operator&gt;</a> (const T &amp;lhs, const Epsilon &amp;)</td></tr>
<tr class="memdesc:gaf0cbca3f85e459a6b20902cb55daad67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="#gaf0cbca3f85e459a6b20902cb55daad67">More...</a><br /></td></tr>
<tr class="separator:gaf0cbca3f85e459a6b20902cb55daad67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga078fff484ed6fc2a78db73d2e3f19ff1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga078fff484ed6fc2a78db73d2e3f19ff1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga078fff484ed6fc2a78db73d2e3f19ff1">blaze::operator&lt;=</a> (const Epsilon &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga078fff484ed6fc2a78db73d2e3f19ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="#ga078fff484ed6fc2a78db73d2e3f19ff1">More...</a><br /></td></tr>
<tr class="separator:ga078fff484ed6fc2a78db73d2e3f19ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00734ffb630fb7fbb9864ae0845629e2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga00734ffb630fb7fbb9864ae0845629e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga00734ffb630fb7fbb9864ae0845629e2">blaze::operator&lt;=</a> (const T &amp;lhs, const Epsilon &amp;)</td></tr>
<tr class="memdesc:ga00734ffb630fb7fbb9864ae0845629e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="#ga00734ffb630fb7fbb9864ae0845629e2">More...</a><br /></td></tr>
<tr class="separator:ga00734ffb630fb7fbb9864ae0845629e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a9ea78dadddb5de9278854251cc8f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga19a9ea78dadddb5de9278854251cc8f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga19a9ea78dadddb5de9278854251cc8f4">blaze::operator&gt;=</a> (const Epsilon &amp;, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga19a9ea78dadddb5de9278854251cc8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value.  <a href="#ga19a9ea78dadddb5de9278854251cc8f4">More...</a><br /></td></tr>
<tr class="separator:ga19a9ea78dadddb5de9278854251cc8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga858866c9c17929b12f6970c90128c932"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga858866c9c17929b12f6970c90128c932"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga858866c9c17929b12f6970c90128c932">blaze::operator&gt;=</a> (const T &amp;lhs, const Epsilon &amp;)</td></tr>
<tr class="memdesc:ga858866c9c17929b12f6970c90128c932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object.  <a href="#ga858866c9c17929b12f6970c90128c932">More...</a><br /></td></tr>
<tr class="separator:ga858866c9c17929b12f6970c90128c932"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mathematical utility functions</h2></td></tr>
<tr class="memitem:gabbfbee6a5a5043d168204dd82e1190c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabbfbee6a5a5043d168204dd82e1190c3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabbfbee6a5a5043d168204dd82e1190c3">blaze::sign</a> (T a)</td></tr>
<tr class="memdesc:gabbfbee6a5a5043d168204dd82e1190c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign function.  <a href="#gabbfbee6a5a5043d168204dd82e1190c3">More...</a><br /></td></tr>
<tr class="separator:gabbfbee6a5a5043d168204dd82e1190c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd55880375d550adbae4dd61aebea75d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabd55880375d550adbae4dd61aebea75d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabd55880375d550adbae4dd61aebea75d">blaze::digits</a> (T a)</td></tr>
<tr class="memdesc:gabd55880375d550adbae4dd61aebea75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of valid digits of an integral value.  <a href="#gabd55880375d550adbae4dd61aebea75d">More...</a><br /></td></tr>
<tr class="separator:gabd55880375d550adbae4dd61aebea75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27423d924911a9bbadee66fbbcbc9b56"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga27423d924911a9bbadee66fbbcbc9b56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const MathTrait&lt; T1, T2 &gt;::HighType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga27423d924911a9bbadee66fbbcbc9b56">blaze::min</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ga27423d924911a9bbadee66fbbcbc9b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum function for two arguments.  <a href="#ga27423d924911a9bbadee66fbbcbc9b56">More...</a><br /></td></tr>
<tr class="separator:ga27423d924911a9bbadee66fbbcbc9b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2afaa479a7f3034d0be679f2e3cef604"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:ga2afaa479a7f3034d0be679f2e3cef604"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const MathTrait&lt; typename MathTrait&lt; T1, T2 &gt;::HighType, T3 &gt;::HighType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2afaa479a7f3034d0be679f2e3cef604">blaze::min</a> (const T1 &amp;a, const T2 &amp;b, const T3 &amp;c)</td></tr>
<tr class="memdesc:ga2afaa479a7f3034d0be679f2e3cef604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum function for three arguments.  <a href="#ga2afaa479a7f3034d0be679f2e3cef604">More...</a><br /></td></tr>
<tr class="separator:ga2afaa479a7f3034d0be679f2e3cef604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5419cbf6def5f70752d58211d80586c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gac5419cbf6def5f70752d58211d80586c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const MathTrait&lt; T1, T2 &gt;::HighType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac5419cbf6def5f70752d58211d80586c">blaze::max</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:gac5419cbf6def5f70752d58211d80586c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum function for two arguments.  <a href="#gac5419cbf6def5f70752d58211d80586c">More...</a><br /></td></tr>
<tr class="separator:gac5419cbf6def5f70752d58211d80586c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff1eab92ba879fcb74710a0b5ad08f0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:gaeff1eab92ba879fcb74710a0b5ad08f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const MathTrait&lt; typename MathTrait&lt; T1, T2 &gt;::HighType, T3 &gt;::HighType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaeff1eab92ba879fcb74710a0b5ad08f0">blaze::max</a> (const T1 &amp;a, const T2 &amp;b, const T3 &amp;c)</td></tr>
<tr class="memdesc:gaeff1eab92ba879fcb74710a0b5ad08f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum function for three arguments.  <a href="#gaeff1eab92ba879fcb74710a0b5ad08f0">More...</a><br /></td></tr>
<tr class="separator:gaeff1eab92ba879fcb74710a0b5ad08f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2357436c0300543a47135f437ac0afbe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2357436c0300543a47135f437ac0afbe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2357436c0300543a47135f437ac0afbe">blaze::round</a> (T a)</td></tr>
<tr class="memdesc:ga2357436c0300543a47135f437ac0afbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the given input value.  <a href="#ga2357436c0300543a47135f437ac0afbe">More...</a><br /></td></tr>
<tr class="separator:ga2357436c0300543a47135f437ac0afbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ab0aea405bc3b739ffc3dd3781a3129"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5ab0aea405bc3b739ffc3dd3781a3129"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5ab0aea405bc3b739ffc3dd3781a3129">blaze::lessThan</a> (T1 a, T2 b)</td></tr>
<tr class="memdesc:ga5ab0aea405bc3b739ffc3dd3781a3129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic less-than comparison.  <a href="#ga5ab0aea405bc3b739ffc3dd3781a3129">More...</a><br /></td></tr>
<tr class="separator:ga5ab0aea405bc3b739ffc3dd3781a3129"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
NegativeInfinity operators</h2></td></tr>
<tr class="memitem:ga62957325299b3c3cdfe774ada80f4312"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:ga62957325299b3c3cdfe774ada80f4312"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga62957325299b3c3cdfe774ada80f4312">blaze::operator==</a> (const NegativeInfinity&lt; I1 &gt; &amp;lhs, const NegativeInfinity&lt; I2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga62957325299b3c3cdfe774ada80f4312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> objects.  <a href="#ga62957325299b3c3cdfe774ada80f4312">More...</a><br /></td></tr>
<tr class="separator:ga62957325299b3c3cdfe774ada80f4312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa89e010144eab077e9d596e74bab15b2"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:gaa89e010144eab077e9d596e74bab15b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa89e010144eab077e9d596e74bab15b2">blaze::operator==</a> (const NegativeInfinity&lt; I &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaa89e010144eab077e9d596e74bab15b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type.  <a href="#gaa89e010144eab077e9d596e74bab15b2">More...</a><br /></td></tr>
<tr class="separator:gaa89e010144eab077e9d596e74bab15b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ce1ea57d9c7fd4be3ab4d75310032c"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:ga52ce1ea57d9c7fd4be3ab4d75310032c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga52ce1ea57d9c7fd4be3ab4d75310032c">blaze::operator==</a> (const T &amp;lhs, const NegativeInfinity&lt; I &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga52ce1ea57d9c7fd4be3ab4d75310032c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="#ga52ce1ea57d9c7fd4be3ab4d75310032c">More...</a><br /></td></tr>
<tr class="separator:ga52ce1ea57d9c7fd4be3ab4d75310032c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2ce8d04b569787a93da217d1852f963"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:gad2ce8d04b569787a93da217d1852f963"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad2ce8d04b569787a93da217d1852f963">blaze::operator!=</a> (const NegativeInfinity&lt; I1 &gt; &amp;lhs, const NegativeInfinity&lt; I2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad2ce8d04b569787a93da217d1852f963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> objects.  <a href="#gad2ce8d04b569787a93da217d1852f963">More...</a><br /></td></tr>
<tr class="separator:gad2ce8d04b569787a93da217d1852f963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga313c450e022ce76f66888b2b6be23e70"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:ga313c450e022ce76f66888b2b6be23e70"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga313c450e022ce76f66888b2b6be23e70">blaze::operator!=</a> (const NegativeInfinity&lt; I &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga313c450e022ce76f66888b2b6be23e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type.  <a href="#ga313c450e022ce76f66888b2b6be23e70">More...</a><br /></td></tr>
<tr class="separator:ga313c450e022ce76f66888b2b6be23e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9e7c387680b76ecf9056a3354c4f82"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:gabc9e7c387680b76ecf9056a3354c4f82"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabc9e7c387680b76ecf9056a3354c4f82">blaze::operator!=</a> (const T &amp;lhs, const NegativeInfinity&lt; I &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabc9e7c387680b76ecf9056a3354c4f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="#gabc9e7c387680b76ecf9056a3354c4f82">More...</a><br /></td></tr>
<tr class="separator:gabc9e7c387680b76ecf9056a3354c4f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Infinity operators</h2></td></tr>
<tr class="memitem:ga655562d8f01de67e6b3cf6aba3a7c39f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga655562d8f01de67e6b3cf6aba3a7c39f">blaze::operator==</a> (const Infinity &amp;lhs, const Infinity &amp;rhs)</td></tr>
<tr class="memdesc:ga655562d8f01de67e6b3cf6aba3a7c39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> objects.  <a href="#ga655562d8f01de67e6b3cf6aba3a7c39f">More...</a><br /></td></tr>
<tr class="separator:ga655562d8f01de67e6b3cf6aba3a7c39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbecdbaa49a24b4f6f8f73a682c7e87a"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:gafbecdbaa49a24b4f6f8f73a682c7e87a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gafbecdbaa49a24b4f6f8f73a682c7e87a">blaze::operator==</a> (const Infinity &amp;lhs, const NegativeInfinity&lt; I &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gafbecdbaa49a24b4f6f8f73a682c7e87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="#gafbecdbaa49a24b4f6f8f73a682c7e87a">More...</a><br /></td></tr>
<tr class="separator:gafbecdbaa49a24b4f6f8f73a682c7e87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac26ca9f27a8e99ff712891dce3cf7d7f"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:gac26ca9f27a8e99ff712891dce3cf7d7f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac26ca9f27a8e99ff712891dce3cf7d7f">blaze::operator==</a> (const NegativeInfinity&lt; I &gt; &amp;lhs, const Infinity &amp;rhs)</td></tr>
<tr class="memdesc:gac26ca9f27a8e99ff712891dce3cf7d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="#gac26ca9f27a8e99ff712891dce3cf7d7f">More...</a><br /></td></tr>
<tr class="separator:gac26ca9f27a8e99ff712891dce3cf7d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga051a2e303820cb2fde125c7516f75ce9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga051a2e303820cb2fde125c7516f75ce9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga051a2e303820cb2fde125c7516f75ce9">blaze::operator==</a> (const Infinity &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga051a2e303820cb2fde125c7516f75ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type.  <a href="#ga051a2e303820cb2fde125c7516f75ce9">More...</a><br /></td></tr>
<tr class="separator:ga051a2e303820cb2fde125c7516f75ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef53b8be129fa00b953bb0f160413b80"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaef53b8be129fa00b953bb0f160413b80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaef53b8be129fa00b953bb0f160413b80">blaze::operator==</a> (const T &amp;lhs, const Infinity &amp;rhs)</td></tr>
<tr class="memdesc:gaef53b8be129fa00b953bb0f160413b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="#gaef53b8be129fa00b953bb0f160413b80">More...</a><br /></td></tr>
<tr class="separator:gaef53b8be129fa00b953bb0f160413b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca25a01de529bfdb940d9524eb8cd007"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaca25a01de529bfdb940d9524eb8cd007">blaze::operator!=</a> (const Infinity &amp;lhs, const Infinity &amp;rhs)</td></tr>
<tr class="memdesc:gaca25a01de529bfdb940d9524eb8cd007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> objects.  <a href="#gaca25a01de529bfdb940d9524eb8cd007">More...</a><br /></td></tr>
<tr class="separator:gaca25a01de529bfdb940d9524eb8cd007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6781afeed67b5b4945558b94aaa86073"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:ga6781afeed67b5b4945558b94aaa86073"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6781afeed67b5b4945558b94aaa86073">blaze::operator!=</a> (const Infinity &amp;lhs, const NegativeInfinity&lt; I &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga6781afeed67b5b4945558b94aaa86073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object.  <a href="#ga6781afeed67b5b4945558b94aaa86073">More...</a><br /></td></tr>
<tr class="separator:ga6781afeed67b5b4945558b94aaa86073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36ef11516f633356b7652726f2543d87"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:ga36ef11516f633356b7652726f2543d87"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga36ef11516f633356b7652726f2543d87">blaze::operator!=</a> (const NegativeInfinity&lt; I &gt; &amp;lhs, const Infinity &amp;rhs)</td></tr>
<tr class="memdesc:ga36ef11516f633356b7652726f2543d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="#ga36ef11516f633356b7652726f2543d87">More...</a><br /></td></tr>
<tr class="separator:ga36ef11516f633356b7652726f2543d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8c22e5fcef35073910201a7e0ae05a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0b8c22e5fcef35073910201a7e0ae05a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0b8c22e5fcef35073910201a7e0ae05a">blaze::operator!=</a> (const Infinity &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga0b8c22e5fcef35073910201a7e0ae05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type.  <a href="#ga0b8c22e5fcef35073910201a7e0ae05a">More...</a><br /></td></tr>
<tr class="separator:ga0b8c22e5fcef35073910201a7e0ae05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d28fd67d95a6015c5b5b6fd62762e22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1d28fd67d95a6015c5b5b6fd62762e22"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1d28fd67d95a6015c5b5b6fd62762e22">blaze::operator!=</a> (const T &amp;lhs, const Infinity &amp;rhs)</td></tr>
<tr class="memdesc:ga1d28fd67d95a6015c5b5b6fd62762e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object.  <a href="#ga1d28fd67d95a6015c5b5b6fd62762e22">More...</a><br /></td></tr>
<tr class="separator:ga1d28fd67d95a6015c5b5b6fd62762e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DenseMatrixProxy global functions</h2></td></tr>
<tr class="memitem:ga473e41444b6324cdd14e5a675b829f4a"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga473e41444b6324cdd14e5a675b829f4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseMatrixProxy&lt; PT, MT &gt;::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga473e41444b6324cdd14e5a675b829f4a">blaze::begin</a> (const DenseMatrixProxy&lt; PT, MT &gt; &amp;proxy, size_t i)</td></tr>
<tr class="memdesc:ga473e41444b6324cdd14e5a675b829f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em> of the represented matrix.  <a href="#ga473e41444b6324cdd14e5a675b829f4a">More...</a><br /></td></tr>
<tr class="separator:ga473e41444b6324cdd14e5a675b829f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e4b8a71e6e426f52371c0d5b9846fd"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gab5e4b8a71e6e426f52371c0d5b9846fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseMatrixProxy&lt; PT, MT &gt;::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gab5e4b8a71e6e426f52371c0d5b9846fd">blaze::cbegin</a> (const DenseMatrixProxy&lt; PT, MT &gt; &amp;proxy, size_t i)</td></tr>
<tr class="memdesc:gab5e4b8a71e6e426f52371c0d5b9846fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em> of the represented matrix.  <a href="#gab5e4b8a71e6e426f52371c0d5b9846fd">More...</a><br /></td></tr>
<tr class="separator:gab5e4b8a71e6e426f52371c0d5b9846fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd12cbf050e7ee64aff69936d37d6b97"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gabd12cbf050e7ee64aff69936d37d6b97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseMatrixProxy&lt; PT, MT &gt;::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabd12cbf050e7ee64aff69936d37d6b97">blaze::end</a> (const DenseMatrixProxy&lt; PT, MT &gt; &amp;proxy, size_t i)</td></tr>
<tr class="memdesc:gabd12cbf050e7ee64aff69936d37d6b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix.  <a href="#gabd12cbf050e7ee64aff69936d37d6b97">More...</a><br /></td></tr>
<tr class="separator:gabd12cbf050e7ee64aff69936d37d6b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb1b473d7716b9abe090c3db5c8df431"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gacb1b473d7716b9abe090c3db5c8df431"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseMatrixProxy&lt; PT, MT &gt;::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gacb1b473d7716b9abe090c3db5c8df431">blaze::cend</a> (const DenseMatrixProxy&lt; PT, MT &gt; &amp;proxy, size_t i)</td></tr>
<tr class="memdesc:gacb1b473d7716b9abe090c3db5c8df431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix.  <a href="#gacb1b473d7716b9abe090c3db5c8df431">More...</a><br /></td></tr>
<tr class="separator:gacb1b473d7716b9abe090c3db5c8df431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b7cec0953f0e0be2c5220bd61e6e2e3"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga9b7cec0953f0e0be2c5220bd61e6e2e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9b7cec0953f0e0be2c5220bd61e6e2e3">blaze::rows</a> (const DenseMatrixProxy&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga9b7cec0953f0e0be2c5220bd61e6e2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of rows of the represented matrix.  <a href="#ga9b7cec0953f0e0be2c5220bd61e6e2e3">More...</a><br /></td></tr>
<tr class="separator:ga9b7cec0953f0e0be2c5220bd61e6e2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf184ec513c031b63bb72c7161f7f9f5c"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaf184ec513c031b63bb72c7161f7f9f5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf184ec513c031b63bb72c7161f7f9f5c">blaze::columns</a> (const DenseMatrixProxy&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaf184ec513c031b63bb72c7161f7f9f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of columns of the represented matrix.  <a href="#gaf184ec513c031b63bb72c7161f7f9f5c">More...</a><br /></td></tr>
<tr class="separator:gaf184ec513c031b63bb72c7161f7f9f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdce650ad06eb019f79bb6b7e92bf15d"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gabdce650ad06eb019f79bb6b7e92bf15d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabdce650ad06eb019f79bb6b7e92bf15d">blaze::capacity</a> (const DenseMatrixProxy&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gabdce650ad06eb019f79bb6b7e92bf15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the represented matrix.  <a href="#gabdce650ad06eb019f79bb6b7e92bf15d">More...</a><br /></td></tr>
<tr class="separator:gabdce650ad06eb019f79bb6b7e92bf15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad086b7d12b02acd9fadbba5c105350c0"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gad086b7d12b02acd9fadbba5c105350c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad086b7d12b02acd9fadbba5c105350c0">blaze::capacity</a> (const DenseMatrixProxy&lt; PT, MT &gt; &amp;proxy, size_t i)</td></tr>
<tr class="memdesc:gad086b7d12b02acd9fadbba5c105350c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the specified row/column of the represented matrix.  <a href="#gad086b7d12b02acd9fadbba5c105350c0">More...</a><br /></td></tr>
<tr class="separator:gad086b7d12b02acd9fadbba5c105350c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf98d55b3997a5e0666e9467aac2f383e"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaf98d55b3997a5e0666e9467aac2f383e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf98d55b3997a5e0666e9467aac2f383e">blaze::nonZeros</a> (const DenseMatrixProxy&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaf98d55b3997a5e0666e9467aac2f383e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the represented matrix.  <a href="#gaf98d55b3997a5e0666e9467aac2f383e">More...</a><br /></td></tr>
<tr class="separator:gaf98d55b3997a5e0666e9467aac2f383e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade25555a94e648076982a8c68fb38b70"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gade25555a94e648076982a8c68fb38b70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gade25555a94e648076982a8c68fb38b70">blaze::nonZeros</a> (const DenseMatrixProxy&lt; PT, MT &gt; &amp;proxy, size_t i)</td></tr>
<tr class="memdesc:gade25555a94e648076982a8c68fb38b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the specified row/column of the represented matrix.  <a href="#gade25555a94e648076982a8c68fb38b70">More...</a><br /></td></tr>
<tr class="separator:gade25555a94e648076982a8c68fb38b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b361008599fbe7c5ad3262ed1cf8bf9"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga6b361008599fbe7c5ad3262ed1cf8bf9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6b361008599fbe7c5ad3262ed1cf8bf9">blaze::reset</a> (const DenseMatrixProxy&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga6b361008599fbe7c5ad3262ed1cf8bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="#ga6b361008599fbe7c5ad3262ed1cf8bf9">More...</a><br /></td></tr>
<tr class="separator:ga6b361008599fbe7c5ad3262ed1cf8bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga218b5d7e25e582cf759a0ffb94d8f88b"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga218b5d7e25e582cf759a0ffb94d8f88b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga218b5d7e25e582cf759a0ffb94d8f88b">blaze::reset</a> (const DenseMatrixProxy&lt; PT, MT &gt; &amp;proxy, size_t i)</td></tr>
<tr class="memdesc:ga218b5d7e25e582cf759a0ffb94d8f88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column of the represented matrix.  <a href="#ga218b5d7e25e582cf759a0ffb94d8f88b">More...</a><br /></td></tr>
<tr class="separator:ga218b5d7e25e582cf759a0ffb94d8f88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d821c7a793e0c694258e2917bb44edc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga1d821c7a793e0c694258e2917bb44edc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1d821c7a793e0c694258e2917bb44edc">blaze::clear</a> (const DenseMatrixProxy&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga1d821c7a793e0c694258e2917bb44edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented matrix.  <a href="#ga1d821c7a793e0c694258e2917bb44edc">More...</a><br /></td></tr>
<tr class="separator:ga1d821c7a793e0c694258e2917bb44edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
DenseVectorProxy global functions</h2></td></tr>
<tr class="memitem:ga33cd8a737acd2b68cf33d84baad75bf8"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga33cd8a737acd2b68cf33d84baad75bf8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseVectorProxy&lt; PT, VT &gt;::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga33cd8a737acd2b68cf33d84baad75bf8">blaze::begin</a> (const DenseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga33cd8a737acd2b68cf33d84baad75bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the represented vector.  <a href="#ga33cd8a737acd2b68cf33d84baad75bf8">More...</a><br /></td></tr>
<tr class="separator:ga33cd8a737acd2b68cf33d84baad75bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1552651c7e7b05385a91c477f198b92c"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga1552651c7e7b05385a91c477f198b92c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseVectorProxy&lt; PT, VT &gt;::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1552651c7e7b05385a91c477f198b92c">blaze::cbegin</a> (const DenseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga1552651c7e7b05385a91c477f198b92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the represented vector.  <a href="#ga1552651c7e7b05385a91c477f198b92c">More...</a><br /></td></tr>
<tr class="separator:ga1552651c7e7b05385a91c477f198b92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad47f01490e02fe97e3e71003d70006b1"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gad47f01490e02fe97e3e71003d70006b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseVectorProxy&lt; PT, VT &gt;::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad47f01490e02fe97e3e71003d70006b1">blaze::end</a> (const DenseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad47f01490e02fe97e3e71003d70006b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the represented vector.  <a href="#gad47f01490e02fe97e3e71003d70006b1">More...</a><br /></td></tr>
<tr class="separator:gad47f01490e02fe97e3e71003d70006b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga485df6bb7b74d08f29bcc446517f33bc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga485df6bb7b74d08f29bcc446517f33bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseVectorProxy&lt; PT, VT &gt;::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga485df6bb7b74d08f29bcc446517f33bc">blaze::cend</a> (const DenseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga485df6bb7b74d08f29bcc446517f33bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the represented vector.  <a href="#ga485df6bb7b74d08f29bcc446517f33bc">More...</a><br /></td></tr>
<tr class="separator:ga485df6bb7b74d08f29bcc446517f33bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga815b73881a05f1de2c4ed92521758c22"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga815b73881a05f1de2c4ed92521758c22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga815b73881a05f1de2c4ed92521758c22">blaze::size</a> (const DenseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga815b73881a05f1de2c4ed92521758c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size/dimension of the represented vector.  <a href="#ga815b73881a05f1de2c4ed92521758c22">More...</a><br /></td></tr>
<tr class="separator:ga815b73881a05f1de2c4ed92521758c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ad8f51a4e5551c83c078c2729c2bece"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga9ad8f51a4e5551c83c078c2729c2bece"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9ad8f51a4e5551c83c078c2729c2bece">blaze::capacity</a> (const DenseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga9ad8f51a4e5551c83c078c2729c2bece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the represented vector.  <a href="#ga9ad8f51a4e5551c83c078c2729c2bece">More...</a><br /></td></tr>
<tr class="separator:ga9ad8f51a4e5551c83c078c2729c2bece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb886f8afac581ea219e7fd9dfdf6c74"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gacb886f8afac581ea219e7fd9dfdf6c74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gacb886f8afac581ea219e7fd9dfdf6c74">blaze::nonZeros</a> (const DenseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gacb886f8afac581ea219e7fd9dfdf6c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the represented vector.  <a href="#gacb886f8afac581ea219e7fd9dfdf6c74">More...</a><br /></td></tr>
<tr class="separator:gacb886f8afac581ea219e7fd9dfdf6c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5277ea1f337ba3a87d2dad48b609cec7"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga5277ea1f337ba3a87d2dad48b609cec7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5277ea1f337ba3a87d2dad48b609cec7">blaze::reset</a> (const DenseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga5277ea1f337ba3a87d2dad48b609cec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented vector to the default initial values.  <a href="#ga5277ea1f337ba3a87d2dad48b609cec7">More...</a><br /></td></tr>
<tr class="separator:ga5277ea1f337ba3a87d2dad48b609cec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae42eef9a424004a86df6fc9c4115c2bc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gae42eef9a424004a86df6fc9c4115c2bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae42eef9a424004a86df6fc9c4115c2bc">blaze::clear</a> (const DenseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gae42eef9a424004a86df6fc9c4115c2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented vector.  <a href="#gae42eef9a424004a86df6fc9c4115c2bc">More...</a><br /></td></tr>
<tr class="separator:gae42eef9a424004a86df6fc9c4115c2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseMatrixProxy global functions</h2></td></tr>
<tr class="memitem:ga34acd458b656ec2167762cc3fb1bdd1f"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga34acd458b656ec2167762cc3fb1bdd1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseMatrixProxy&lt; PT, MT &gt;::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga34acd458b656ec2167762cc3fb1bdd1f">blaze::begin</a> (const SparseMatrixProxy&lt; PT, MT &gt; &amp;proxy, size_t i)</td></tr>
<tr class="memdesc:ga34acd458b656ec2167762cc3fb1bdd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em> of the represented matrix.  <a href="#ga34acd458b656ec2167762cc3fb1bdd1f">More...</a><br /></td></tr>
<tr class="separator:ga34acd458b656ec2167762cc3fb1bdd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa97c7a3f2a26f8a8a918b3ef33ea1adc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaa97c7a3f2a26f8a8a918b3ef33ea1adc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseMatrixProxy&lt; PT, MT &gt;::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa97c7a3f2a26f8a8a918b3ef33ea1adc">blaze::cbegin</a> (const SparseMatrixProxy&lt; PT, MT &gt; &amp;proxy, size_t i)</td></tr>
<tr class="memdesc:gaa97c7a3f2a26f8a8a918b3ef33ea1adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em> of the represented matrix.  <a href="#gaa97c7a3f2a26f8a8a918b3ef33ea1adc">More...</a><br /></td></tr>
<tr class="separator:gaa97c7a3f2a26f8a8a918b3ef33ea1adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff459171ee4708a8fc325de33d9345aa"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaff459171ee4708a8fc325de33d9345aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseMatrixProxy&lt; PT, MT &gt;::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaff459171ee4708a8fc325de33d9345aa">blaze::end</a> (const SparseMatrixProxy&lt; PT, MT &gt; &amp;proxy, size_t i)</td></tr>
<tr class="memdesc:gaff459171ee4708a8fc325de33d9345aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix.  <a href="#gaff459171ee4708a8fc325de33d9345aa">More...</a><br /></td></tr>
<tr class="separator:gaff459171ee4708a8fc325de33d9345aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58b9786b8a311ab1bf97f247f566edd9"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga58b9786b8a311ab1bf97f247f566edd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseMatrixProxy&lt; PT, MT &gt;::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga58b9786b8a311ab1bf97f247f566edd9">blaze::cend</a> (const SparseMatrixProxy&lt; PT, MT &gt; &amp;proxy, size_t i)</td></tr>
<tr class="memdesc:ga58b9786b8a311ab1bf97f247f566edd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix.  <a href="#ga58b9786b8a311ab1bf97f247f566edd9">More...</a><br /></td></tr>
<tr class="separator:ga58b9786b8a311ab1bf97f247f566edd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e08caafa4583f32333b5d17f1c4ef5"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga51e08caafa4583f32333b5d17f1c4ef5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga51e08caafa4583f32333b5d17f1c4ef5">blaze::rows</a> (const SparseMatrixProxy&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga51e08caafa4583f32333b5d17f1c4ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of rows of the represented matrix.  <a href="#ga51e08caafa4583f32333b5d17f1c4ef5">More...</a><br /></td></tr>
<tr class="separator:ga51e08caafa4583f32333b5d17f1c4ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69887db471553a593455e9939bd20e8"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaa69887db471553a593455e9939bd20e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa69887db471553a593455e9939bd20e8">blaze::columns</a> (const SparseMatrixProxy&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa69887db471553a593455e9939bd20e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of columns of the represented matrix.  <a href="#gaa69887db471553a593455e9939bd20e8">More...</a><br /></td></tr>
<tr class="separator:gaa69887db471553a593455e9939bd20e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d7b618c624d4911ae7f3882a05dc14"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gaf8d7b618c624d4911ae7f3882a05dc14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf8d7b618c624d4911ae7f3882a05dc14">blaze::capacity</a> (const SparseMatrixProxy&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaf8d7b618c624d4911ae7f3882a05dc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the represented matrix.  <a href="#gaf8d7b618c624d4911ae7f3882a05dc14">More...</a><br /></td></tr>
<tr class="separator:gaf8d7b618c624d4911ae7f3882a05dc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3df62b3c237c2a2b04fc28e7a20dcf"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga1c3df62b3c237c2a2b04fc28e7a20dcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1c3df62b3c237c2a2b04fc28e7a20dcf">blaze::capacity</a> (const SparseMatrixProxy&lt; PT, MT &gt; &amp;proxy, size_t i)</td></tr>
<tr class="memdesc:ga1c3df62b3c237c2a2b04fc28e7a20dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the specified row/column of the represented matrix.  <a href="#ga1c3df62b3c237c2a2b04fc28e7a20dcf">More...</a><br /></td></tr>
<tr class="separator:ga1c3df62b3c237c2a2b04fc28e7a20dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8d4a1ad716a90d183a1f310887f678f"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gad8d4a1ad716a90d183a1f310887f678f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad8d4a1ad716a90d183a1f310887f678f">blaze::nonZeros</a> (const SparseMatrixProxy&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad8d4a1ad716a90d183a1f310887f678f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the represented matrix.  <a href="#gad8d4a1ad716a90d183a1f310887f678f">More...</a><br /></td></tr>
<tr class="separator:gad8d4a1ad716a90d183a1f310887f678f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe8aa45ed742cea841472f9f575f9c71"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:gabe8aa45ed742cea841472f9f575f9c71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabe8aa45ed742cea841472f9f575f9c71">blaze::nonZeros</a> (const SparseMatrixProxy&lt; PT, MT &gt; &amp;proxy, size_t i)</td></tr>
<tr class="memdesc:gabe8aa45ed742cea841472f9f575f9c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the specified row/column of the represented matrix.  <a href="#gabe8aa45ed742cea841472f9f575f9c71">More...</a><br /></td></tr>
<tr class="separator:gabe8aa45ed742cea841472f9f575f9c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df60d6b50394cad1e546a4cd8969af6"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga7df60d6b50394cad1e546a4cd8969af6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7df60d6b50394cad1e546a4cd8969af6">blaze::reset</a> (const SparseMatrixProxy&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga7df60d6b50394cad1e546a4cd8969af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="#ga7df60d6b50394cad1e546a4cd8969af6">More...</a><br /></td></tr>
<tr class="separator:ga7df60d6b50394cad1e546a4cd8969af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a8a33a97692e307634bf7db10cd6276"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga5a8a33a97692e307634bf7db10cd6276"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga5a8a33a97692e307634bf7db10cd6276">blaze::reset</a> (const SparseMatrixProxy&lt; PT, MT &gt; &amp;proxy, size_t i)</td></tr>
<tr class="memdesc:ga5a8a33a97692e307634bf7db10cd6276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column of the represented matrix.  <a href="#ga5a8a33a97692e307634bf7db10cd6276">More...</a><br /></td></tr>
<tr class="separator:ga5a8a33a97692e307634bf7db10cd6276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a52ebee9e73c73f6492af64841cdca"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename MT &gt; </td></tr>
<tr class="memitem:ga98a52ebee9e73c73f6492af64841cdca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga98a52ebee9e73c73f6492af64841cdca">blaze::clear</a> (const SparseMatrixProxy&lt; PT, MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga98a52ebee9e73c73f6492af64841cdca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented matrix.  <a href="#ga98a52ebee9e73c73f6492af64841cdca">More...</a><br /></td></tr>
<tr class="separator:ga98a52ebee9e73c73f6492af64841cdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseVectorProxy global functions</h2></td></tr>
<tr class="memitem:ga8d0d84fb462bcda9e4ac1b46da8f4e3a"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga8d0d84fb462bcda9e4ac1b46da8f4e3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseVectorProxy&lt; PT, VT &gt;::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga8d0d84fb462bcda9e4ac1b46da8f4e3a">blaze::begin</a> (const SparseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga8d0d84fb462bcda9e4ac1b46da8f4e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the represented vector.  <a href="#ga8d0d84fb462bcda9e4ac1b46da8f4e3a">More...</a><br /></td></tr>
<tr class="separator:ga8d0d84fb462bcda9e4ac1b46da8f4e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64edd34b7ccc061871ebf7b372a0d1c"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gaa64edd34b7ccc061871ebf7b372a0d1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseVectorProxy&lt; PT, VT &gt;::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa64edd34b7ccc061871ebf7b372a0d1c">blaze::cbegin</a> (const SparseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa64edd34b7ccc061871ebf7b372a0d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the represented vector.  <a href="#gaa64edd34b7ccc061871ebf7b372a0d1c">More...</a><br /></td></tr>
<tr class="separator:gaa64edd34b7ccc061871ebf7b372a0d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2eb393d47a7d6681303ec6729fe259"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga7a2eb393d47a7d6681303ec6729fe259"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseVectorProxy&lt; PT, VT &gt;::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7a2eb393d47a7d6681303ec6729fe259">blaze::end</a> (const SparseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga7a2eb393d47a7d6681303ec6729fe259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the represented vector.  <a href="#ga7a2eb393d47a7d6681303ec6729fe259">More...</a><br /></td></tr>
<tr class="separator:ga7a2eb393d47a7d6681303ec6729fe259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1731ef12d4ac4b1847d616935cd74cc8"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga1731ef12d4ac4b1847d616935cd74cc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseVectorProxy&lt; PT, VT &gt;::ConstIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1731ef12d4ac4b1847d616935cd74cc8">blaze::cend</a> (const SparseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga1731ef12d4ac4b1847d616935cd74cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of the represented vector.  <a href="#ga1731ef12d4ac4b1847d616935cd74cc8">More...</a><br /></td></tr>
<tr class="separator:ga1731ef12d4ac4b1847d616935cd74cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d73069d106d356f221e1dca36f86f8"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gac0d73069d106d356f221e1dca36f86f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac0d73069d106d356f221e1dca36f86f8">blaze::size</a> (const SparseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gac0d73069d106d356f221e1dca36f86f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size/dimension of the represented vector.  <a href="#gac0d73069d106d356f221e1dca36f86f8">More...</a><br /></td></tr>
<tr class="separator:gac0d73069d106d356f221e1dca36f86f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16914bece2ebf39b5e72e42727593ffd"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga16914bece2ebf39b5e72e42727593ffd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga16914bece2ebf39b5e72e42727593ffd">blaze::capacity</a> (const SparseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga16914bece2ebf39b5e72e42727593ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the represented vector.  <a href="#ga16914bece2ebf39b5e72e42727593ffd">More...</a><br /></td></tr>
<tr class="separator:ga16914bece2ebf39b5e72e42727593ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c458777c59275735f874c6bb6b3dcc"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gae3c458777c59275735f874c6bb6b3dcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae3c458777c59275735f874c6bb6b3dcc">blaze::nonZeros</a> (const SparseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gae3c458777c59275735f874c6bb6b3dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the represented vector.  <a href="#gae3c458777c59275735f874c6bb6b3dcc">More...</a><br /></td></tr>
<tr class="separator:gae3c458777c59275735f874c6bb6b3dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad18d9138d144ff01dcf136f703443a80"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:gad18d9138d144ff01dcf136f703443a80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad18d9138d144ff01dcf136f703443a80">blaze::reset</a> (const SparseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gad18d9138d144ff01dcf136f703443a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="#gad18d9138d144ff01dcf136f703443a80">More...</a><br /></td></tr>
<tr class="separator:gad18d9138d144ff01dcf136f703443a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga727608d5ba71b44eb89fb8d00e567c5f"><td class="memTemplParams" colspan="2">template&lt;typename PT , typename VT &gt; </td></tr>
<tr class="memitem:ga727608d5ba71b44eb89fb8d00e567c5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga727608d5ba71b44eb89fb8d00e567c5f">blaze::clear</a> (const SparseVectorProxy&lt; PT, VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga727608d5ba71b44eb89fb8d00e567c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="#ga727608d5ba71b44eb89fb8d00e567c5f">More...</a><br /></td></tr>
<tr class="separator:ga727608d5ba71b44eb89fb8d00e567c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
MatrixAccessProxy operators</h2></td></tr>
<tr class="memitem:gadbacbd1246746a45c7a1dcab279c2d8a"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gadbacbd1246746a45c7a1dcab279c2d8a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gadbacbd1246746a45c7a1dcab279c2d8a">blaze::operator==</a> (const MatrixAccessProxy&lt; MT1 &gt; &amp;lhs, const MatrixAccessProxy&lt; MT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gadbacbd1246746a45c7a1dcab279c2d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> objects.  <a href="#gadbacbd1246746a45c7a1dcab279c2d8a">More...</a><br /></td></tr>
<tr class="separator:gadbacbd1246746a45c7a1dcab279c2d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a6e11c1679c47a99a8916ab6f36a430"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:ga9a6e11c1679c47a99a8916ab6f36a430"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9a6e11c1679c47a99a8916ab6f36a430">blaze::operator==</a> (const MatrixAccessProxy&lt; MT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga9a6e11c1679c47a99a8916ab6f36a430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object and an object of different type.  <a href="#ga9a6e11c1679c47a99a8916ab6f36a430">More...</a><br /></td></tr>
<tr class="separator:ga9a6e11c1679c47a99a8916ab6f36a430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38c636cc9c1a670b065d42a1a4515f0c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:ga38c636cc9c1a670b065d42a1a4515f0c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga38c636cc9c1a670b065d42a1a4515f0c">blaze::operator==</a> (const T &amp;lhs, const MatrixAccessProxy&lt; MT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga38c636cc9c1a670b065d42a1a4515f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an object of different type and a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object.  <a href="#ga38c636cc9c1a670b065d42a1a4515f0c">More...</a><br /></td></tr>
<tr class="separator:ga38c636cc9c1a670b065d42a1a4515f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ef548bb2e362777a3b5636b28ec1cf3"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga9ef548bb2e362777a3b5636b28ec1cf3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9ef548bb2e362777a3b5636b28ec1cf3">blaze::operator!=</a> (const MatrixAccessProxy&lt; MT1 &gt; &amp;lhs, const MatrixAccessProxy&lt; MT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga9ef548bb2e362777a3b5636b28ec1cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> objects.  <a href="#ga9ef548bb2e362777a3b5636b28ec1cf3">More...</a><br /></td></tr>
<tr class="separator:ga9ef548bb2e362777a3b5636b28ec1cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa78690eb7486a2a90fe3543009ecac9"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:gaaa78690eb7486a2a90fe3543009ecac9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaaa78690eb7486a2a90fe3543009ecac9">blaze::operator!=</a> (const MatrixAccessProxy&lt; MT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gaaa78690eb7486a2a90fe3543009ecac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object and an object of different type.  <a href="#gaaa78690eb7486a2a90fe3543009ecac9">More...</a><br /></td></tr>
<tr class="separator:gaaa78690eb7486a2a90fe3543009ecac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea71061dabd437d913ce7c72caf45d41"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:gaea71061dabd437d913ce7c72caf45d41"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaea71061dabd437d913ce7c72caf45d41">blaze::operator!=</a> (const T &amp;lhs, const MatrixAccessProxy&lt; MT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaea71061dabd437d913ce7c72caf45d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquality comparison between an object of different type and a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object.  <a href="#gaea71061dabd437d913ce7c72caf45d41">More...</a><br /></td></tr>
<tr class="separator:gaea71061dabd437d913ce7c72caf45d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f949c39833f694a0acc922c3af440c"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gaf1f949c39833f694a0acc922c3af440c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaf1f949c39833f694a0acc922c3af440c">blaze::operator&lt;</a> (const MatrixAccessProxy&lt; MT1 &gt; &amp;lhs, const MatrixAccessProxy&lt; MT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf1f949c39833f694a0acc922c3af440c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between two <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> objects.  <a href="#gaf1f949c39833f694a0acc922c3af440c">More...</a><br /></td></tr>
<tr class="separator:gaf1f949c39833f694a0acc922c3af440c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ff1a96ef28bebf0d56cce417094026b"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:ga9ff1a96ef28bebf0d56cce417094026b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga9ff1a96ef28bebf0d56cce417094026b">blaze::operator&lt;</a> (const MatrixAccessProxy&lt; MT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga9ff1a96ef28bebf0d56cce417094026b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object and an object of different type.  <a href="#ga9ff1a96ef28bebf0d56cce417094026b">More...</a><br /></td></tr>
<tr class="separator:ga9ff1a96ef28bebf0d56cce417094026b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga959aedd0006bca949f5a67e493fcc263"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:ga959aedd0006bca949f5a67e493fcc263"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga959aedd0006bca949f5a67e493fcc263">blaze::operator&lt;</a> (const T &amp;lhs, const MatrixAccessProxy&lt; MT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga959aedd0006bca949f5a67e493fcc263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between an object of different type and a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object.  <a href="#ga959aedd0006bca949f5a67e493fcc263">More...</a><br /></td></tr>
<tr class="separator:ga959aedd0006bca949f5a67e493fcc263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77093a57f829dce5eee6b4b3d86d530c"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga77093a57f829dce5eee6b4b3d86d530c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga77093a57f829dce5eee6b4b3d86d530c">blaze::operator&gt;</a> (const MatrixAccessProxy&lt; MT1 &gt; &amp;lhs, const MatrixAccessProxy&lt; MT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga77093a57f829dce5eee6b4b3d86d530c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between two <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> objects.  <a href="#ga77093a57f829dce5eee6b4b3d86d530c">More...</a><br /></td></tr>
<tr class="separator:ga77093a57f829dce5eee6b4b3d86d530c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga044239e64e8e955acea91ae1c14c994a"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:ga044239e64e8e955acea91ae1c14c994a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga044239e64e8e955acea91ae1c14c994a">blaze::operator&gt;</a> (const MatrixAccessProxy&lt; MT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga044239e64e8e955acea91ae1c14c994a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object and an object of different type.  <a href="#ga044239e64e8e955acea91ae1c14c994a">More...</a><br /></td></tr>
<tr class="separator:ga044239e64e8e955acea91ae1c14c994a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83359a82f95f7facbc0b1c445c743326"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:ga83359a82f95f7facbc0b1c445c743326"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga83359a82f95f7facbc0b1c445c743326">blaze::operator&gt;</a> (const T &amp;lhs, const MatrixAccessProxy&lt; MT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga83359a82f95f7facbc0b1c445c743326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between an object of different type and a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object.  <a href="#ga83359a82f95f7facbc0b1c445c743326">More...</a><br /></td></tr>
<tr class="separator:ga83359a82f95f7facbc0b1c445c743326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7406274ca325fefa3df2ab43e6ee1075"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:ga7406274ca325fefa3df2ab43e6ee1075"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7406274ca325fefa3df2ab43e6ee1075">blaze::operator&lt;=</a> (const MatrixAccessProxy&lt; MT1 &gt; &amp;lhs, const MatrixAccessProxy&lt; MT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7406274ca325fefa3df2ab43e6ee1075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between two <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> objects.  <a href="#ga7406274ca325fefa3df2ab43e6ee1075">More...</a><br /></td></tr>
<tr class="separator:ga7406274ca325fefa3df2ab43e6ee1075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26551d0713ea4a4b8c6cfd4a7c8fa2d0"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:ga26551d0713ea4a4b8c6cfd4a7c8fa2d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga26551d0713ea4a4b8c6cfd4a7c8fa2d0">blaze::operator&lt;=</a> (const MatrixAccessProxy&lt; MT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga26551d0713ea4a4b8c6cfd4a7c8fa2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object and an object of different type.  <a href="#ga26551d0713ea4a4b8c6cfd4a7c8fa2d0">More...</a><br /></td></tr>
<tr class="separator:ga26551d0713ea4a4b8c6cfd4a7c8fa2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e6439ac29b32bb05ef2eb8d14913b4e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:ga2e6439ac29b32bb05ef2eb8d14913b4e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2e6439ac29b32bb05ef2eb8d14913b4e">blaze::operator&lt;=</a> (const T &amp;lhs, const MatrixAccessProxy&lt; MT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga2e6439ac29b32bb05ef2eb8d14913b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between an object of different type and a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object.  <a href="#ga2e6439ac29b32bb05ef2eb8d14913b4e">More...</a><br /></td></tr>
<tr class="separator:ga2e6439ac29b32bb05ef2eb8d14913b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae49b450bc781b5d48e924ba64e1566d1"><td class="memTemplParams" colspan="2">template&lt;typename MT1 , typename MT2 &gt; </td></tr>
<tr class="memitem:gae49b450bc781b5d48e924ba64e1566d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gae49b450bc781b5d48e924ba64e1566d1">blaze::operator&gt;=</a> (const MatrixAccessProxy&lt; MT1 &gt; &amp;lhs, const MatrixAccessProxy&lt; MT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gae49b450bc781b5d48e924ba64e1566d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between two <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> objects.  <a href="#gae49b450bc781b5d48e924ba64e1566d1">More...</a><br /></td></tr>
<tr class="separator:gae49b450bc781b5d48e924ba64e1566d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga162b096fdaf47541baa27d8328eac010"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:ga162b096fdaf47541baa27d8328eac010"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga162b096fdaf47541baa27d8328eac010">blaze::operator&gt;=</a> (const MatrixAccessProxy&lt; MT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga162b096fdaf47541baa27d8328eac010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object and an object of different type.  <a href="#ga162b096fdaf47541baa27d8328eac010">More...</a><br /></td></tr>
<tr class="separator:ga162b096fdaf47541baa27d8328eac010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7135ca170b91aa06582670d9cb991a44"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:ga7135ca170b91aa06582670d9cb991a44"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga7135ca170b91aa06582670d9cb991a44">blaze::operator&gt;=</a> (const T &amp;lhs, const MatrixAccessProxy&lt; MT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7135ca170b91aa06582670d9cb991a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between an object of different type and a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object.  <a href="#ga7135ca170b91aa06582670d9cb991a44">More...</a><br /></td></tr>
<tr class="separator:ga7135ca170b91aa06582670d9cb991a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga824329c3c439b14d96a3b0a3f6221cef"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga824329c3c439b14d96a3b0a3f6221cef"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga824329c3c439b14d96a3b0a3f6221cef">blaze::operator&lt;&lt;</a> (std::ostream &amp;os, const MatrixAccessProxy&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga824329c3c439b14d96a3b0a3f6221cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for the <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> class template.  <a href="#ga824329c3c439b14d96a3b0a3f6221cef">More...</a><br /></td></tr>
<tr class="separator:ga824329c3c439b14d96a3b0a3f6221cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
MatrixAccessProxy global functions</h2></td></tr>
<tr class="memitem:gaa329d4ff44a8780cb8f29343ffc32790"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:gaa329d4ff44a8780cb8f29343ffc32790"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa329d4ff44a8780cb8f29343ffc32790">blaze::reset</a> (const MatrixAccessProxy&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaa329d4ff44a8780cb8f29343ffc32790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="#gaa329d4ff44a8780cb8f29343ffc32790">More...</a><br /></td></tr>
<tr class="separator:gaa329d4ff44a8780cb8f29343ffc32790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3d9a939b2471f71e81d8eee8c22a5ae4">blaze::clear</a> (const MatrixAccessProxy&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="#ga3d9a939b2471f71e81d8eee8c22a5ae4">More...</a><br /></td></tr>
<tr class="separator:ga3d9a939b2471f71e81d8eee8c22a5ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga045077f88b05d5f5fa13c4ef1eaf0161"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga045077f88b05d5f5fa13c4ef1eaf0161"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga045077f88b05d5f5fa13c4ef1eaf0161">blaze::isDefault</a> (const MatrixAccessProxy&lt; MT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga045077f88b05d5f5fa13c4ef1eaf0161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="#ga045077f88b05d5f5fa13c4ef1eaf0161">More...</a><br /></td></tr>
<tr class="separator:ga045077f88b05d5f5fa13c4ef1eaf0161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84b0b9696de93cc4950814019c124aa6"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ga84b0b9696de93cc4950814019c124aa6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga84b0b9696de93cc4950814019c124aa6">blaze::swap</a> (const MatrixAccessProxy&lt; MT &gt; &amp;a, const MatrixAccessProxy&lt; MT &gt; &amp;b)</td></tr>
<tr class="memdesc:ga84b0b9696de93cc4950814019c124aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two access proxies.  <a href="#ga84b0b9696de93cc4950814019c124aa6">More...</a><br /></td></tr>
<tr class="separator:ga84b0b9696de93cc4950814019c124aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04034dd426e9c78cfa1b6d1bdffc0e10"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename T &gt; </td></tr>
<tr class="memitem:ga04034dd426e9c78cfa1b6d1bdffc0e10"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga04034dd426e9c78cfa1b6d1bdffc0e10">blaze::swap</a> (const MatrixAccessProxy&lt; MT &gt; &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:ga04034dd426e9c78cfa1b6d1bdffc0e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="#ga04034dd426e9c78cfa1b6d1bdffc0e10">More...</a><br /></td></tr>
<tr class="separator:ga04034dd426e9c78cfa1b6d1bdffc0e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1552a5426e51180216d9030bedfff20"><td class="memTemplParams" colspan="2">template&lt;typename T , typename MT &gt; </td></tr>
<tr class="memitem:gaa1552a5426e51180216d9030bedfff20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaa1552a5426e51180216d9030bedfff20">blaze::swap</a> (T &amp;a, const MatrixAccessProxy&lt; MT &gt; &amp;b)</td></tr>
<tr class="memdesc:gaa1552a5426e51180216d9030bedfff20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="#gaa1552a5426e51180216d9030bedfff20">More...</a><br /></td></tr>
<tr class="separator:gaa1552a5426e51180216d9030bedfff20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
VectorAccessProxy operators</h2></td></tr>
<tr class="memitem:gad48448011cb8dd68c6342c8677cc14b3"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gad48448011cb8dd68c6342c8677cc14b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gad48448011cb8dd68c6342c8677cc14b3">blaze::operator==</a> (const VectorAccessProxy&lt; VT1 &gt; &amp;lhs, const VectorAccessProxy&lt; VT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad48448011cb8dd68c6342c8677cc14b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> objects.  <a href="#gad48448011cb8dd68c6342c8677cc14b3">More...</a><br /></td></tr>
<tr class="separator:gad48448011cb8dd68c6342c8677cc14b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa1f0ce4980d2344ddaef5837171c16"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename T &gt; </td></tr>
<tr class="memitem:gabaa1f0ce4980d2344ddaef5837171c16"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gabaa1f0ce4980d2344ddaef5837171c16">blaze::operator==</a> (const VectorAccessProxy&lt; VT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gabaa1f0ce4980d2344ddaef5837171c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object and an object of different type.  <a href="#gabaa1f0ce4980d2344ddaef5837171c16">More...</a><br /></td></tr>
<tr class="separator:gabaa1f0ce4980d2344ddaef5837171c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b290a1fa75dff33cf122255d18aae41"><td class="memTemplParams" colspan="2">template&lt;typename T , typename VT &gt; </td></tr>
<tr class="memitem:ga1b290a1fa75dff33cf122255d18aae41"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga1b290a1fa75dff33cf122255d18aae41">blaze::operator==</a> (const T &amp;lhs, const VectorAccessProxy&lt; VT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1b290a1fa75dff33cf122255d18aae41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between an object of different type and a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object.  <a href="#ga1b290a1fa75dff33cf122255d18aae41">More...</a><br /></td></tr>
<tr class="separator:ga1b290a1fa75dff33cf122255d18aae41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37382d7c34d33f06cad082f7cfa85036"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga37382d7c34d33f06cad082f7cfa85036"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga37382d7c34d33f06cad082f7cfa85036">blaze::operator!=</a> (const VectorAccessProxy&lt; VT1 &gt; &amp;lhs, const VectorAccessProxy&lt; VT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga37382d7c34d33f06cad082f7cfa85036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between two <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> objects.  <a href="#ga37382d7c34d33f06cad082f7cfa85036">More...</a><br /></td></tr>
<tr class="separator:ga37382d7c34d33f06cad082f7cfa85036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75d9aaa612d5861fbd5a1166dd3b3c96"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename T &gt; </td></tr>
<tr class="memitem:ga75d9aaa612d5861fbd5a1166dd3b3c96"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga75d9aaa612d5861fbd5a1166dd3b3c96">blaze::operator!=</a> (const VectorAccessProxy&lt; VT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga75d9aaa612d5861fbd5a1166dd3b3c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison between a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object and an object of different type.  <a href="#ga75d9aaa612d5861fbd5a1166dd3b3c96">More...</a><br /></td></tr>
<tr class="separator:ga75d9aaa612d5861fbd5a1166dd3b3c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga175ba67536b1bb9e0c42c43e28772c78"><td class="memTemplParams" colspan="2">template&lt;typename T , typename VT &gt; </td></tr>
<tr class="memitem:ga175ba67536b1bb9e0c42c43e28772c78"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga175ba67536b1bb9e0c42c43e28772c78">blaze::operator!=</a> (const T &amp;lhs, const VectorAccessProxy&lt; VT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga175ba67536b1bb9e0c42c43e28772c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquality comparison between an object of different type and a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object.  <a href="#ga175ba67536b1bb9e0c42c43e28772c78">More...</a><br /></td></tr>
<tr class="separator:ga175ba67536b1bb9e0c42c43e28772c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5258365f88dab53563dfa0d49389855"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:gac5258365f88dab53563dfa0d49389855"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gac5258365f88dab53563dfa0d49389855">blaze::operator&lt;</a> (const VectorAccessProxy&lt; VT1 &gt; &amp;lhs, const VectorAccessProxy&lt; VT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gac5258365f88dab53563dfa0d49389855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between two <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> objects.  <a href="#gac5258365f88dab53563dfa0d49389855">More...</a><br /></td></tr>
<tr class="separator:gac5258365f88dab53563dfa0d49389855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6983c7c1017ad5332e378ad7160769bc"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename T &gt; </td></tr>
<tr class="memitem:ga6983c7c1017ad5332e378ad7160769bc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6983c7c1017ad5332e378ad7160769bc">blaze::operator&lt;</a> (const VectorAccessProxy&lt; VT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga6983c7c1017ad5332e378ad7160769bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object and an object of different type.  <a href="#ga6983c7c1017ad5332e378ad7160769bc">More...</a><br /></td></tr>
<tr class="separator:ga6983c7c1017ad5332e378ad7160769bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga151487afa014e0d54a14bdc08d885189"><td class="memTemplParams" colspan="2">template&lt;typename T , typename VT &gt; </td></tr>
<tr class="memitem:ga151487afa014e0d54a14bdc08d885189"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga151487afa014e0d54a14bdc08d885189">blaze::operator&lt;</a> (const T &amp;lhs, const VectorAccessProxy&lt; VT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga151487afa014e0d54a14bdc08d885189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison between an object of different type and a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object.  <a href="#ga151487afa014e0d54a14bdc08d885189">More...</a><br /></td></tr>
<tr class="separator:ga151487afa014e0d54a14bdc08d885189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d527ac477b7866bed57673a86a41377"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga0d527ac477b7866bed57673a86a41377"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0d527ac477b7866bed57673a86a41377">blaze::operator&gt;</a> (const VectorAccessProxy&lt; VT1 &gt; &amp;lhs, const VectorAccessProxy&lt; VT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0d527ac477b7866bed57673a86a41377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between two <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> objects.  <a href="#ga0d527ac477b7866bed57673a86a41377">More...</a><br /></td></tr>
<tr class="separator:ga0d527ac477b7866bed57673a86a41377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga662f69f6fe731fa92d68e2d0705d21cd"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename T &gt; </td></tr>
<tr class="memitem:ga662f69f6fe731fa92d68e2d0705d21cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga662f69f6fe731fa92d68e2d0705d21cd">blaze::operator&gt;</a> (const VectorAccessProxy&lt; VT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga662f69f6fe731fa92d68e2d0705d21cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object and an object of different type.  <a href="#ga662f69f6fe731fa92d68e2d0705d21cd">More...</a><br /></td></tr>
<tr class="separator:ga662f69f6fe731fa92d68e2d0705d21cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga352a7a263d5af50f5ed3c2adbbb26650"><td class="memTemplParams" colspan="2">template&lt;typename T , typename VT &gt; </td></tr>
<tr class="memitem:ga352a7a263d5af50f5ed3c2adbbb26650"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga352a7a263d5af50f5ed3c2adbbb26650">blaze::operator&gt;</a> (const T &amp;lhs, const VectorAccessProxy&lt; VT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga352a7a263d5af50f5ed3c2adbbb26650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than comparison between an object of different type and a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object.  <a href="#ga352a7a263d5af50f5ed3c2adbbb26650">More...</a><br /></td></tr>
<tr class="separator:ga352a7a263d5af50f5ed3c2adbbb26650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d3a2e43e521b703f01e422e2f36928a"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga3d3a2e43e521b703f01e422e2f36928a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga3d3a2e43e521b703f01e422e2f36928a">blaze::operator&lt;=</a> (const VectorAccessProxy&lt; VT1 &gt; &amp;lhs, const VectorAccessProxy&lt; VT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga3d3a2e43e521b703f01e422e2f36928a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between two <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> objects.  <a href="#ga3d3a2e43e521b703f01e422e2f36928a">More...</a><br /></td></tr>
<tr class="separator:ga3d3a2e43e521b703f01e422e2f36928a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4749e3903e7f27b4007c5dda73517093"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename T &gt; </td></tr>
<tr class="memitem:ga4749e3903e7f27b4007c5dda73517093"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4749e3903e7f27b4007c5dda73517093">blaze::operator&lt;=</a> (const VectorAccessProxy&lt; VT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ga4749e3903e7f27b4007c5dda73517093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object and an object of different type.  <a href="#ga4749e3903e7f27b4007c5dda73517093">More...</a><br /></td></tr>
<tr class="separator:ga4749e3903e7f27b4007c5dda73517093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0afaffd71fc9ca3128d04959cd93e583"><td class="memTemplParams" colspan="2">template&lt;typename T , typename VT &gt; </td></tr>
<tr class="memitem:ga0afaffd71fc9ca3128d04959cd93e583"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0afaffd71fc9ca3128d04959cd93e583">blaze::operator&lt;=</a> (const T &amp;lhs, const VectorAccessProxy&lt; VT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0afaffd71fc9ca3128d04959cd93e583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-or-equal-than comparison between an object of different type and a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object.  <a href="#ga0afaffd71fc9ca3128d04959cd93e583">More...</a><br /></td></tr>
<tr class="separator:ga0afaffd71fc9ca3128d04959cd93e583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a305e6fad74d2989d9423f7ddc9c4b7"><td class="memTemplParams" colspan="2">template&lt;typename VT1 , typename VT2 &gt; </td></tr>
<tr class="memitem:ga0a305e6fad74d2989d9423f7ddc9c4b7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga0a305e6fad74d2989d9423f7ddc9c4b7">blaze::operator&gt;=</a> (const VectorAccessProxy&lt; VT1 &gt; &amp;lhs, const VectorAccessProxy&lt; VT2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0a305e6fad74d2989d9423f7ddc9c4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between two <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> objects.  <a href="#ga0a305e6fad74d2989d9423f7ddc9c4b7">More...</a><br /></td></tr>
<tr class="separator:ga0a305e6fad74d2989d9423f7ddc9c4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade31b841a1677982148bd880b5088ea6"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename T &gt; </td></tr>
<tr class="memitem:gade31b841a1677982148bd880b5088ea6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gade31b841a1677982148bd880b5088ea6">blaze::operator&gt;=</a> (const VectorAccessProxy&lt; VT &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gade31b841a1677982148bd880b5088ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object and an object of different type.  <a href="#gade31b841a1677982148bd880b5088ea6">More...</a><br /></td></tr>
<tr class="separator:gade31b841a1677982148bd880b5088ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc29d5df06b66ef4a5ffc1e63e830ae"><td class="memTemplParams" colspan="2">template&lt;typename T , typename VT &gt; </td></tr>
<tr class="memitem:ga6cc29d5df06b66ef4a5ffc1e63e830ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga6cc29d5df06b66ef4a5ffc1e63e830ae">blaze::operator&gt;=</a> (const T &amp;lhs, const VectorAccessProxy&lt; VT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga6cc29d5df06b66ef4a5ffc1e63e830ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-or-equal-than comparison between an object of different type and a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object.  <a href="#ga6cc29d5df06b66ef4a5ffc1e63e830ae">More...</a><br /></td></tr>
<tr class="separator:ga6cc29d5df06b66ef4a5ffc1e63e830ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedcb4af011fc205eb97c713f504f302a"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gaedcb4af011fc205eb97c713f504f302a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gaedcb4af011fc205eb97c713f504f302a">blaze::operator&lt;&lt;</a> (std::ostream &amp;os, const VectorAccessProxy&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gaedcb4af011fc205eb97c713f504f302a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global output operator for the <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> class template.  <a href="#gaedcb4af011fc205eb97c713f504f302a">More...</a><br /></td></tr>
<tr class="separator:gaedcb4af011fc205eb97c713f504f302a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
VectorAccessProxy global functions</h2></td></tr>
<tr class="memitem:ga4ccb520d1605428c703fb1e231984b8a"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga4ccb520d1605428c703fb1e231984b8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga4ccb520d1605428c703fb1e231984b8a">blaze::reset</a> (const VectorAccessProxy&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga4ccb520d1605428c703fb1e231984b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the represented element to the default initial values.  <a href="#ga4ccb520d1605428c703fb1e231984b8a">More...</a><br /></td></tr>
<tr class="separator:ga4ccb520d1605428c703fb1e231984b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga548f8ae65fde704870019a244c4aa68d"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ga548f8ae65fde704870019a244c4aa68d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga548f8ae65fde704870019a244c4aa68d">blaze::clear</a> (const VectorAccessProxy&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:ga548f8ae65fde704870019a244c4aa68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the represented element.  <a href="#ga548f8ae65fde704870019a244c4aa68d">More...</a><br /></td></tr>
<tr class="separator:ga548f8ae65fde704870019a244c4aa68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb3ad1af3a538107952f5d3f03dab8d5"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gacb3ad1af3a538107952f5d3f03dab8d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gacb3ad1af3a538107952f5d3f03dab8d5">blaze::isDefault</a> (const VectorAccessProxy&lt; VT &gt; &amp;proxy)</td></tr>
<tr class="memdesc:gacb3ad1af3a538107952f5d3f03dab8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the represented element is in default state.  <a href="#gacb3ad1af3a538107952f5d3f03dab8d5">More...</a><br /></td></tr>
<tr class="separator:gacb3ad1af3a538107952f5d3f03dab8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfa2709535c36a4e01a28214c7a74bb3"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:gacfa2709535c36a4e01a28214c7a74bb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#gacfa2709535c36a4e01a28214c7a74bb3">blaze::swap</a> (const VectorAccessProxy&lt; VT &gt; &amp;a, const VectorAccessProxy&lt; VT &gt; &amp;b)</td></tr>
<tr class="memdesc:gacfa2709535c36a4e01a28214c7a74bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two access proxies.  <a href="#gacfa2709535c36a4e01a28214c7a74bb3">More...</a><br /></td></tr>
<tr class="separator:gacfa2709535c36a4e01a28214c7a74bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b699985ef207a6ac943a26690ebc96e"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename T &gt; </td></tr>
<tr class="memitem:ga2b699985ef207a6ac943a26690ebc96e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga2b699985ef207a6ac943a26690ebc96e">blaze::swap</a> (const VectorAccessProxy&lt; VT &gt; &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:ga2b699985ef207a6ac943a26690ebc96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="#ga2b699985ef207a6ac943a26690ebc96e">More...</a><br /></td></tr>
<tr class="separator:ga2b699985ef207a6ac943a26690ebc96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51937d821b95e70f8ddbf1b23536ff28"><td class="memTemplParams" colspan="2">template&lt;typename T , typename VT &gt; </td></tr>
<tr class="memitem:ga51937d821b95e70f8ddbf1b23536ff28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df1/group__math.html#ga51937d821b95e70f8ddbf1b23536ff28">blaze::swap</a> (T &amp;a, const VectorAccessProxy&lt; VT &gt; &amp;b)</td></tr>
<tr class="memdesc:ga51937d821b95e70f8ddbf1b23536ff28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of an access proxy with another element.  <a href="#ga51937d821b95e70f8ddbf1b23536ff28">More...</a><br /></td></tr>
<tr class="separator:ga51937d821b95e70f8ddbf1b23536ff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga33cd8a737acd2b68cf33d84baad75bf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseVectorProxy&lt; PT, VT &gt;::Iterator blaze::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ga473e41444b6324cdd14e5a675b829f4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseMatrixProxy&lt; PT, MT &gt;::Iterator blaze::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the given matrix is a row-major matrix the function returns an iterator to the first element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="ga8d0d84fb462bcda9e4ac1b46da8f4e3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseVectorProxy&lt; PT, VT &gt;::Iterator blaze::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ga34acd458b656ec2167762cc3fb1bdd1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseMatrixProxy&lt; PT, MT &gt;::Iterator blaze::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the given matrix is a row-major matrix the function returns an iterator to the first element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="ga9ad8f51a4e5551c83c078c2729c2bece"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::capacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="gabdce650ad06eb019f79bb6b7e92bf15d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::capacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="gad086b7d12b02acd9fadbba5c105350c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::capacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current capacity of the specified row/column of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current capacity of row/column <em>i</em>.</dd></dl>
<p>This function returns the current capacity of the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the capacity of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the capacity of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="ga16914bece2ebf39b5e72e42727593ffd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::capacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf8d7b618c624d4911ae7f3882a05dc14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::capacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c3df62b3c237c2a2b04fc28e7a20dcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::capacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current capacity of the specified row/column of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current capacity of row/column <em>i</em>.</dd></dl>
<p>This function returns the current capacity of the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the capacity of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the capacity of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="ga1552651c7e7b05385a91c477f198b92c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseVectorProxy&lt; PT, VT &gt;::ConstIterator blaze::cbegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="gab5e4b8a71e6e426f52371c0d5b9846fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseMatrixProxy&lt; PT, MT &gt;::ConstIterator blaze::cbegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the given matrix is a row-major matrix the function returns an iterator to the first element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="gaa64edd34b7ccc061871ebf7b372a0d1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseVectorProxy&lt; PT, VT &gt;::ConstIterator blaze::cbegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa97c7a3f2a26f8a8a918b3ef33ea1adc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseMatrixProxy&lt; PT, MT &gt;::ConstIterator blaze::cbegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the given matrix is a row-major matrix the function returns an iterator to the first element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="ga485df6bb7b74d08f29bcc446517f33bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseVectorProxy&lt; PT, VT &gt;::ConstIterator blaze::cend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb1b473d7716b9abe090c3db5c8df431"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseMatrixProxy&lt; PT, MT &gt;::ConstIterator blaze::cend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>In case the access proxy represents a matrix-like data structure that provides a <a class="el" href="../../d2/de9/namespaceblaze.html#a096461344e174dd70d10ef1166d59023" title="Returns an iterator just past the last element of row/column i. ">cend()</a> function, this function returns an iterator just past the last element of row/column <em>i</em> of the matrix. In case the given matrix is a row-major matrix the function returns an iterator just past the last element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="ga1731ef12d4ac4b1847d616935cd74cc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseVectorProxy&lt; PT, VT &gt;::ConstIterator blaze::cend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ga58b9786b8a311ab1bf97f247f566edd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseMatrixProxy&lt; PT, MT &gt;::ConstIterator blaze::cend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>In case the access proxy represents a matrix-like data structure that provides a <a class="el" href="../../d2/de9/namespaceblaze.html#a096461344e174dd70d10ef1166d59023" title="Returns an iterator just past the last element of row/column i. ">cend()</a> function, this function returns an iterator just past the last element of row/column <em>i</em> of the matrix. In case the given matrix is a row-major matrix the function returns an iterator just past the last element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="gae42eef9a424004a86df6fc9c4115c2bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clearing the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function clears the vector to its default initial state. </p>

</div>
</div>
<a class="anchor" id="ga1d821c7a793e0c694258e2917bb44edc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clearing the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function clears the matrix to its default initial state. </p>

</div>
</div>
<a class="anchor" id="ga727608d5ba71b44eb89fb8d00e567c5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clearing the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function clears the vector to its default initial state. </p>

</div>
</div>
<a class="anchor" id="ga548f8ae65fde704870019a244c4aa68d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clearing the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d9a939b2471f71e81d8eee8c22a5ae4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clearing the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function clears the element represented by the access proxy to its default initial state. In case the access proxy represents a vector- or matrix-like data structure that provides a <a class="el" href="../../d0/d90/group__diagonal__matrix.html#ga834f663e7bd7bad48600ec5b036269bb" title="Clearing the represented element. ">clear()</a> function, this function clears the vector/matrix to its default initial state. </p>

</div>
</div>
<a class="anchor" id="gaf8060179ae7d8ee97914ecb0fae7d9d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clearing the represented element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function clears the element represented by the access proxy to its default initial state. In case the access proxy represents a vector- or matrix-like data structure that provides a <a class="el" href="../../d0/d90/group__diagonal__matrix.html#ga834f663e7bd7bad48600ec5b036269bb" title="Clearing the represented element. ">clear()</a> function, this function clears the vector/matrix to its default initial state. </p>

</div>
</div>
<a class="anchor" id="ga98a52ebee9e73c73f6492af64841cdca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clearing the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function clears the matrix to its default initial state. </p>

</div>
</div>
<a class="anchor" id="gaf184ec513c031b63bb72c7161f7f9f5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::columns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current number of columns of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of columns of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa69887db471553a593455e9939bd20e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::columns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current number of columns of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of columns of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="gabd55880375d550adbae4dd61aebea75d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t blaze::digits </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of valid digits of an integral value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The integral value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of valid digits.</dd></dl>
<p>This function counts the number of valid digits in the given integral value.</p>
<div class="fragment"><div class="line"><a class="code" href="../../de/df1/group__math.html#gabd55880375d550adbae4dd61aebea75d">digits</a>( 100   );  <span class="comment">// Returns 3</span></div>
<div class="line"><a class="code" href="../../de/df1/group__math.html#gabd55880375d550adbae4dd61aebea75d">digits</a>( 12345 );  <span class="comment">// Returns 5</span></div>
<div class="line"><a class="code" href="../../de/df1/group__math.html#gabd55880375d550adbae4dd61aebea75d">digits</a>( 0     );  <span class="comment">// Returns 0</span></div>
</div><!-- fragment --><p>The digits function only works for integral built-in data types. The attempt to use any other type will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gad47f01490e02fe97e3e71003d70006b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseVectorProxy&lt; PT, VT &gt;::Iterator blaze::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="gabd12cbf050e7ee64aff69936d37d6b97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> DenseMatrixProxy&lt; PT, MT &gt;::Iterator blaze::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>In case the access proxy represents a matrix-like data structure that provides an <a class="el" href="../../d2/de9/namespaceblaze.html#a7fdc81bb7ed1970229a4f29afebfd7a6" title="Returns an iterator just past the last element of row/column i. ">end()</a> function, this function returns an iterator just past the last element of row/column <em>i</em> of the matrix. In case the given matrix is a row-major matrix the function returns an iterator just past the last element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="ga7a2eb393d47a7d6681303ec6729fe259"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseVectorProxy&lt; PT, VT &gt;::Iterator blaze::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="gaff459171ee4708a8fc325de33d9345aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> SparseMatrixProxy&lt; PT, MT &gt;::Iterator blaze::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em> of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>In case the access proxy represents a matrix-like data structure that provides an <a class="el" href="../../d2/de9/namespaceblaze.html#a7fdc81bb7ed1970229a4f29afebfd7a6" title="Returns an iterator just past the last element of row/column i. ">end()</a> function, this function returns an iterator just past the last element of row/column <em>i</em> of the matrix. In case the given matrix is a row-major matrix the function returns an iterator just past the last element of row <em>i</em>, in case it is a column-major matrix the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="gacb3ad1af3a538107952f5d3f03dab8d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isDefault </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is in default state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is in default state, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy is in default state. In case it is in default state, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="ga045077f88b05d5f5fa13c4ef1eaf0161"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isDefault </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the represented element is in default state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is in default state, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy is in default state. In case it is in default state, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="gad427497af2146e20165927ebd1a0109a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> bool blaze::isDefault </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the represented element is in default state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the represented element is in default state, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the element represented by the access proxy is in default state. In case it is in default state, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="ga5ab0aea405bc3b739ffc3dd3781a3129"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> bool blaze::lessThan </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic less-than comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the first value is smaller than the second, <em>false</em> if not.</dd></dl>
<p>Generic less-than comparison between to numeric values. Depending on the types of the two arguments, a special comparison for floating point values is selected that takes the limited machine accuracy into account. </p>

</div>
</div>
<a class="anchor" id="gac5419cbf6def5f70752d58211d80586c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const MathTrait&lt; T1, T2 &gt;::HighType blaze::max </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum function for two arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum of the two values.</dd></dl>
<p>This function returns the maximum of the two given data values. The return type of the function is determined by the data types of the given arguments (for further detail see the <a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html" title="Base template for the MathTrait class. ">MathTrait</a> class description). </p>

</div>
</div>
<a class="anchor" id="gaeff1eab92ba879fcb74710a0b5ad08f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const MathTrait&lt; typename MathTrait&lt; T1, T2 &gt;::HighType, T3 &gt;::HighType blaze::max </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum function for three arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
    <tr><td class="paramname">c</td><td>Third value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum of the three values.</dd></dl>
<p>This function returns the maximum of the three given data values. The return type of the function is determined by the data types of the given arguments (for further detail see the <a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html" title="Base template for the MathTrait class. ">MathTrait</a> class description). </p>

</div>
</div>
<a class="anchor" id="ga27423d924911a9bbadee66fbbcbc9b56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const MathTrait&lt; T1, T2 &gt;::HighType blaze::min </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum function for two arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum of the two values.</dd></dl>
<p>This function returns the minimum of the two given data values. The return type of the function is determined by the data types of the given arguments (for further detail see the <a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html" title="Base template for the MathTrait class. ">MathTrait</a> class description). </p>

</div>
</div>
<a class="anchor" id="ga2afaa479a7f3034d0be679f2e3cef604"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const MathTrait&lt; typename MathTrait&lt; T1, T2 &gt;::HighType, T3 &gt;::HighType blaze::min </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum function for three arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First value. </td></tr>
    <tr><td class="paramname">b</td><td>Second value. </td></tr>
    <tr><td class="paramname">c</td><td>Third value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum of the three values.</dd></dl>
<p>This function returns the minimum of the three given data values. The return type of the function is determined by the data types of the given arguments (for further detail see the <a class="el" href="../../d3/d6a/structblaze_1_1MathTrait.html" title="Base template for the MathTrait class. ">MathTrait</a> class description). </p>

</div>
</div>
<a class="anchor" id="gacb886f8afac581ea219e7fd9dfdf6c74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::nonZeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the vector.</dd></dl>
<p>Note that the number of non-zero elements is always less than or equal to the current size of the vector. </p>

</div>
</div>
<a class="anchor" id="gaf98d55b3997a5e0666e9467aac2f383e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::nonZeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="gade25555a94e648076982a8c68fb38b70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::nonZeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the specified row/column of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements of row/column <em>i</em>.</dd></dl>
<p>This function returns the current number of non-zero elements in the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the number of non-zero elements in row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the number of non-zero elements in column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="gae3c458777c59275735f874c6bb6b3dcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::nonZeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the vector.</dd></dl>
<p>Note that the number of non-zero elements is always less than or equal to the current size of the vector. </p>

</div>
</div>
<a class="anchor" id="gad8d4a1ad716a90d183a1f310887f678f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::nonZeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="gabe8aa45ed742cea841472f9f575f9c71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::nonZeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the specified row/column of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements of row/column <em>i</em>.</dd></dl>
<p>This function returns the current number of non-zero elements in the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the number of non-zero elements in row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the number of non-zero elements in column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="gafc02f01b7d880ce7e0f5413746872b3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is unequal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga5f6ac5831d994de1617100e79b409f78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is unequal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga46d93714b380cec87ee26da168f4a0e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is unequal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga22db42744b1d782e174dbcf6f2bf37e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is unequal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gad2ce8d04b569787a93da217d1852f963"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename I2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>false</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga313c450e022ce76f66888b2b6be23e70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side built-in data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is not negative infinity, <em>false</em> if it is.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gabc9e7c387680b76ecf9056a3354c4f82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side built-in data value. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is not negative infinity, <em>false</em> if it is.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga37382d7c34d33f06cad082f7cfa85036"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if both referenced values are not equal, <em>false</em> if they are. </dd></dl>

</div>
</div>
<a class="anchor" id="ga75d9aaa612d5861fbd5a1166dd3b3c96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the referenced value and the other object are not equal, <em>false</em> if they are. </dd></dl>

</div>
</div>
<a class="anchor" id="ga175ba67536b1bb9e0c42c43e28772c78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inquality comparison between an object of different type and a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the other object and the referenced value are not equal, <em>false</em> if they are. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ef548bb2e362777a3b5636b28ec1cf3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if both referenced values are not equal, <em>false</em> if they are. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaa78690eb7486a2a90fe3543009ecac9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the referenced value and the other object are not equal, <em>false</em> if they are. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea71061dabd437d913ce7c72caf45d41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inquality comparison between an object of different type and a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the other object and the referenced value are not equal, <em>false</em> if they are. </dd></dl>

</div>
</div>
<a class="anchor" id="gad67a505ca548cbc1024329aebc3483f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if both referenced values are not equal, <em>false</em> if they are. </dd></dl>

</div>
</div>
<a class="anchor" id="ga777d32f7eda6e19099accb98afe83dff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the referenced value and the other object are not equal, <em>false</em> if they are. </dd></dl>

</div>
</div>
<a class="anchor" id="gae51b7c17eee2f3621d89eebafb9bc56a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inquality comparison between an object of different type and a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the other object and the referenced value are not equal, <em>false</em> if they are. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a50f57ff770309ebb61142b2a425d27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is unequal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gac81389b775ddd91717cc708fd4815b6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is unequal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gae116a92a519bc1a7faa511e50ebd3b90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is unequal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga927507337b7b6cdbe244112194218275"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is unequal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gaca25a01de529bfdb940d9524eb8cd007"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between two <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>false</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6781afeed67b5b4945558b94aaa86073"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga36ef11516f633356b7652726f2543d87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The left-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
    <tr><td class="paramname">lhs</td><td>The right-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b8c22e5fcef35073910201a7e0ae05a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side built-in data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is not infinity, <em>false</em> if it is.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga1d28fd67d95a6015c5b5b6fd62762e22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side built-in data value. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is not infinity, <em>false</em> if it is.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gab0f6e6c059c34b31b67dfe6e6420398d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gac1d14e4e7b3ef42af647b7d92db0f6cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga9f80a558803f060623e0ac21763e989a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga9b86a750765429e61761ff7baee2b9d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gac5258365f88dab53563dfa0d49389855"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between two <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6983c7c1017ad5332e378ad7160769bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga151487afa014e0d54a14bdc08d885189"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between an object of different type and a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is smaller, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1f949c39833f694a0acc922c3af440c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between two <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ff1a96ef28bebf0d56cce417094026b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga959aedd0006bca949f5a67e493fcc263"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between an object of different type and a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is smaller, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf04da1771663ba18774439eedbafd55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between two <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5196586daa116ce37f80f917476e10a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gad664938020f72ac2a69d18f0df5762d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between an object of different type and a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is smaller, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gaecb0cc5d9dcf5ed3c3a244b072b838ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floatin point value is greater than the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gad73847d144e9f3c172f5630175c05e28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gafdbb1c3cbb179e0e86ef79b4ffa11dc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga25b5ff3c3bb106998735574abd5a081b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gaedcb4af011fc205eb97c713f504f302a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; blaze::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global output operator for the <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> class template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Reference to the output stream. </td></tr>
    <tr><td class="paramname">proxy</td><td>Reference to a constant proxy object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the output stream. </dd></dl>

</div>
</div>
<a class="anchor" id="ga824329c3c439b14d96a3b0a3f6221cef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; blaze::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global output operator for the <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> class template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Reference to the output stream. </td></tr>
    <tr><td class="paramname">proxy</td><td>Reference to a constant proxy object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the output stream. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4b6a6d6381391ab005834b05f3e36ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; blaze::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global output operator for the <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> class template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Reference to the output stream. </td></tr>
    <tr><td class="paramname">proxy</td><td>Reference to a constant proxy object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the output stream. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d3a2e43e521b703f01e422e2f36928a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between two <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4749e3903e7f27b4007c5dda73517093"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0afaffd71fc9ca3128d04959cd93e583"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between an object of different type and a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is smaller or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7406274ca325fefa3df2ab43e6ee1075"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between two <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga26551d0713ea4a4b8c6cfd4a7c8fa2d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e6439ac29b32bb05ef2eb8d14913b4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between an object of different type and a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is smaller or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gae7d2ce5289464e8b270eb72a7a0dbff9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between two <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2408003649832cde727a2f52a45e650b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is smaller or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga95ca142d4a5d140a85a4c7362a0eedab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between an object of different type and a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is smaller or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga17abc6a6b11aecfc787e01c600e0546b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than or equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga078fff484ed6fc2a78db73d2e3f19ff1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than or equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga7fa9b68879cea6b50867c5018151bee4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than or equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga00734ffb630fb7fbb9864ae0845629e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than or equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga7b8b533b8e6a1bbcc85cbd8de67a07bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is equal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga2eebfaf6382f255164a9cefa6ab8eb27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is equal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga3cfe831bb614ba1d4a67eaea42c82998"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is equal to the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga3cf42a6c23efe1880899f5b89b265286"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is equal to the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga62957325299b3c3cdfe774ada80f4312"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename I2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa89e010144eab077e9d596e74bab15b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and a built-in data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side built-in data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is negative infinity, <em>false</em> if not.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga52ce1ea57d9c7fd4be3ab4d75310032c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a built-in data type and an <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side built-in data value. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is negative infinity, <em>false</em> if not.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gad48448011cb8dd68c6342c8677cc14b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if both referenced values are equal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a class="anchor" id="gabaa1f0ce4980d2344ddaef5837171c16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the referenced value and the other object are equal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b290a1fa75dff33cf122255d18aae41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an object of different type and a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the other object and the referenced value are equal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a class="anchor" id="gadbacbd1246746a45c7a1dcab279c2d8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if both referenced values are equal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a6e11c1679c47a99a8916ab6f36a430"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the referenced value and the other object are equal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga38c636cc9c1a670b065d42a1a4515f0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an object of different type and a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the other object and the referenced value are equal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a class="anchor" id="gab3d5153c4fa9db305f78439a7893ed60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if both referenced values are equal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga667fb1bc5b1eda64ec69ee1bb64b967a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the referenced value and the other object are equal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga93b1056eb3e7b206a178b0ac0a03c794"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an object of different type and a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the other object and the referenced value are equal, <em>false</em> if they are not. </dd></dl>

</div>
</div>
<a class="anchor" id="gac3ec406b1801fa25c3f9ffa9144cee0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga42be9e710c330d928604c4fe730661d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga8e7b4cf5af885cb431eb37281691fe4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga5362cd08bf302cd8f8272be634a5b435"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga655562d8f01de67e6b3cf6aba3a7c39f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gafbecdbaa49a24b4f6f8f73a682c7e87a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>false</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gac26ca9f27a8e99ff712891dce3cf7d7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html">NegativeInfinity</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The left-hand side <a class="el" href="../../db/da3/classblaze_1_1NegativeInfinity.html" title="Negative infinity for built-in data types.The NegativeInfinity class is a wrapper class around the fu...">NegativeInfinity</a> object. </td></tr>
    <tr><td class="paramname">lhs</td><td>The right-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>false</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga051a2e303820cb2fde125c7516f75ce9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object and a built-in data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side built-in data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is infinity, <em>false</em> if not.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gaef53b8be129fa00b953bb0f160413b80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/dff/classblaze_1_1Infinity.html">Infinity</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between a built-in data type and an <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side built-in data value. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../da/dff/classblaze_1_1Infinity.html" title="Positive infinity for built-in data types.The Infinity class is a wrapper class around the functional...">Infinity</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the built-in data value is infinity, <em>false</em> if not.</dd></dl>
<p>This operator works only for built-in data types. The attempt to compare user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga22864fea6db8d1ca553b327194d0b9aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga0c3a3aa80c4823700946bfbcbf0e15a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gaedd63616a647a5c54dd3fc4d8061010b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html">NegativeEpsilon</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a floating point value and a <a class="el" href="../../d9/d70/classblaze_1_1NegativeEpsilon.html" title="Negative epsilon value for floating point data types.The NegativeEpsilon class is a wrapper class aro...">NegativeEpsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than the negative epsilon, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gad1147bca7c8d61c5705dd67a7bb37b72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html">NegativeAccuracy</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a floating point value and a <a class="el" href="../../da/d32/classblaze_1_1NegativeAccuracy.html" title="Negative computation accuracy for floating point data types.The NegativeAccuracy class is a wrapper c...">NegativeAccuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than the negative accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga0d527ac477b7866bed57673a86a41377"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between two <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga662f69f6fe731fa92d68e2d0705d21cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga352a7a263d5af50f5ed3c2adbbb26650"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between an object of different type and a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is greater, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga77093a57f829dce5eee6b4b3d86d530c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between two <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga044239e64e8e955acea91ae1c14c994a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga83359a82f95f7facbc0b1c445c743326"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between an object of different type and a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is greater, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7248502d6a1a34c23aaa3a2d1310347"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between two <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga407f1aeebb6cf4cc4fa5a3778df0cc89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga76f73becdb5e4d03e2942967686c93b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between an object of different type and a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is greater, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga19f217c7d16c2691b15c61bd5aef9cee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga84f7eea431aca4b1b3741d765cfe300e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gaf0cbca3f85e459a6b20902cb55daad67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gaab2ec2c16b016e3ba86a076cee12001d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga0a305e6fad74d2989d9423f7ddc9c4b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT1 , typename VT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between two <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gade31b841a1677982148bd880b5088ea6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6cc29d5df06b66ef4a5ffc1e63e830ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between an object of different type and a <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html" title="Access proxy for sparse, N-dimensional vectors.The VectorAccessProxy provides safe access to the elem...">VectorAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is greater or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gae49b450bc781b5d48e924ba64e1566d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between two <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga162b096fdaf47541baa27d8328eac010"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7135ca170b91aa06582670d9cb991a44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between an object of different type and a <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html" title="Access proxy for sparse,  matrices.The MatrixAccessProxy provides safe access to the elements of a no...">MatrixAccessProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is greater or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gad2918d6490730a00d5ed50c924d8cb1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT1 , typename MT2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between two <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga07bf389a3d421a598a310e8177677d11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object and an object of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side object of other type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side referenced value is greater or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f7309bd8a23e37e2203999bd65ced4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between an object of different type and a <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side object of other type. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html" title="Access proxy for symmetric, square matrices with non-numeric element types.The NonNumericProxy provid...">NonNumericProxy</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the left-hand side other object is greater or equal, <em>false</em> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa46c931e3c38d084981c9ebe8611a3b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is smaller than or equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga19a9ea78dadddb5de9278854251cc8f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-or-equal-than comparison between an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object and a floating point value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is smaller than or equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="gadd532f78625cbf286b84fa5d4d8b32ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html">Accuracy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../d6/d75/classblaze_1_1Accuracy.html" title="Computation accuracy for floating point data types.The Accuracy class is a wrapper class around the f...">Accuracy</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value is greater than or equal to the accuracy, <em>false</em> if not.</dd></dl>
<p>This operator exclusively works for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga858866c9c17929b12f6970c90128c932"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html">Epsilon</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-or-equal-than comparison between a floating point value and an <a class="el" href="../../dd/d28/classblaze_1_1Epsilon.html" title="Numerical epsilon value for floating point data types.The Epsilon class is a wrapper class around the...">Epsilon</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the floating point value is greater than or equal to epsilon, <em>false</em> if not.</dd></dl>
<p>This operator works only for floating point data types. The attempt to compare any integral data type or user-defined class types will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga5277ea1f337ba3a87d2dad48b609cec7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resetting the represented vector to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets all elements of the vector to the default initial values. </p>

</div>
</div>
<a class="anchor" id="ga6b361008599fbe7c5ad3262ed1cf8bf9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resetting the represented element to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets all elements of the matrix to the default initial values. </p>

</div>
</div>
<a class="anchor" id="ga218b5d7e25e582cf759a0ffb94d8f88b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the specified row/column of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the row/column to be resetted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets all elements in the specified row/column of the given matrix to their default value. In case the given matrix is a <em>rowMajor</em> matrix the function resets the values in row <em>i</em>, if it is a <em>columnMajor</em> matrix the function resets the values in column <em>i</em>. Note that the capacity of the row/column remains unchanged. </p>

</div>
</div>
<a class="anchor" id="gad18d9138d144ff01dcf136f703443a80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resetting the represented element to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets all elements of the vector to the default initial values. </p>

</div>
</div>
<a class="anchor" id="ga4ccb520d1605428c703fb1e231984b8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resetting the represented element to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="gaa329d4ff44a8780cb8f29343ffc32790"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resetting the represented element to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets the element represented by the access proxy to its default initial value. In case the access proxy represents a vector- or matrix-like data structure that provides a <a class="el" href="../../d0/d90/group__diagonal__matrix.html#gab1218387fdd76e3eead49086d7fdc5e7" title="Resetting the represented element to the default initial values. ">reset()</a> function, this function resets all elements of the vector/matrix to the default initial values. </p>

</div>
</div>
<a class="anchor" id="gaa0d8432e93c661038aabd4e1bda0af9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/dcd/classblaze_1_1NonNumericProxy.html">NonNumericProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resetting the represented element to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets the element represented by the access proxy to its default initial value. In case the access proxy represents a vector- or matrix-like data structure that provides a <a class="el" href="../../d0/d90/group__diagonal__matrix.html#gab1218387fdd76e3eead49086d7fdc5e7" title="Resetting the represented element to the default initial values. ">reset()</a> function, this function resets all elements of the vector/matrix to the default initial values. </p>

</div>
</div>
<a class="anchor" id="ga7df60d6b50394cad1e546a4cd8969af6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resetting the represented element to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets all elements of the matrix to the default initial values. </p>

</div>
</div>
<a class="anchor" id="ga5a8a33a97692e307634bf7db10cd6276"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void blaze::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the specified row/column of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the row/column to be resetted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets all elements in the specified row/column of the given matrix to their default value. In case the given matrix is a <em>rowMajor</em> matrix the function resets the values in row <em>i</em>, if it is a <em>columnMajor</em> matrix the function resets the values in column <em>i</em>. Note that the capacity of the row/column remains unchanged. </p>

</div>
</div>
<a class="anchor" id="ga2357436c0300543a47135f437ac0afbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> T blaze::round </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rounds the given input value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value to be rounded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rounded value.</dd></dl>
<p>This function rounds the given input value. In case the first digit after the comma is smaller than five the value is rounded down. Otherwise it is rounded up. Note that this function only works for integral and floating point types. The attempt to use the function for any other type will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga9b7cec0953f0e0be2c5220bd61e6e2e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::rows </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1d/classblaze_1_1DenseMatrixProxy.html">DenseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current number of rows of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of rows of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="ga51e08caafa4583f32333b5d17f1c4ef5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::rows </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da0/classblaze_1_1SparseMatrixProxy.html">SparseMatrixProxy</a>&lt; PT, MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current number of rows of the represented matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of rows of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="gabbfbee6a5a5043d168204dd82e1190c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int blaze::sign </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The given value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the value is greater than zero, 0 if it is zero, and -1 if it is smaller than zero.</dd></dl>
<p>The sign function only works for built-in data types. The attempt to use any user-defined class type will result in a compile time error. </p>

</div>
</div>
<a class="anchor" id="ga815b73881a05f1de2c4ed92521758c22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d4a/classblaze_1_1DenseVectorProxy.html">DenseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current size/dimension of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="gac0d73069d106d356f221e1dca36f86f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PT , typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> size_t blaze::size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/df4/classblaze_1_1SparseVectorProxy.html">SparseVectorProxy</a>&lt; PT, VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current size/dimension of the represented vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The given access proxy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="gacfa2709535c36a4e01a28214c7a74bb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two access proxies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first access proxy to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The second access proxy to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">no-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2b699985ef207a6ac943a26690ebc96e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of an access proxy with another element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The access proxy to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The other element to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">no-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga51937d821b95e70f8ddbf1b23536ff28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename VT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/de3/classblaze_1_1VectorAccessProxy.html">VectorAccessProxy</a>&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of an access proxy with another element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The other element to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The access proxy to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">no-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga84b0b9696de93cc4950814019c124aa6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two access proxies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first access proxy to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The second access proxy to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">no-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga04034dd426e9c78cfa1b6d1bdffc0e10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of an access proxy with another element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The access proxy to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The other element to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">no-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa1552a5426e51180216d9030bedfff20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/dd3/classblaze_1_1MatrixAccessProxy.html">MatrixAccessProxy</a>&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of an access proxy with another element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The other element to be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>The access proxy to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">no-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:55:21 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
