<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>blaze::DynamicMatrix&lt; Type, SO &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="../../d4/d48/classblaze_1_1DynamicMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::DynamicMatrix&lt; Type, SO &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../dd/d7a/group__matrix.html">Matrices</a> &raquo; <a class="el" href="../../db/df0/group__dense__matrix.html">Dense Matrices</a> &raquo; <a class="el" href="../../dd/dfc/group__dynamic__matrix.html">DynamicMatrix</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Efficient implementation of a dynamic <img class="formulaInl" alt="$ M \times N $" src="../../form_48.png"/> matrix.The <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a> class template is the representation of an arbitrary sized matrix with <img class="formulaInl" alt="$ M \times N $" src="../../form_48.png"/> dynamically allocated elements of arbitrary type. The type of the elements and the storage order of the matrix can be specified via the two template parameters:  
 <a href="../../de/d1e/classblaze_1_1DynamicMatrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../db/d2d/dense_2DynamicMatrix_8h_source.html">DynamicMatrix.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">blaze::DenseMatrix&lt; DynamicMatrix&lt; Type, SO &gt;, SO &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de6/structblaze_1_1DynamicMatrix_1_1Rebind.html">Rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/de6/structblaze_1_1DynamicMatrix_1_1Rebind.html" title="Rebind mechanism to obtain a DynamicMatrix with different data/element type. ">Rebind</a> mechanism to obtain a <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a> with different data/element type.  <a href="../../de/de6/structblaze_1_1DynamicMatrix_1_1Rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ga91f203cc310a6b0d82e916e47f6920d2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>vectorizable</b> = IsVectorizable&lt;Type&gt;::value
 }</td></tr>
<tr class="memdesc:ga91f203cc310a6b0d82e916e47f6920d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for intrinsic optimization.  <a href="../../dd/dfc/group__dynamic__matrix.html#ga91f203cc310a6b0d82e916e47f6920d2">More...</a><br /></td></tr>
<tr class="separator:ga91f203cc310a6b0d82e916e47f6920d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac82b2768477ecee6fa231ee2b4084842"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>smpAssignable</b> = !IsSMPAssignable&lt;Type&gt;::value
 }</td></tr>
<tr class="memdesc:gac82b2768477ecee6fa231ee2b4084842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation flag for SMP assignments.  <a href="../../dd/dfc/group__dynamic__matrix.html#gac82b2768477ecee6fa231ee2b4084842">More...</a><br /></td></tr>
<tr class="separator:gac82b2768477ecee6fa231ee2b4084842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f0f87e2059a001131d8dacffa45eea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2f0f87e2059a001131d8dacffa45eea"></a>
typedef <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ad2f0f87e2059a001131d8dacffa45eea">This</a></td></tr>
<tr class="memdesc:ad2f0f87e2059a001131d8dacffa45eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a> instance. <br /></td></tr>
<tr class="separator:ad2f0f87e2059a001131d8dacffa45eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5899a67fd04c5eb26a4ffc9a292948"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c5899a67fd04c5eb26a4ffc9a292948"></a>
typedef <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ad2f0f87e2059a001131d8dacffa45eea">This</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a3c5899a67fd04c5eb26a4ffc9a292948">ResultType</a></td></tr>
<tr class="memdesc:a3c5899a67fd04c5eb26a4ffc9a292948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for expression template evaluations. <br /></td></tr>
<tr class="separator:a3c5899a67fd04c5eb26a4ffc9a292948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71627939d692374d47af6e967a5ffe97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71627939d692374d47af6e967a5ffe97"></a>
typedef <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type,!SO &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a71627939d692374d47af6e967a5ffe97">OppositeType</a></td></tr>
<tr class="memdesc:a71627939d692374d47af6e967a5ffe97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type with opposite storage order for expression template evaluations. <br /></td></tr>
<tr class="separator:a71627939d692374d47af6e967a5ffe97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c8c912435dc3af90a55fa29e18ea01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1c8c912435dc3af90a55fa29e18ea01"></a>
typedef <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type,!SO &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ae1c8c912435dc3af90a55fa29e18ea01">TransposeType</a></td></tr>
<tr class="memdesc:ae1c8c912435dc3af90a55fa29e18ea01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose type for expression template evaluations. <br /></td></tr>
<tr class="separator:ae1c8c912435dc3af90a55fa29e18ea01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95555bcb59b7d79389536876eb76ff67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95555bcb59b7d79389536876eb76ff67"></a>
typedef Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a95555bcb59b7d79389536876eb76ff67">ElementType</a></td></tr>
<tr class="memdesc:a95555bcb59b7d79389536876eb76ff67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the matrix elements. <br /></td></tr>
<tr class="separator:a95555bcb59b7d79389536876eb76ff67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d673389dcc90152922ac6d3424e1889"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d673389dcc90152922ac6d3424e1889"></a>
typedef IT::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a9d673389dcc90152922ac6d3424e1889">IntrinsicType</a></td></tr>
<tr class="memdesc:a9d673389dcc90152922ac6d3424e1889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic type of the matrix elements. <br /></td></tr>
<tr class="separator:a9d673389dcc90152922ac6d3424e1889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad78c979ce36fd3bd51972b7fa44a0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ad78c979ce36fd3bd51972b7fa44a0b"></a>
typedef const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a0ad78c979ce36fd3bd51972b7fa44a0b">ReturnType</a></td></tr>
<tr class="memdesc:a0ad78c979ce36fd3bd51972b7fa44a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for expression template evaluations. <br /></td></tr>
<tr class="separator:a0ad78c979ce36fd3bd51972b7fa44a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a2d81e4a28f5fdee9185651d30dab2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90a2d81e4a28f5fdee9185651d30dab2"></a>
typedef const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ad2f0f87e2059a001131d8dacffa45eea">This</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a90a2d81e4a28f5fdee9185651d30dab2">CompositeType</a></td></tr>
<tr class="memdesc:a90a2d81e4a28f5fdee9185651d30dab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type for composite expression templates. <br /></td></tr>
<tr class="separator:a90a2d81e4a28f5fdee9185651d30dab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7716897295045a77922b9016597dd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa7716897295045a77922b9016597dd3"></a>
typedef Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#afa7716897295045a77922b9016597dd3">Reference</a></td></tr>
<tr class="memdesc:afa7716897295045a77922b9016597dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a non-constant matrix value. <br /></td></tr>
<tr class="separator:afa7716897295045a77922b9016597dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600d9acc1b695e6e8ee07a1137cfcd5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a600d9acc1b695e6e8ee07a1137cfcd5c"></a>
typedef const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a600d9acc1b695e6e8ee07a1137cfcd5c">ConstReference</a></td></tr>
<tr class="memdesc:a600d9acc1b695e6e8ee07a1137cfcd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to a constant matrix value. <br /></td></tr>
<tr class="separator:a600d9acc1b695e6e8ee07a1137cfcd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37108ab139573e0149b63c09190997e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af37108ab139573e0149b63c09190997e"></a>
typedef Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#af37108ab139573e0149b63c09190997e">Pointer</a></td></tr>
<tr class="memdesc:af37108ab139573e0149b63c09190997e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a non-constant matrix value. <br /></td></tr>
<tr class="separator:af37108ab139573e0149b63c09190997e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c594626a5952d7ddad9e0ccb64e441"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28c594626a5952d7ddad9e0ccb64e441"></a>
typedef const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a28c594626a5952d7ddad9e0ccb64e441">ConstPointer</a></td></tr>
<tr class="memdesc:a28c594626a5952d7ddad9e0ccb64e441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a constant matrix value. <br /></td></tr>
<tr class="separator:a28c594626a5952d7ddad9e0ccb64e441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143e7e720de03484547f8d5e81197ca9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a143e7e720de03484547f8d5e81197ca9"></a>
typedef <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a143e7e720de03484547f8d5e81197ca9">Iterator</a></td></tr>
<tr class="memdesc:a143e7e720de03484547f8d5e81197ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over non-constant elements. <br /></td></tr>
<tr class="separator:a143e7e720de03484547f8d5e81197ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014ffc8116459b6abae9e0255f9ca6b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a014ffc8116459b6abae9e0255f9ca6b3"></a>
typedef <a class="el" href="../../dc/de8/classblaze_1_1DenseIterator.html">DenseIterator</a>&lt; const Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a014ffc8116459b6abae9e0255f9ca6b3">ConstIterator</a></td></tr>
<tr class="memdesc:a014ffc8116459b6abae9e0255f9ca6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over constant elements. <br /></td></tr>
<tr class="separator:a014ffc8116459b6abae9e0255f9ca6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8433a860ba90d8f77df196183ee2891d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8433a860ba90d8f77df196183ee2891d"></a>
typedef MT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a></td></tr>
<tr class="memdesc:a8433a860ba90d8f77df196183ee2891d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the matrix. <br /></td></tr>
<tr class="separator:a8433a860ba90d8f77df196183ee2891d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abacb16e0fa742f3de43f7056d1f612a5"><td class="memTemplParams" colspan="2">template&lt;typename Other , size_t M, size_t N&gt; </td></tr>
<tr class="memitem:abacb16e0fa742f3de43f7056d1f612a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#abacb16e0fa742f3de43f7056d1f612a5">operator=</a> (const Other(&amp;array)[M][N])</td></tr>
<tr class="memdesc:abacb16e0fa742f3de43f7056d1f612a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array assignment to all matrix elements.  <a href="#abacb16e0fa742f3de43f7056d1f612a5">More...</a><br /></td></tr>
<tr class="separator:abacb16e0fa742f3de43f7056d1f612a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1826c4a9dab38deedb7961090b38e375"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a1826c4a9dab38deedb7961090b38e375"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a1826c4a9dab38deedb7961090b38e375">operator=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1826c4a9dab38deedb7961090b38e375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for different matrices.  <a href="#a1826c4a9dab38deedb7961090b38e375">More...</a><br /></td></tr>
<tr class="separator:a1826c4a9dab38deedb7961090b38e375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513bcb5f9a40b2fb3d826555bb8f9b86"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a513bcb5f9a40b2fb3d826555bb8f9b86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a513bcb5f9a40b2fb3d826555bb8f9b86">operator+=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a513bcb5f9a40b2fb3d826555bb8f9b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator for the addition of a matrix ( <img class="formulaInl" alt="$ A+=B $" src="../../form_55.png"/>).  <a href="#a513bcb5f9a40b2fb3d826555bb8f9b86">More...</a><br /></td></tr>
<tr class="separator:a513bcb5f9a40b2fb3d826555bb8f9b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f94a45a7a30e916933219bef48e47a"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a60f94a45a7a30e916933219bef48e47a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a60f94a45a7a30e916933219bef48e47a">operator-=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a60f94a45a7a30e916933219bef48e47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator for the subtraction of a matrix ( <img class="formulaInl" alt="$ A-=B $" src="../../form_56.png"/>).  <a href="#a60f94a45a7a30e916933219bef48e47a">More...</a><br /></td></tr>
<tr class="separator:a60f94a45a7a30e916933219bef48e47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2004179d794e1113a7309ca806f5d36c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a2004179d794e1113a7309ca806f5d36c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a2004179d794e1113a7309ca806f5d36c">operator*=</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2004179d794e1113a7309ca806f5d36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication of a matrix ( <img class="formulaInl" alt="$ A*=B $" src="../../form_57.png"/>).  <a href="#a2004179d794e1113a7309ca806f5d36c">More...</a><br /></td></tr>
<tr class="separator:a2004179d794e1113a7309ca806f5d36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53978c88acaed9887e07b8bffe1ba559"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a53978c88acaed9887e07b8bffe1ba559"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a53978c88acaed9887e07b8bffe1ba559">operator*=</a> (Other rhs)</td></tr>
<tr class="memdesc:a53978c88acaed9887e07b8bffe1ba559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator for the multiplication between a matrix and a scalar value ( <img class="formulaInl" alt="$ A*=s $" src="../../form_58.png"/>).  <a href="#a53978c88acaed9887e07b8bffe1ba559">More...</a><br /></td></tr>
<tr class="separator:a53978c88acaed9887e07b8bffe1ba559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6feeb5648dd7221670e5bd504ac11ca"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:ae6feeb5648dd7221670e5bd504ac11ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ae6feeb5648dd7221670e5bd504ac11ca">operator/=</a> (Other rhs)</td></tr>
<tr class="memdesc:ae6feeb5648dd7221670e5bd504ac11ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator for the division of a matrix by a scalar value ( <img class="formulaInl" alt="$ A/=s $" src="../../form_59.png"/>).  <a href="#ae6feeb5648dd7221670e5bd504ac11ca">More...</a><br /></td></tr>
<tr class="separator:ae6feeb5648dd7221670e5bd504ac11ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4e85d1c8320a8a2257cf42d7aa8943"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a6b4e85d1c8320a8a2257cf42d7aa8943"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a6b4e85d1c8320a8a2257cf42d7aa8943">scale</a> (const Other &amp;scalar)</td></tr>
<tr class="memdesc:a6b4e85d1c8320a8a2257cf42d7aa8943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling of the matrix by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_63.png"/>).  <a href="#a6b4e85d1c8320a8a2257cf42d7aa8943">More...</a><br /></td></tr>
<tr class="separator:a6b4e85d1c8320a8a2257cf42d7aa8943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d13ed1867cd9d7cf293a6fdc5605f7"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a36d13ed1867cd9d7cf293a6fdc5605f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a36d13ed1867cd9d7cf293a6fdc5605f7">assign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a36d13ed1867cd9d7cf293a6fdc5605f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a row-major dense matrix.  <a href="#a36d13ed1867cd9d7cf293a6fdc5605f7">More...</a><br /></td></tr>
<tr class="separator:a36d13ed1867cd9d7cf293a6fdc5605f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791975b46aefd16fc300ff8302e7476d"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a791975b46aefd16fc300ff8302e7476d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::BLAZE_TEMPLATE VectorizedAssign&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a791975b46aefd16fc300ff8302e7476d">assign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a791975b46aefd16fc300ff8302e7476d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the assignment of a row-major dense matrix.  <a href="#a791975b46aefd16fc300ff8302e7476d">More...</a><br /></td></tr>
<tr class="separator:a791975b46aefd16fc300ff8302e7476d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a463a6ee3671a6aecd49fa340ad9ce"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a78a463a6ee3671a6aecd49fa340ad9ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a78a463a6ee3671a6aecd49fa340ad9ce">addAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a78a463a6ee3671a6aecd49fa340ad9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a row-major dense matrix.  <a href="#a78a463a6ee3671a6aecd49fa340ad9ce">More...</a><br /></td></tr>
<tr class="separator:a78a463a6ee3671a6aecd49fa340ad9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd76d481678984fb7732abb73a501440"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:abd76d481678984fb7732abb73a501440"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#abd76d481678984fb7732abb73a501440">addAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:abd76d481678984fb7732abb73a501440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the addition assignment of a row-major dense matrix.  <a href="#abd76d481678984fb7732abb73a501440">More...</a><br /></td></tr>
<tr class="separator:abd76d481678984fb7732abb73a501440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a8451b75566cffe1e2cdb19208948c"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ab1a8451b75566cffe1e2cdb19208948c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ab1a8451b75566cffe1e2cdb19208948c">subAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab1a8451b75566cffe1e2cdb19208948c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a row-major dense matrix.  <a href="#ab1a8451b75566cffe1e2cdb19208948c">More...</a><br /></td></tr>
<tr class="separator:ab1a8451b75566cffe1e2cdb19208948c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac2708b713a15feb121883d81569227"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a1ac2708b713a15feb121883d81569227"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a1ac2708b713a15feb121883d81569227">subAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1ac2708b713a15feb121883d81569227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic optimized implementation of the subtraction assignment of a row-major dense matrix.  <a href="#a1ac2708b713a15feb121883d81569227">More...</a><br /></td></tr>
<tr class="separator:a1ac2708b713a15feb121883d81569227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a540a2c4c893ac8d4842bbbfd19a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#af6a540a2c4c893ac8d4842bbbfd19a61">operator~</a> ()</td></tr>
<tr class="memdesc:af6a540a2c4c893ac8d4842bbbfd19a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for non-constant matrices.  <a href="#af6a540a2c4c893ac8d4842bbbfd19a61">More...</a><br /></td></tr>
<tr class="separator:af6a540a2c4c893ac8d4842bbbfd19a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71becdce9e44bcba62ee6458c6f5a6fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a71becdce9e44bcba62ee6458c6f5a6fb">operator~</a> () const </td></tr>
<tr class="memdesc:a71becdce9e44bcba62ee6458c6f5a6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator for constant matrices.  <a href="#a71becdce9e44bcba62ee6458c6f5a6fb">More...</a><br /></td></tr>
<tr class="separator:a71becdce9e44bcba62ee6458c6f5a6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a82a9781672d66200bc88124052789b38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82a9781672d66200bc88124052789b38"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a82a9781672d66200bc88124052789b38">DynamicMatrix</a> ()</td></tr>
<tr class="memdesc:a82a9781672d66200bc88124052789b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor for <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a>. <br /></td></tr>
<tr class="separator:a82a9781672d66200bc88124052789b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c6ebe364618ed8bd872f912c5a6926"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a13c6ebe364618ed8bd872f912c5a6926">DynamicMatrix</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:a13c6ebe364618ed8bd872f912c5a6926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a matrix of size <img class="formulaInl" alt="$ m \times n $" src="../../form_52.png"/>. No element initialization is performed!  <a href="#a13c6ebe364618ed8bd872f912c5a6926">More...</a><br /></td></tr>
<tr class="separator:a13c6ebe364618ed8bd872f912c5a6926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26db057b4ca2148f7c97ffade1241a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#aa26db057b4ca2148f7c97ffade1241a3">DynamicMatrix</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, const Type &amp;init)</td></tr>
<tr class="memdesc:aa26db057b4ca2148f7c97ffade1241a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a homogenous initialization of all <img class="formulaInl" alt="$ m \times n $" src="../../form_52.png"/> matrix elements.  <a href="#aa26db057b4ca2148f7c97ffade1241a3">More...</a><br /></td></tr>
<tr class="separator:aa26db057b4ca2148f7c97ffade1241a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834f5f05c93fff58d718c4c551fead07"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a834f5f05c93fff58d718c4c551fead07"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a834f5f05c93fff58d718c4c551fead07">DynamicMatrix</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, const Other *array)</td></tr>
<tr class="memdesc:a834f5f05c93fff58d718c4c551fead07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array initialization of all matrix elements.  <a href="#a834f5f05c93fff58d718c4c551fead07">More...</a><br /></td></tr>
<tr class="separator:a834f5f05c93fff58d718c4c551fead07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7443eb18fbdd9bca3370d7f76458a610"><td class="memTemplParams" colspan="2">template&lt;typename Other , size_t M, size_t N&gt; </td></tr>
<tr class="memitem:a7443eb18fbdd9bca3370d7f76458a610"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a7443eb18fbdd9bca3370d7f76458a610">DynamicMatrix</a> (const Other(&amp;array)[M][N])</td></tr>
<tr class="memdesc:a7443eb18fbdd9bca3370d7f76458a610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array initialization of all matrix elements.  <a href="#a7443eb18fbdd9bca3370d7f76458a610">More...</a><br /></td></tr>
<tr class="separator:a7443eb18fbdd9bca3370d7f76458a610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c01f7ae5abd8f26bc2a270b1780f84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a35c01f7ae5abd8f26bc2a270b1780f84">DynamicMatrix</a> (const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> &amp;m)</td></tr>
<tr class="memdesc:a35c01f7ae5abd8f26bc2a270b1780f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor for <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a>.  <a href="#a35c01f7ae5abd8f26bc2a270b1780f84">More...</a><br /></td></tr>
<tr class="separator:a35c01f7ae5abd8f26bc2a270b1780f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fa8672112ed48ca4f6b1c6c685cc0c"><td class="memTemplParams" colspan="2">template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a08fa8672112ed48ca4f6b1c6c685cc0c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a08fa8672112ed48ca4f6b1c6c685cc0c">DynamicMatrix</a> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;m)</td></tr>
<tr class="memdesc:a08fa8672112ed48ca4f6b1c6c685cc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion constructor from different matrices.  <a href="#a08fa8672112ed48ca4f6b1c6c685cc0c">More...</a><br /></td></tr>
<tr class="separator:a08fa8672112ed48ca4f6b1c6c685cc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:af3e0bed08fedd565c28f0f4c6e1b25f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3e0bed08fedd565c28f0f4c6e1b25f4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#af3e0bed08fedd565c28f0f4c6e1b25f4">~DynamicMatrix</a> ()</td></tr>
<tr class="memdesc:af3e0bed08fedd565c28f0f4c6e1b25f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor for <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a>. <br /></td></tr>
<tr class="separator:af3e0bed08fedd565c28f0f4c6e1b25f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access functions</div></td></tr>
<tr class="memitem:a73600a6415609a425847c1fe97a5c445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#afa7716897295045a77922b9016597dd3">Reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a73600a6415609a425847c1fe97a5c445">operator()</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j)</td></tr>
<tr class="memdesc:a73600a6415609a425847c1fe97a5c445"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D-access to the matrix elements.  <a href="#a73600a6415609a425847c1fe97a5c445">More...</a><br /></td></tr>
<tr class="separator:a73600a6415609a425847c1fe97a5c445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74658d32a5302febab55b1d50857c83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a600d9acc1b695e6e8ee07a1137cfcd5c">ConstReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#aa74658d32a5302febab55b1d50857c83">operator()</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const </td></tr>
<tr class="memdesc:aa74658d32a5302febab55b1d50857c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D-access to the matrix elements.  <a href="#aa74658d32a5302febab55b1d50857c83">More...</a><br /></td></tr>
<tr class="separator:aa74658d32a5302febab55b1d50857c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb14d78fa8d7d48f8fdb0602f6a3a95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#af37108ab139573e0149b63c09190997e">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a5bb14d78fa8d7d48f8fdb0602f6a3a95">data</a> ()</td></tr>
<tr class="memdesc:a5bb14d78fa8d7d48f8fdb0602f6a3a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the matrix elements.  <a href="#a5bb14d78fa8d7d48f8fdb0602f6a3a95">More...</a><br /></td></tr>
<tr class="separator:a5bb14d78fa8d7d48f8fdb0602f6a3a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19452d03183655ee441b82a21106d30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a28c594626a5952d7ddad9e0ccb64e441">ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ab19452d03183655ee441b82a21106d30">data</a> () const </td></tr>
<tr class="memdesc:ab19452d03183655ee441b82a21106d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the matrix elements.  <a href="#ab19452d03183655ee441b82a21106d30">More...</a><br /></td></tr>
<tr class="separator:ab19452d03183655ee441b82a21106d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da7f4e7ab0c88e4c3baa3231b00adb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#af37108ab139573e0149b63c09190997e">Pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a4da7f4e7ab0c88e4c3baa3231b00adb7">data</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:a4da7f4e7ab0c88e4c3baa3231b00adb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the matrix elements of row/column <em>i</em>.  <a href="#a4da7f4e7ab0c88e4c3baa3231b00adb7">More...</a><br /></td></tr>
<tr class="separator:a4da7f4e7ab0c88e4c3baa3231b00adb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c92700c9453ae71ab8c62aac766587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a28c594626a5952d7ddad9e0ccb64e441">ConstPointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a78c92700c9453ae71ab8c62aac766587">data</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:a78c92700c9453ae71ab8c62aac766587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level data access to the matrix elements of row/column <em>i</em>.  <a href="#a78c92700c9453ae71ab8c62aac766587">More...</a><br /></td></tr>
<tr class="separator:a78c92700c9453ae71ab8c62aac766587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c989fca9877dce31f5267e2c4b7934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a143e7e720de03484547f8d5e81197ca9">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a78c989fca9877dce31f5267e2c4b7934">begin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:a78c989fca9877dce31f5267e2c4b7934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em>.  <a href="#a78c989fca9877dce31f5267e2c4b7934">More...</a><br /></td></tr>
<tr class="separator:a78c989fca9877dce31f5267e2c4b7934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf467fec692b113195968ce75b271f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a014ffc8116459b6abae9e0255f9ca6b3">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#aeaf467fec692b113195968ce75b271f0">begin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:aeaf467fec692b113195968ce75b271f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em>.  <a href="#aeaf467fec692b113195968ce75b271f0">More...</a><br /></td></tr>
<tr class="separator:aeaf467fec692b113195968ce75b271f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5865fc962ce4e7985e9e44a3227225f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a014ffc8116459b6abae9e0255f9ca6b3">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a5865fc962ce4e7985e9e44a3227225f7">cbegin</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:a5865fc962ce4e7985e9e44a3227225f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of row/column <em>i</em>.  <a href="#a5865fc962ce4e7985e9e44a3227225f7">More...</a><br /></td></tr>
<tr class="separator:a5865fc962ce4e7985e9e44a3227225f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9318abf20c821be6169bcc30c8961359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a143e7e720de03484547f8d5e81197ca9">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a9318abf20c821be6169bcc30c8961359">end</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:a9318abf20c821be6169bcc30c8961359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em>.  <a href="#a9318abf20c821be6169bcc30c8961359">More...</a><br /></td></tr>
<tr class="separator:a9318abf20c821be6169bcc30c8961359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6af024e946a6b594fc28ba975bbf8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a014ffc8116459b6abae9e0255f9ca6b3">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a3d6af024e946a6b594fc28ba975bbf8e">end</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:a3d6af024e946a6b594fc28ba975bbf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em>.  <a href="#a3d6af024e946a6b594fc28ba975bbf8e">More...</a><br /></td></tr>
<tr class="separator:a3d6af024e946a6b594fc28ba975bbf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc8e6d0685a01090b33c8c6b9c3a353"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a014ffc8116459b6abae9e0255f9ca6b3">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a0cc8e6d0685a01090b33c8c6b9c3a353">cend</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:a0cc8e6d0685a01090b33c8c6b9c3a353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the last element of row/column <em>i</em>.  <a href="#a0cc8e6d0685a01090b33c8c6b9c3a353">More...</a><br /></td></tr>
<tr class="separator:a0cc8e6d0685a01090b33c8c6b9c3a353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment operators</div></td></tr>
<tr class="memitem:ad53cfbaa1669c73df56b2bb46da46bc6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad53cfbaa1669c73df56b2bb46da46bc6"></a>
template&lt;typename Other , size_t M, size_t N&gt; </td></tr>
<tr class="memitem:ad53cfbaa1669c73df56b2bb46da46bc6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const Other(&amp;array)[M][N])</td></tr>
<tr class="separator:ad53cfbaa1669c73df56b2bb46da46bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb94ce0fd105bece71d0dc1a37761bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#afb94ce0fd105bece71d0dc1a37761bd9">operator=</a> (Type <a class="el" href="../../df/daa/group__intrinsics.html#gae6e5b4b28a27323847ddb31628b84ee6">set</a>)</td></tr>
<tr class="memdesc:afb94ce0fd105bece71d0dc1a37761bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Homogenous assignment to all matrix elements.  <a href="#afb94ce0fd105bece71d0dc1a37761bd9">More...</a><br /></td></tr>
<tr class="separator:afb94ce0fd105bece71d0dc1a37761bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe89612bf924c148dfe10c80c6382a3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#afe89612bf924c148dfe10c80c6382a3d">operator=</a> (const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> &amp;rhs)</td></tr>
<tr class="memdesc:afe89612bf924c148dfe10c80c6382a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a>.  <a href="#afe89612bf924c148dfe10c80c6382a3d">More...</a><br /></td></tr>
<tr class="separator:afe89612bf924c148dfe10c80c6382a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa28435cde37460f26d72d087fea16e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7fa28435cde37460f26d72d087fea16e"></a>
template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a7fa28435cde37460f26d72d087fea16e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a7fa28435cde37460f26d72d087fea16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0ee28b58bd7b98550af777161b4d6a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0c0ee28b58bd7b98550af777161b4d6a"></a>
template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:a0c0ee28b58bd7b98550af777161b4d6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a0c0ee28b58bd7b98550af777161b4d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa9b671c92b1e863d9b51891cc6c84c"><td class="memTemplParams" colspan="2"><a class="anchor" id="adaa9b671c92b1e863d9b51891cc6c84c"></a>
template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:adaa9b671c92b1e863d9b51891cc6c84c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:adaa9b671c92b1e863d9b51891cc6c84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadcb2f48235361b679d4d3dfa75aeb2"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeadcb2f48235361b679d4d3dfa75aeb2"></a>
template&lt;typename MT , bool SO2&gt; </td></tr>
<tr class="memitem:aeadcb2f48235361b679d4d3dfa75aeb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;rhs)</td></tr>
<tr class="separator:aeadcb2f48235361b679d4d3dfa75aeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dc2c6fb2a4f00a6afb354b4da45277"><td class="memTemplParams" colspan="2"><a class="anchor" id="a10dc2c6fb2a4f00a6afb354b4da45277"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a10dc2c6fb2a4f00a6afb354b4da45277"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (Other rhs)</td></tr>
<tr class="separator:a10dc2c6fb2a4f00a6afb354b4da45277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523c93e68e9db49036beeff6bf68c5b7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a523c93e68e9db49036beeff6bf68c5b7"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a523c93e68e9db49036beeff6bf68c5b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt; Other &gt;, <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> &gt;::Type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (Other rhs)</td></tr>
<tr class="separator:a523c93e68e9db49036beeff6bf68c5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Expression template evaluation functions</div></td></tr>
<tr class="memitem:a70ff1d579c88bb7c410df99f172d71f5"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a70ff1d579c88bb7c410df99f172d71f5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a70ff1d579c88bb7c410df99f172d71f5">canAlias</a> (const Other *alias) const </td></tr>
<tr class="memdesc:a70ff1d579c88bb7c410df99f172d71f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix can alias with the given address <em>alias</em>.  <a href="#a70ff1d579c88bb7c410df99f172d71f5">More...</a><br /></td></tr>
<tr class="separator:a70ff1d579c88bb7c410df99f172d71f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0bc293eab8272d1230ae2aebdb2319"><td class="memTemplParams" colspan="2">template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a7c0bc293eab8272d1230ae2aebdb2319"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a7c0bc293eab8272d1230ae2aebdb2319">isAliased</a> (const Other *alias) const </td></tr>
<tr class="memdesc:a7c0bc293eab8272d1230ae2aebdb2319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix is aliased with the given address <em>alias</em>.  <a href="#a7c0bc293eab8272d1230ae2aebdb2319">More...</a><br /></td></tr>
<tr class="separator:a7c0bc293eab8272d1230ae2aebdb2319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f0a6d8b96048c7c36842ba49deb531"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a96f0a6d8b96048c7c36842ba49deb531">isAligned</a> () const </td></tr>
<tr class="memdesc:a96f0a6d8b96048c7c36842ba49deb531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix is properly aligned in memory.  <a href="#a96f0a6d8b96048c7c36842ba49deb531">More...</a><br /></td></tr>
<tr class="separator:a96f0a6d8b96048c7c36842ba49deb531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5ee7d0180ca6b960ceafe3223012d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a9a5ee7d0180ca6b960ceafe3223012d3">canSMPAssign</a> () const </td></tr>
<tr class="memdesc:a9a5ee7d0180ca6b960ceafe3223012d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the matrix can be used in SMP assignments.  <a href="#a9a5ee7d0180ca6b960ceafe3223012d3">More...</a><br /></td></tr>
<tr class="separator:a9a5ee7d0180ca6b960ceafe3223012d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba71f59e1379169164f7474385a78cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a9d673389dcc90152922ac6d3424e1889">IntrinsicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a5ba71f59e1379169164f7474385a78cf">load</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const </td></tr>
<tr class="memdesc:a5ba71f59e1379169164f7474385a78cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned load of an intrinsic element of the matrix.  <a href="#a5ba71f59e1379169164f7474385a78cf">More...</a><br /></td></tr>
<tr class="separator:a5ba71f59e1379169164f7474385a78cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c838cea360388e222a1fee43d4c49c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a9d673389dcc90152922ac6d3424e1889">IntrinsicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a1c838cea360388e222a1fee43d4c49c2">loadu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j) const </td></tr>
<tr class="memdesc:a1c838cea360388e222a1fee43d4c49c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned load of an intrinsic element of the matrix.  <a href="#a1c838cea360388e222a1fee43d4c49c2">More...</a><br /></td></tr>
<tr class="separator:a1c838cea360388e222a1fee43d4c49c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c36b7b0dc1c284b9640ad0ab85742e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a3c36b7b0dc1c284b9640ad0ab85742e9">store</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a9d673389dcc90152922ac6d3424e1889">IntrinsicType</a> &amp;value)</td></tr>
<tr class="memdesc:a3c36b7b0dc1c284b9640ad0ab85742e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned store of an intrinsic element of the matrix.  <a href="#a3c36b7b0dc1c284b9640ad0ab85742e9">More...</a><br /></td></tr>
<tr class="separator:a3c36b7b0dc1c284b9640ad0ab85742e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579c7e521f0e5005d0ca849610fd105b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a579c7e521f0e5005d0ca849610fd105b">storeu</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a9d673389dcc90152922ac6d3424e1889">IntrinsicType</a> &amp;value)</td></tr>
<tr class="memdesc:a579c7e521f0e5005d0ca849610fd105b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unaligned store of an intrinsic element of the matrix.  <a href="#a579c7e521f0e5005d0ca849610fd105b">More...</a><br /></td></tr>
<tr class="separator:a579c7e521f0e5005d0ca849610fd105b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268c13d173164fbd6102e81c3574d23c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a268c13d173164fbd6102e81c3574d23c">stream</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> j, const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a9d673389dcc90152922ac6d3424e1889">IntrinsicType</a> &amp;value)</td></tr>
<tr class="memdesc:a268c13d173164fbd6102e81c3574d23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned, non-temporal store of an intrinsic element of the matrix.  <a href="#a268c13d173164fbd6102e81c3574d23c">More...</a><br /></td></tr>
<tr class="separator:a268c13d173164fbd6102e81c3574d23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4dd82f67f97b3be33d5336dc6f06975"><td class="memTemplParams" colspan="2"><a class="anchor" id="af4dd82f67f97b3be33d5336dc6f06975"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:af4dd82f67f97b3be33d5336dc6f06975"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedAssign&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:af4dd82f67f97b3be33d5336dc6f06975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0272249d102142001d64d479d756e44"><td class="memTemplParams" colspan="2"><a class="anchor" id="af0272249d102142001d64d479d756e44"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:af0272249d102142001d64d479d756e44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedAssign&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:af0272249d102142001d64d479d756e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a9e311ec780d94e90e4e32bf95d881"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ad2a9e311ec780d94e90e4e32bf95d881"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ad2a9e311ec780d94e90e4e32bf95d881">assign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad2a9e311ec780d94e90e4e32bf95d881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a column-major dense matrix.  <a href="#ad2a9e311ec780d94e90e4e32bf95d881">More...</a><br /></td></tr>
<tr class="separator:ad2a9e311ec780d94e90e4e32bf95d881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb22f701c8f2067c1ae6d5528c474991"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:abb22f701c8f2067c1ae6d5528c474991"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#abb22f701c8f2067c1ae6d5528c474991">assign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:abb22f701c8f2067c1ae6d5528c474991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a row-major sparse matrix.  <a href="#abb22f701c8f2067c1ae6d5528c474991">More...</a><br /></td></tr>
<tr class="separator:abb22f701c8f2067c1ae6d5528c474991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a64a37ee0a3ae66199f84efc3475a2f"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a3a64a37ee0a3ae66199f84efc3475a2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a3a64a37ee0a3ae66199f84efc3475a2f">assign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a3a64a37ee0a3ae66199f84efc3475a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the assignment of a column-major sparse matrix.  <a href="#a3a64a37ee0a3ae66199f84efc3475a2f">More...</a><br /></td></tr>
<tr class="separator:a3a64a37ee0a3ae66199f84efc3475a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ffad3af332652e23f38cbc648cd37a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab2ffad3af332652e23f38cbc648cd37a"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ab2ffad3af332652e23f38cbc648cd37a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedAddAssign&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:ab2ffad3af332652e23f38cbc648cd37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15109774a246cde70dc832537c9ecc8b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a15109774a246cde70dc832537c9ecc8b"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a15109774a246cde70dc832537c9ecc8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedAddAssign&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:a15109774a246cde70dc832537c9ecc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d342d45d33ef1fd1328265752b2267a"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a1d342d45d33ef1fd1328265752b2267a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a1d342d45d33ef1fd1328265752b2267a">addAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1d342d45d33ef1fd1328265752b2267a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a column-major dense matrix.  <a href="#a1d342d45d33ef1fd1328265752b2267a">More...</a><br /></td></tr>
<tr class="separator:a1d342d45d33ef1fd1328265752b2267a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9302a2ec422709abeae443ca4e9178a9"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a9302a2ec422709abeae443ca4e9178a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a9302a2ec422709abeae443ca4e9178a9">addAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9302a2ec422709abeae443ca4e9178a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a row-major sparse matrix.  <a href="#a9302a2ec422709abeae443ca4e9178a9">More...</a><br /></td></tr>
<tr class="separator:a9302a2ec422709abeae443ca4e9178a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72cf6c8630880e9b6ce8c92d281c6d8"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:ad72cf6c8630880e9b6ce8c92d281c6d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ad72cf6c8630880e9b6ce8c92d281c6d8">addAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad72cf6c8630880e9b6ce8c92d281c6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the addition assignment of a column-major sparse matrix.  <a href="#ad72cf6c8630880e9b6ce8c92d281c6d8">More...</a><br /></td></tr>
<tr class="separator:ad72cf6c8630880e9b6ce8c92d281c6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ea2e0ae49f83ca24f49e2d5f939fb9"><td class="memTemplParams" colspan="2"><a class="anchor" id="af0ea2e0ae49f83ca24f49e2d5f939fb9"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:af0ea2e0ae49f83ca24f49e2d5f939fb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; VectorizedSubAssign&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:af0ea2e0ae49f83ca24f49e2d5f939fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05071e63a1603341f31c1024d6e461da"><td class="memTemplParams" colspan="2"><a class="anchor" id="a05071e63a1603341f31c1024d6e461da"></a>
template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a05071e63a1603341f31c1024d6e461da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; VectorizedSubAssign&lt; MT &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subAssign</b> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="separator:a05071e63a1603341f31c1024d6e461da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b0ec850297d0caf27b49c259944d2d"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a98b0ec850297d0caf27b49c259944d2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a98b0ec850297d0caf27b49c259944d2d">subAssign</a> (const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a98b0ec850297d0caf27b49c259944d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a column-major dense matrix.  <a href="#a98b0ec850297d0caf27b49c259944d2d">More...</a><br /></td></tr>
<tr class="separator:a98b0ec850297d0caf27b49c259944d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88af9bdb6974b2d3fb1337a780ac61fa"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a88af9bdb6974b2d3fb1337a780ac61fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a88af9bdb6974b2d3fb1337a780ac61fa">subAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a88af9bdb6974b2d3fb1337a780ac61fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a row-major sparse matrix.  <a href="#a88af9bdb6974b2d3fb1337a780ac61fa">More...</a><br /></td></tr>
<tr class="separator:a88af9bdb6974b2d3fb1337a780ac61fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdc0ffbad87fc3d812b051cb99c70e0"><td class="memTemplParams" colspan="2">template&lt;typename MT &gt; </td></tr>
<tr class="memitem:a6cdc0ffbad87fc3d812b051cb99c70e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a6cdc0ffbad87fc3d812b051cb99c70e0">subAssign</a> (const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6cdc0ffbad87fc3d812b051cb99c70e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the subtraction assignment of a column-major sparse matrix.  <a href="#a6cdc0ffbad87fc3d812b051cb99c70e0">More...</a><br /></td></tr>
<tr class="separator:a6cdc0ffbad87fc3d812b051cb99c70e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a02d0b5b1ebbeb07b31ad3cc7d4168971"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02d0b5b1ebbeb07b31ad3cc7d4168971"></a>
typedef <a class="el" href="../../d7/d73/classblaze_1_1IntrinsicTrait.html">IntrinsicTrait</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a02d0b5b1ebbeb07b31ad3cc7d4168971">IT</a></td></tr>
<tr class="memdesc:a02d0b5b1ebbeb07b31ad3cc7d4168971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic trait for the matrix element type. <br /></td></tr>
<tr class="separator:a02d0b5b1ebbeb07b31ad3cc7d4168971"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:a86f8acfdecc8569ee4014d7e977a1887"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86f8acfdecc8569ee4014d7e977a1887"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a86f8acfdecc8569ee4014d7e977a1887">m_</a></td></tr>
<tr class="memdesc:a86f8acfdecc8569ee4014d7e977a1887"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current number of rows of the matrix. <br /></td></tr>
<tr class="separator:a86f8acfdecc8569ee4014d7e977a1887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfd689f2d3f9549a38558ba995ca29f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcfd689f2d3f9549a38558ba995ca29f"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#adcfd689f2d3f9549a38558ba995ca29f">n_</a></td></tr>
<tr class="memdesc:adcfd689f2d3f9549a38558ba995ca29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current number of columns of the matrix. <br /></td></tr>
<tr class="separator:adcfd689f2d3f9549a38558ba995ca29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d781a5f6d655a0fc83e21239888ecd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d781a5f6d655a0fc83e21239888ecd4"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a8d781a5f6d655a0fc83e21239888ecd4">nn_</a></td></tr>
<tr class="memdesc:a8d781a5f6d655a0fc83e21239888ecd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alignment adjusted number of columns. <br /></td></tr>
<tr class="separator:a8d781a5f6d655a0fc83e21239888ecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1916a2592c20f6c13111add6e543b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b1916a2592c20f6c13111add6e543b4"></a>
<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a1b1916a2592c20f6c13111add6e543b4">capacity_</a></td></tr>
<tr class="memdesc:a1b1916a2592c20f6c13111add6e543b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum capacity of the matrix. <br /></td></tr>
<tr class="separator:a1b1916a2592c20f6c13111add6e543b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c09cd12716cef8b79831c6a77c2628e"><td class="memItemLeft" align="right" valign="top">Type *<a class="el" href="../../d4/d37/group__system.html#gaeb7809d70987fc2dbe69c2fea852d797">BLAZE_RESTRICT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a4c09cd12716cef8b79831c6a77c2628e">v_</a></td></tr>
<tr class="memdesc:a4c09cd12716cef8b79831c6a77c2628e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dynamically allocated matrix elements.  <a href="#a4c09cd12716cef8b79831c6a77c2628e">More...</a><br /></td></tr>
<tr class="separator:a4c09cd12716cef8b79831c6a77c2628e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Utility functions</h2></td></tr>
<tr class="memitem:a28b7d5dd5032bb82f553b17c75b80430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a28b7d5dd5032bb82f553b17c75b80430">rows</a> () const </td></tr>
<tr class="memdesc:a28b7d5dd5032bb82f553b17c75b80430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of rows of the matrix.  <a href="#a28b7d5dd5032bb82f553b17c75b80430">More...</a><br /></td></tr>
<tr class="separator:a28b7d5dd5032bb82f553b17c75b80430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3e0768dfe0f6104ece139148479b2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#aba3e0768dfe0f6104ece139148479b2a">columns</a> () const </td></tr>
<tr class="memdesc:aba3e0768dfe0f6104ece139148479b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of columns of the matrix.  <a href="#aba3e0768dfe0f6104ece139148479b2a">More...</a><br /></td></tr>
<tr class="separator:aba3e0768dfe0f6104ece139148479b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac667836fd3212bfcb1577cac94285e7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ac667836fd3212bfcb1577cac94285e7e">spacing</a> () const </td></tr>
<tr class="memdesc:ac667836fd3212bfcb1577cac94285e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the spacing between the beginning of two rows/columns.  <a href="#ac667836fd3212bfcb1577cac94285e7e">More...</a><br /></td></tr>
<tr class="separator:ac667836fd3212bfcb1577cac94285e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b81f2249b2b4f98c8f89a519e17cfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ab6b81f2249b2b4f98c8f89a519e17cfa">capacity</a> () const </td></tr>
<tr class="memdesc:ab6b81f2249b2b4f98c8f89a519e17cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum capacity of the matrix.  <a href="#ab6b81f2249b2b4f98c8f89a519e17cfa">More...</a><br /></td></tr>
<tr class="separator:ab6b81f2249b2b4f98c8f89a519e17cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3f40229e810437d0fe1a095755b278"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#aaa3f40229e810437d0fe1a095755b278">capacity</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:aaa3f40229e810437d0fe1a095755b278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current capacity of the specified row/column.  <a href="#aaa3f40229e810437d0fe1a095755b278">More...</a><br /></td></tr>
<tr class="separator:aaa3f40229e810437d0fe1a095755b278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c9abfeef09771079b9d441c68383ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a04c9abfeef09771079b9d441c68383ca">nonZeros</a> () const </td></tr>
<tr class="memdesc:a04c9abfeef09771079b9d441c68383ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of non-zero elements in the matrix.  <a href="#a04c9abfeef09771079b9d441c68383ca">More...</a><br /></td></tr>
<tr class="separator:a04c9abfeef09771079b9d441c68383ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94f2e90f0a5e3d56c1a8b5efb2e16a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ac94f2e90f0a5e3d56c1a8b5efb2e16a0">nonZeros</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i) const </td></tr>
<tr class="memdesc:ac94f2e90f0a5e3d56c1a8b5efb2e16a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-zero elements in the specified row/column.  <a href="#ac94f2e90f0a5e3d56c1a8b5efb2e16a0">More...</a><br /></td></tr>
<tr class="separator:ac94f2e90f0a5e3d56c1a8b5efb2e16a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e6bf358dca281ce1abfc24c324d985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#aa8e6bf358dca281ce1abfc24c324d985">reset</a> ()</td></tr>
<tr class="memdesc:aa8e6bf358dca281ce1abfc24c324d985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to the default initial values.  <a href="#aa8e6bf358dca281ce1abfc24c324d985">More...</a><br /></td></tr>
<tr class="separator:aa8e6bf358dca281ce1abfc24c324d985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd3d6fc1f43f49ef6949106a030d1b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a6cd3d6fc1f43f49ef6949106a030d1b1">reset</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> i)</td></tr>
<tr class="memdesc:a6cd3d6fc1f43f49ef6949106a030d1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the specified row/column to the default initial values.  <a href="#a6cd3d6fc1f43f49ef6949106a030d1b1">More...</a><br /></td></tr>
<tr class="separator:a6cd3d6fc1f43f49ef6949106a030d1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab1dbfd20bfdb175673ef51f1221b42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#afab1dbfd20bfdb175673ef51f1221b42">clear</a> ()</td></tr>
<tr class="memdesc:afab1dbfd20bfdb175673ef51f1221b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the <img class="formulaInl" alt="$ M \times N $" src="../../form_48.png"/> matrix.  <a href="#afab1dbfd20bfdb175673ef51f1221b42">More...</a><br /></td></tr>
<tr class="separator:afab1dbfd20bfdb175673ef51f1221b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12614e6ea64ebee876e22576a7ad1bf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a12614e6ea64ebee876e22576a7ad1bf6">resize</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve=true)</td></tr>
<tr class="memdesc:a12614e6ea64ebee876e22576a7ad1bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing the size of the matrix.  <a href="#a12614e6ea64ebee876e22576a7ad1bf6">More...</a><br /></td></tr>
<tr class="separator:a12614e6ea64ebee876e22576a7ad1bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f8f49d308a5daf390f1122e4df5afe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a30f8f49d308a5daf390f1122e4df5afe">extend</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> m, <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool preserve=true)</td></tr>
<tr class="memdesc:a30f8f49d308a5daf390f1122e4df5afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extending the size of the matrix.  <a href="#a30f8f49d308a5daf390f1122e4df5afe">More...</a><br /></td></tr>
<tr class="separator:a30f8f49d308a5daf390f1122e4df5afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426ee42e366c0211ecab7dbe4cc9593b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a426ee42e366c0211ecab7dbe4cc9593b">reserve</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> elements)</td></tr>
<tr class="memdesc:a426ee42e366c0211ecab7dbe4cc9593b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the minimum capacity of the matrix.  <a href="#a426ee42e366c0211ecab7dbe4cc9593b">More...</a><br /></td></tr>
<tr class="separator:a426ee42e366c0211ecab7dbe4cc9593b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af891916acbfc3ad5caa7f38efe6a6fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#af891916acbfc3ad5caa7f38efe6a6fbf">transpose</a> ()</td></tr>
<tr class="memdesc:af891916acbfc3ad5caa7f38efe6a6fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposing the matrix.  <a href="#af891916acbfc3ad5caa7f38efe6a6fbf">More...</a><br /></td></tr>
<tr class="separator:af891916acbfc3ad5caa7f38efe6a6fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2fa1eaa5d67181eaeaf9446eee9198"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f2fa1eaa5d67181eaeaf9446eee9198"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a2f2fa1eaa5d67181eaeaf9446eee9198"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scale</b> (const Other &amp;scalar)</td></tr>
<tr class="separator:a2f2fa1eaa5d67181eaeaf9446eee9198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0a7281d8f49fff213113e5f1dd418c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a6d0a7281d8f49fff213113e5f1dd418c">swap</a> (<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> &amp;m)</td></tr>
<tr class="memdesc:a6d0a7281d8f49fff213113e5f1dd418c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swapping the contents of two matrices.  <a href="#a6d0a7281d8f49fff213113e5f1dd418c">More...</a><br /></td></tr>
<tr class="separator:a6d0a7281d8f49fff213113e5f1dd418c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad888c697b0933316ff8e768cda844eda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ad888c697b0933316ff8e768cda844eda">adjustColumns</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> minColumns) const </td></tr>
<tr class="memdesc:ad888c697b0933316ff8e768cda844eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusting the number columns of the matrix according to its data type <em>Type</em>.  <a href="#ad888c697b0933316ff8e768cda844eda">More...</a><br /></td></tr>
<tr class="separator:ad888c697b0933316ff8e768cda844eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Type, bool SO = defaultStorageOrder&gt;<br />
class blaze::DynamicMatrix&lt; Type, SO &gt;</h3>

<p>Efficient implementation of a dynamic <img class="formulaInl" alt="$ M \times N $" src="../../form_48.png"/> matrix.</p>
<p>The <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a> class template is the representation of an arbitrary sized matrix with <img class="formulaInl" alt="$ M \times N $" src="../../form_48.png"/> dynamically allocated elements of arbitrary type. The type of the elements and the storage order of the matrix can be specified via the two template parameters: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> Type, <span class="keywordtype">bool</span> SO &gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a82a9781672d66200bc88124052789b38">DynamicMatrix</a>;</div>
</div><!-- fragment --><ul>
<li>Type: specifies the type of the matrix elements. <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a> can be used with any non-cv-qualified, non-reference, non-pointer element type.</li>
<li>SO : specifies the storage order (<a class="el" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices. ">blaze::rowMajor</a>, <a class="el" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583" title="Storage order flag for column-major matrices. ">blaze::columnMajor</a>) of the matrix. The default value is <a class="el" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa" title="Storage order flag for row-major matrices. ">blaze::rowMajor</a>.</li>
</ul>
<p>Depending on the storage order, the matrix elements are either stored in a row-wise fashion or in a column-wise fashion. Given the 2x3 matrix</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{3}{c}} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ \end{array}\right)\]" src="../../form_49.png"/>
</p>
<p><br />
 in case of row-major order the elements are stored in the order</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{6}{c}} 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6. \\ \end{array}\right)\]" src="../../form_50.png"/>
</p>
<p>In case of column-major order the elements are stored in the order</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{6}{c}} 1 &amp; 4 &amp; 2 &amp; 5 &amp; 3 &amp; 6. \\ \end{array}\right)\]" src="../../form_51.png"/>
</p>
<p>The use of <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a> is very natural and intuitive. All operations (addition, subtraction, multiplication, scaling, ...) can be performed on all possible combination of row-major and column-major dense and sparse matrices with fitting element types. The following example gives an impression of the use of <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../da/d7a/classblaze_1_1CompressedMatrix.html">blaze::CompressedMatrix</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a5e42e1508f7d4d364fe7c64eef78a583">blaze::columnMajor</a>;</div>
<div class="line"></div>
<div class="line">DynamicMatrix&lt;double,rowMajor&gt; A( 2, 3 );  <span class="comment">// Default constructed, non-initialized, row-major 2x3 matrix</span></div>
<div class="line">A(0,0) = 1.0; A(0,1) = 2.0; A(0,2) = 3.0;  <span class="comment">// Initialization of the first row</span></div>
<div class="line">A(1,0) = 4.0; A(1,1) = 5.0; A(1,2) = 6.0;  <span class="comment">// Initialization of the second row</span></div>
<div class="line"></div>
<div class="line">DynamicMatrix&lt;float,columnMajor&gt; B( 2, 3 );  <span class="comment">// Default constructed column-major single precision 2x3 matrix</span></div>
<div class="line">B(0,0) = 1.0; B(0,1) = 3.0; B(0,2) = 5.0;    <span class="comment">// Initialization of the first row</span></div>
<div class="line">B(1,0) = 2.0; B(1,1) = 4.0; B(1,2) = 6.0;    <span class="comment">// Initialization of the second row</span></div>
<div class="line"></div>
<div class="line">CompressedMatrix&lt;float&gt; C( 2, 3 );        <span class="comment">// Empty row-major sparse single precision matrix</span></div>
<div class="line">DynamicMatrix&lt;float&gt;    D( 3, 2, 4.0F );  <span class="comment">// Directly, homogeneously initialized single precision 3x2 matrix</span></div>
<div class="line"></div>
<div class="line">DynamicMatrix&lt;double,rowMajor&gt;    E( A );  <span class="comment">// Creation of a new row-major matrix as a copy of A</span></div>
<div class="line">DynamicMatrix&lt;double,columnMajor&gt; F;       <span class="comment">// Creation of a default column-major matrix</span></div>
<div class="line"></div>
<div class="line">E = A + B;     <span class="comment">// Matrix addition and assignment to a row-major matrix</span></div>
<div class="line">F = A - C;     <span class="comment">// Matrix subtraction and assignment to a column-major matrix</span></div>
<div class="line">F = A * D;     <span class="comment">// Matrix multiplication between two matrices of different element types</span></div>
<div class="line"></div>
<div class="line">A *= 2.0;      <span class="comment">// In-place scaling of matrix A</span></div>
<div class="line">E  = 2.0 * B;  <span class="comment">// Scaling of matrix B</span></div>
<div class="line">F  = D * 2.0;  <span class="comment">// Scaling of matrix D</span></div>
<div class="line"></div>
<div class="line">E += A - B;    <span class="comment">// Addition assignment</span></div>
<div class="line">F -= A + C;    <span class="comment">// Subtraction assignment</span></div>
<div class="line">F *= A * D;    <span class="comment">// Multiplication assignment</span></div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a13c6ebe364618ed8bd872f912c5a6926"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a matrix of size <img class="formulaInl" alt="$ m \times n $" src="../../form_52.png"/>. No element initialization is performed! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows of the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns of the matrix.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Note:</b> This constructor is only responsible to allocate the required dynamic memory. No element initialization is performed! </p>

</div>
</div>
<a class="anchor" id="aa26db057b4ca2148f7c97ffade1241a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a homogenous initialization of all <img class="formulaInl" alt="$ m \times n $" src="../../form_52.png"/> matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows of the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns of the matrix. </td></tr>
    <tr><td class="paramname">init</td><td>The initial value of the matrix elements.</td></tr>
  </table>
  </dd>
</dl>
<p>All matrix elements are initialized with the specified value. </p>

</div>
</div>
<a class="anchor" id="a834f5f05c93fff58d718c4c551fead07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array initialization of all matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The number of rows of the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns of the matrix. </td></tr>
    <tr><td class="paramname">array</td><td>Dynamic array for the initialization.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to directly initialize the elements of the matrix with a dynamic array:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span>* array = <span class="keyword">new</span> <span class="keywordtype">int</span>[20];</div>
<div class="line"><span class="comment">// ... Initialization of the dynamic array</span></div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,rowMajor&gt;</a> v( 4UL, 5UL, array );</div>
<div class="line"><span class="keyword">delete</span>[] array;</div>
</div><!-- fragment --><p>The matrix is sized accoring to the given size of the array and initialized with the values from the given array. Note that it is expected that the given <em>array</em> has at least <em>m</em> by <em>n</em> elements. Providing an array with less elements results in undefined behavior! </p>

</div>
</div>
<a class="anchor" id="a7443eb18fbdd9bca3370d7f76458a610"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other , size_t M, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Other(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[M][N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array initialization of all matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td><img class="formulaInl" alt="$ M \times N $" src="../../form_48.png"/> dimensional array for the initialization.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor offers the option to directly initialize the elements of the matrix with a static array:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> init[3][3] = { { 1, 2, 3 },</div>
<div class="line">                         { 4, 5 },</div>
<div class="line">                         { 7, 8, 9 } };</div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,rowMajor&gt;</a> A( init );</div>
</div><!-- fragment --><p>The matrix is sized accoring to the size of the array and initialized with the values from the given array. Missing values are initialized with default values (as e.g. the value 6 in the example). </p>

</div>
</div>
<a class="anchor" id="a35c01f7ae5abd8f26bc2a270b1780f84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The copy constructor for <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be copied.</td></tr>
  </table>
  </dd>
</dl>
<p>The copy constructor is explicitly defined due to the required dynamic memory management and in order to enable/facilitate NRV optimization. </p>

</div>
</div>
<a class="anchor" id="a08fa8672112ed48ca4f6b1c6c685cc0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion constructor from different matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1d342d45d33ef1fd1328265752b2267a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a column-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a9302a2ec422709abeae443ca4e9178a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ad72cf6c8630880e9b6ce8c92d281c6d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a78a463a6ee3671a6aecd49fa340ad9ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt;Type,SO&gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt;MT&gt; &gt;::Type <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the addition assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="abd76d481678984fb7732abb73a501440"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt;Type,SO&gt;::BLAZE_TEMPLATE VectorizedAddAssign&lt;MT&gt; &gt;::Type <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::addAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the addition assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ad888c697b0933316ff8e768cda844eda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::adjustColumns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>minColumns</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusting the number columns of the matrix according to its data type <em>Type</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minColumns</td><td>The minimum necessary number of columns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The adjusted number of columns. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2a9e311ec780d94e90e4e32bf95d881"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a column-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="abb22f701c8f2067c1ae6d5528c474991"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a3a64a37ee0a3ae66199f84efc3475a2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a36d13ed1867cd9d7cf293a6fdc5605f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt;Type,SO&gt;::BLAZE_TEMPLATE VectorizedAssign&lt;MT&gt; &gt;::Type <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a791975b46aefd16fc300ff8302e7476d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt;Type,SO&gt;::BLAZE_TEMPLATE VectorizedAssign&lt;MT&gt; &gt;::Type <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a78c989fca9877dce31f5267e2c4b7934"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a143e7e720de03484547f8d5e81197ca9">Iterator</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="aeaf467fec692b113195968ce75b271f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a014ffc8116459b6abae9e0255f9ca6b3">ConstIterator</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a70ff1d579c88bb7c410df99f172d71f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::canAlias </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix can alias with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this matrix, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address can alias with the matrix. In contrast to the <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a7c0bc293eab8272d1230ae2aebdb2319" title="Returns whether the matrix is aliased with the given address alias. ">isAliased()</a> function this function is allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="a9a5ee7d0180ca6b960ceafe3223012d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::canSMPAssign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix can be used in SMP assignments. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the matrix can be used in SMP assignments, <em>false</em> if not.</dd></dl>
<p>This function returns whether the matrix can be used in SMP assignments. In contrast to the <em>smpAssignable</em> member enumeration, which is based solely on compile time information, this function additionally provides runtime information (as for instance the current number of rows and/or columns of the matrix). </p>

</div>
</div>
<a class="anchor" id="ab6b81f2249b2b4f98c8f89a519e17cfa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum capacity of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa3f40229e810437d0fe1a095755b278"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current capacity of the specified row/column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current capacity of row/column <em>i</em>.</dd></dl>
<p>This function returns the current capacity of the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the capacity of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the capacity of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a5865fc962ce4e7985e9e44a3227225f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a014ffc8116459b6abae9e0255f9ca6b3">ConstIterator</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of row/column <em>i</em>.</dd></dl>
<p>This function returns a row/column iterator to the first element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator to the first element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator to the first element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a0cc8e6d0685a01090b33c8c6b9c3a353"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a014ffc8116459b6abae9e0255f9ca6b3">ConstIterator</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="afab1dbfd20bfdb175673ef51f1221b42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clearing the <img class="formulaInl" alt="$ M \times N $" src="../../form_48.png"/> matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>After the <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#afab1dbfd20bfdb175673ef51f1221b42" title="Clearing the  matrix. ">clear()</a> function, the size of the matrix is 0. </p>

</div>
</div>
<a class="anchor" id="aba3e0768dfe0f6104ece139148479b2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current number of columns of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of columns of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a5bb14d78fa8d7d48f8fdb0602f6a3a95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#af37108ab139573e0149b63c09190997e">Pointer</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the matrix elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage of the dynamic matrix. Note that you can NOT assume that all matrix elements lie adjacent to each other! The dynamic matrix may use techniques such as padding to improve the alignment of the data. Whereas the number of elements within a row/column are given by the <code><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a28b7d5dd5032bb82f553b17c75b80430" title="Returns the current number of rows of the matrix. ">rows()</a></code> and <code><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#aba3e0768dfe0f6104ece139148479b2a" title="Returns the current number of columns of the matrix. ">columns()</a></code> member functions, respectively, the total number of elements including padding is given by the <code><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ac667836fd3212bfcb1577cac94285e7e" title="Returns the spacing between the beginning of two rows/columns. ">spacing()</a></code> member function. </p>

</div>
</div>
<a class="anchor" id="ab19452d03183655ee441b82a21106d30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a28c594626a5952d7ddad9e0ccb64e441">ConstPointer</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the matrix elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage of the dynamic matrix. Note that you can NOT assume that all matrix elements lie adjacent to each other! The dynamic matrix may use techniques such as padding to improve the alignment of the data. Whereas the number of elements within a row/column are given by the <code><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a28b7d5dd5032bb82f553b17c75b80430" title="Returns the current number of rows of the matrix. ">rows()</a></code> and <code><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#aba3e0768dfe0f6104ece139148479b2a" title="Returns the current number of columns of the matrix. ">columns()</a></code> member functions, respectively, the total number of elements including padding is given by the <code><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#ac667836fd3212bfcb1577cac94285e7e" title="Returns the spacing between the beginning of two rows/columns. ">spacing()</a></code> member function. </p>

</div>
</div>
<a class="anchor" id="a4da7f4e7ab0c88e4c3baa3231b00adb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#af37108ab139573e0149b63c09190997e">Pointer</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the matrix elements of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage for the elements in row/column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a78c92700c9453ae71ab8c62aac766587"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a28c594626a5952d7ddad9e0ccb64e441">ConstPointer</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level data access to the matrix elements of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal element storage.</dd></dl>
<p>This function returns a pointer to the internal storage for the elements in row/column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a9318abf20c821be6169bcc30c8961359"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a143e7e720de03484547f8d5e81197ca9">Iterator</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a3d6af024e946a6b594fc28ba975bbf8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a014ffc8116459b6abae9e0255f9ca6b3">ConstIterator</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the last element of row/column <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row/column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator just past the last element of row/column <em>i</em>.</dd></dl>
<p>This function returns an row/column iterator just past the last element of row/column <em>i</em>. In case the storage order is set to <em>rowMajor</em> the function returns an iterator just past the last element of row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns an iterator just past the last element of column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a30f8f49d308a5daf390f1122e4df5afe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extending the size of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Number of additional rows. </td></tr>
    <tr><td class="paramname">n</td><td>Number of additional columns. </td></tr>
    <tr><td class="paramname">preserve</td><td><em>true</em> if the old values of the matrix should be preserved, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function increases the matrix size by <em>m</em> rows and <em>n</em> columns. During this operation, new dynamic memory may be allocated in case the capacity of the matrix is too small. Therefore this function potentially changes all matrix elements. In order to preserve the old matrix values, the <em>preserve</em> flag can be set to <em>true</em>. However, new matrix elements are not initialized! </p>

</div>
</div>
<a class="anchor" id="a7c0bc293eab8272d1230ae2aebdb2319"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::isAliased </td>
          <td>(</td>
          <td class="paramtype">const Other *&#160;</td>
          <td class="paramname"><em>alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix is aliased with the given address <em>alias</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>The alias to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the alias corresponds to this matrix, <em>false</em> if not.</dd></dl>
<p>This function returns whether the given address is aliased with the matrix. In contrast to the <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a70ff1d579c88bb7c410df99f172d71f5" title="Returns whether the matrix can alias with the given address alias. ">canAlias()</a> function this function is not allowed to use compile time expressions to optimize the evaluation. </p>

</div>
</div>
<a class="anchor" id="a96f0a6d8b96048c7c36842ba49deb531"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::isAligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the matrix is properly aligned in memory. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the matrix is aligned, <em>false</em> if not.</dd></dl>
<p>This function returns whether the matrix is guaranteed to be properly aligned in memory, i.e. whether the beginning and the end of each row/column of the matrix are guaranteed to conform to the alignment restrictions of the element type <em>Type</em>. </p>

</div>
</div>
<a class="anchor" id="a5ba71f59e1379169164f7474385a78cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a9d673389dcc90152922ac6d3424e1889">IntrinsicType</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned load of an intrinsic element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded intrinsic element.</dd></dl>
<p>This function performs an aligned load of a specific intrinsic element of the dense matrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a1c838cea360388e222a1fee43d4c49c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a9d673389dcc90152922ac6d3424e1889">IntrinsicType</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::loadu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unaligned load of an intrinsic element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded intrinsic element.</dd></dl>
<p>This function performs an unaligned load of a specific intrinsic element of the dense matrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a04c9abfeef09771079b9d441c68383ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of non-zero elements in the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements in the dense matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="ac94f2e90f0a5e3d56c1a8b5efb2e16a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::nonZeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of non-zero elements in the specified row/column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of non-zero elements of row/column <em>i</em>.</dd></dl>
<p>This function returns the current number of non-zero elements in the specified row/column. In case the storage order is set to <em>rowMajor</em> the function returns the number of non-zero elements in row <em>i</em>, in case the storage flag is set to <em>columnMajor</em> the function returns the number of non-zero elements in column <em>i</em>. </p>

</div>
</div>
<a class="anchor" id="a73600a6415609a425847c1fe97a5c445"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#afa7716897295045a77922b9016597dd3">Reference</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2D-access to the matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="aa74658d32a5302febab55b1d50857c83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt;::<a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a600d9acc1b695e6e8ee07a1137cfcd5c">ConstReference</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2D-access to the matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range <img class="formulaInl" alt="$[0..M-1]$" src="../../form_53.png"/>. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range <img class="formulaInl" alt="$[0..N-1]$" src="../../form_54.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the accessed value. </dd></dl>

</div>
</div>
<a class="anchor" id="a2004179d794e1113a7309ca806f5d36c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt;Type,SO&gt;&amp; <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication of a matrix ( <img class="formulaInl" alt="$ A*=B $" src="../../form_57.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two given matrices don't match, a <em>std::invalid_argument</em> is thrown. </p>

</div>
</div>
<a class="anchor" id="a53978c88acaed9887e07b8bffe1ba559"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt;Type,SO&gt; &gt;::Type&amp; <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication assignment operator for the multiplication between a matrix and a scalar value ( <img class="formulaInl" alt="$ A*=s $" src="../../form_58.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the multiplication. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a513bcb5f9a40b2fb3d826555bb8f9b86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt;Type,SO&gt;&amp; <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition assignment operator for the addition of a matrix ( <img class="formulaInl" alt="$ A+=B $" src="../../form_55.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix to be added to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a60f94a45a7a30e916933219bef48e47a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt;Type,SO&gt;&amp; <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction assignment operator for the subtraction of a matrix ( <img class="formulaInl" alt="$ A-=B $" src="../../form_56.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side matrix to be subtracted from the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> sizes do not match.</td></tr>
  </table>
  </dd>
</dl>
<p>In case the current sizes of the two matrices don't match, a <em>std::invalid_argument</em> exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ae6feeb5648dd7221670e5bd504ac11ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; <a class="el" href="../../d8/dea/structblaze_1_1IsNumeric.html">IsNumeric</a>&lt;Other&gt;, <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt;Type,SO&gt; &gt;::Type&amp; <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division assignment operator for the division of a matrix by a scalar value ( <img class="formulaInl" alt="$ A/=s $" src="../../form_59.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side scalar value for the division. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="afb94ce0fd105bece71d0dc1a37761bd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp; <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Homogenous assignment to all matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Scalar value to be assigned to all matrix elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="afe89612bf924c148dfe10c80c6382a3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp; <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator for <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html" title="Efficient implementation of a dynamic  matrix.The DynamicMatrix class template is the representation ...">DynamicMatrix</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned matrix.</dd></dl>
<p>The matrix is resized according to the given <img class="formulaInl" alt="$ M \times N $" src="../../form_48.png"/> matrix and initialized as a copy of this matrix. </p>

</div>
</div>
<a class="anchor" id="abacb16e0fa742f3de43f7056d1f612a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename Other , size_t M, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt;Type,SO&gt;&amp; <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Other(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[M][N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array assignment to all matrix elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td><img class="formulaInl" alt="$ M \times N $" src="../../form_48.png"/> dimensional array for the assignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned matrix.</dd></dl>
<p>This assignment operator offers the option to directly set all elements of the matrix:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="../../d2/de9/namespaceblaze.html#a511878ce70095271b6d0dd5b855a9eaa">blaze::rowMajor</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="../../d1/d44/group__config.html#gaa774f520d2b69fe578f63dd8e4ded3a5">real</a> init[3][3] = { { 1, 2, 3 },</div>
<div class="line">                          { 4, 5 },</div>
<div class="line">                          { 7, 8, 9 } };</div>
<div class="line"><a class="code" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix&lt;int,rowMajor&gt;</a> A;</div>
<div class="line">A = init;</div>
</div><!-- fragment --><p>The matrix is resized accoring to the size of the array and assigned the values of the given array. Missing values are initialized with default values (as e.g. the value 6 in the example). </p>

</div>
</div>
<a class="anchor" id="a1826c4a9dab38deedb7961090b38e375"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT , bool SO2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt;Type,SO&gt;&amp; <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">Matrix</a>&lt; MT, SO2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for different matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html" title="Base class for matrices.The Matrix class is a base class for all dense and sparse matrix classes with...">Matrix</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the assigned matrix.</dd></dl>
<p>The matrix is resized according to the given <img class="formulaInl" alt="$ M \times N $" src="../../form_48.png"/> matrix and initialized as a copy of this matrix. </p>

</div>
</div>
<a class="anchor" id="af6a540a2c4c893ac8d4842bbbfd19a61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>&amp; <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">blaze::Matrix</a>&lt; MT, SO &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for non-constant matrices. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference of the actual type of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a71becdce9e44bcba62ee6458c6f5a6fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT, bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> const <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html#a8433a860ba90d8f77df196183ee2891d">MatrixType</a>&amp; <a class="el" href="../../d0/d5c/structblaze_1_1Matrix.html">blaze::Matrix</a>&lt; MT, SO &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator for constant matrices. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant reference of the actual type of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a426ee42e366c0211ecab7dbe4cc9593b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>elements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setting the minimum capacity of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elements</td><td>The new minimum capacity of the dense matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function increases the capacity of the dense matrix to at least <em>elements</em> elements. The current values of the matrix elements are preserved. </p>

</div>
</div>
<a class="anchor" id="aa8e6bf358dca281ce1abfc24c324d985"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset to the default initial values. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a6cd3d6fc1f43f49ef6949106a030d1b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the specified row/column to the default initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the row/column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resets the values in the specified row/column to their default value. In case the storage order is set to <em>rowMajor</em> the function resets the values in row <em>i</em>, in case the storage order is set to <em>columnMajor</em> the function resets the values in column <em>i</em>. Note that the capacity of the row/column remains unchanged. </p>

</div>
</div>
<a class="anchor" id="a12614e6ea64ebee876e22576a7ad1bf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changing the size of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The new number of rows of the matrix. </td></tr>
    <tr><td class="paramname">n</td><td>The new number of columns of the matrix. </td></tr>
    <tr><td class="paramname">preserve</td><td><em>true</em> if the old values of the matrix should be preserved, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function resizes the matrix using the given size to <img class="formulaInl" alt="$ m \times n $" src="../../form_52.png"/>. During this operation, new dynamic memory may be allocated in case the capacity of the matrix is too small. Note that this function may invalidate all existing views (submatrices, rows, columns, ...) on the matrix if it is used to shrink the matrix. Additionally, the resize operation potentially changes all matrix elements. In order to preserve the old matrix values, the <em>preserve</em> flag can be set to <em>true</em>. However, new matrix elements are not initialized!</p>
<p>The following example illustrates the resize operation of a <img class="formulaInl" alt="$ 2 \times 4 $" src="../../form_60.png"/> matrix to a <img class="formulaInl" alt="$ 4 \times 2 $" src="../../form_61.png"/> matrix. The new, uninitialized elements are marked with <em>x:</em> </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left(\begin{array}{*{4}{c}} 1 &amp; 2 &amp; 3 &amp; 4 \\ 5 &amp; 6 &amp; 7 &amp; 8 \\ \end{array}\right) \Longrightarrow \left(\begin{array}{*{2}{c}} 1 &amp; 2 \\ 5 &amp; 6 \\ x &amp; x \\ x &amp; x \\ \end{array}\right) \]" src="../../form_62.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="a28b7d5dd5032bb82f553b17c75b80430"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current number of rows of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of rows of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b4e85d1c8320a8a2257cf42d7aa8943"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt;Type,SO&gt;&amp; <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scaling of the matrix by the scalar value <em>scalar</em> ( <img class="formulaInl" alt="$ A=B*s $" src="../../form_63.png"/>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value for the matrix scaling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="ac667836fd3212bfcb1577cac94285e7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::spacing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the spacing between the beginning of two rows/columns. </p>
<dl class="section return"><dt>Returns</dt><dd>The spacing between the beginning of two rows/columns.</dd></dl>
<p>This function returns the spacing between the beginning of two rows/columns, i.e. the total number of elements of a row/column. In case the storage order is set to <em>rowMajor</em> the function returns the spacing between two rows, in case the storage flag is set to <em>columnMajor</em> the function returns the spacing between two columns. </p>

</div>
</div>
<a class="anchor" id="a3c36b7b0dc1c284b9640ad0ab85742e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a9d673389dcc90152922ac6d3424e1889">IntrinsicType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned store of an intrinsic element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
    <tr><td class="paramname">value</td><td>The intrinsic element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an aligned store of a specific intrinsic element of the dense matrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a579c7e521f0e5005d0ca849610fd105b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::storeu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a9d673389dcc90152922ac6d3424e1889">IntrinsicType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unaligned store of an intrinsic element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
    <tr><td class="paramname">value</td><td>The intrinsic element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an unaligned store of a specific intrinsic element of the dense matrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a268c13d173164fbd6102e81c3574d23c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d37/group__system.html#ga414fb20bc543f1b920b6599c9b63a23a">BLAZE_ALWAYS_INLINE</a> void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html#a9d673389dcc90152922ac6d3424e1889">IntrinsicType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligned, non-temporal store of an intrinsic element of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Access index for the row. The index has to be in the range [0..M-1]. </td></tr>
    <tr><td class="paramname">j</td><td>Access index for the column. The index has to be in the range [0..N-1]. </td></tr>
    <tr><td class="paramname">value</td><td>The intrinsic element to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function performs an aligned, non-temporal store of a specific intrinsic element of the dense matrix. The row index must be smaller than the number of rows and the column index must be smaller than the number of columns. Additionally, the column index (in case of a row-major matrix) or the row index (in case of a column-major matrix) must be a multiple of the number of values inside the intrinsic element. This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. </p>

</div>
</div>
<a class="anchor" id="a98b0ec850297d0caf27b49c259944d2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a column-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a88af9bdb6974b2d3fb1337a780ac61fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a row-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a6cdc0ffbad87fc3d812b051cb99c70e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d5d/structblaze_1_1SparseMatrix.html">SparseMatrix</a>&lt; MT,!SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a column-major sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side sparse matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="ab1a8451b75566cffe1e2cdb19208948c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d36/structblaze_1_1DisableIf.html">DisableIf</a>&lt; typename <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt;Type,SO&gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt;MT&gt; &gt;::Type <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the subtraction assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a1ac2708b713a15feb121883d81569227"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool SO = defaultStorageOrder&gt; </div>
<div class="memtemplate">
template&lt;typename MT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d28/structblaze_1_1EnableIf.html">EnableIf</a>&lt; typename <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt;Type,SO&gt;::BLAZE_TEMPLATE VectorizedSubAssign&lt;MT&gt; &gt;::Type <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::subAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d89/structblaze_1_1DenseMatrix.html">DenseMatrix</a>&lt; MT, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intrinsic optimized implementation of the subtraction assignment of a row-major dense matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side dense matrix to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function must <b>NOT</b> be called explicitly! It is used internally for the performance optimized evaluation of expression templates. Calling this function explicitly might result in erroneous results and/or in compilation errors. Instead of using this function use the assignment operator. </p>

</div>
</div>
<a class="anchor" id="a6d0a7281d8f49fff213113e5f1dd418c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swapping the contents of two matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to be swapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">no-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af891916acbfc3ad5caa7f38efe6a6fbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , bool SO&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">DynamicMatrix</a>&lt; Type, SO &gt; &amp; <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transposing the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the transposed matrix. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a4c09cd12716cef8b79831c6a77c2628e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type, bool SO = defaultStorageOrder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* <a class="el" href="../../d4/d37/group__system.html#gaeb7809d70987fc2dbe69c2fea852d797">BLAZE_RESTRICT</a> <a class="el" href="../../de/d1e/classblaze_1_1DynamicMatrix.html">blaze::DynamicMatrix</a>&lt; Type, SO &gt;::v_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The dynamically allocated matrix elements. </p>
<p>Access to the matrix elements is gained via the subscript or function call operator. In case of row-major order the memory layout of the elements is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\left(\begin{array}{*{5}{c}} 0 &amp; 1 &amp; 2 &amp; \cdots &amp; N-1 \\ N &amp; N+1 &amp; N+2 &amp; \cdots &amp; 2 \cdot N-1 \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ M \cdot N-N &amp; M \cdot N-N+1 &amp; M \cdot N-N+2 &amp; \cdots &amp; M \cdot N-1 \\ \end{array}\right)\]" src="../../form_64.png"/>
</p>
<p>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>blaze/math/dense/<a class="el" href="../../db/d2d/dense_2DynamicMatrix_8h_source.html">DynamicMatrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:55:24 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
