<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>blaze::ThreadPool&lt; TT, MT, LT, CT &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/de9/namespaceblaze.html">blaze</a></li><li class="navelem"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">ThreadPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pri-types">Private Types</a> &#124;
<a href="../../d8/d0d/classblaze_1_1ThreadPool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blaze::ThreadPool&lt; TT, MT, LT, CT &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../d4/d3a/group__util.html">Utility module</a> &raquo; <a class="el" href="../../d2/db9/group__threads.html">Thread parallelization</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of a thread pool.  
 <a href="../../db/d38/classblaze_1_1ThreadPool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d3/d43/ThreadPool_8h_source.html">ThreadPool.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="../../dd/dbc/classblaze_1_1NonCopyable.html">blaze::NonCopyable</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor</div></td></tr>
<tr class="memitem:a5fb200ed35908231bba1d72a71c78c17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a5fb200ed35908231bba1d72a71c78c17">ThreadPool</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n)</td></tr>
<tr class="memdesc:a5fb200ed35908231bba1d72a71c78c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class.  <a href="#a5fb200ed35908231bba1d72a71c78c17">More...</a><br /></td></tr>
<tr class="separator:a5fb200ed35908231bba1d72a71c78c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a8dd5edaab373a5115f1570d8dcacfc00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a8dd5edaab373a5115f1570d8dcacfc00">~ThreadPool</a> ()</td></tr>
<tr class="memdesc:a8dd5edaab373a5115f1570d8dcacfc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class.  <a href="#a8dd5edaab373a5115f1570d8dcacfc00">More...</a><br /></td></tr>
<tr class="separator:a8dd5edaab373a5115f1570d8dcacfc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get functions</div></td></tr>
<tr class="memitem:a6fadeb0b297815e4d7e1c21dae1ac05b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a6fadeb0b297815e4d7e1c21dae1ac05b">isEmpty</a> () const </td></tr>
<tr class="memdesc:a6fadeb0b297815e4d7e1c21dae1ac05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether any tasks are scheduled for execution.  <a href="#a6fadeb0b297815e4d7e1c21dae1ac05b">More...</a><br /></td></tr>
<tr class="separator:a6fadeb0b297815e4d7e1c21dae1ac05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ebd2bf56c7a1914686218c303fc4e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a87ebd2bf56c7a1914686218c303fc4e1">size</a> () const </td></tr>
<tr class="memdesc:a87ebd2bf56c7a1914686218c303fc4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size of the thread pool.  <a href="#a87ebd2bf56c7a1914686218c303fc4e1">More...</a><br /></td></tr>
<tr class="separator:a87ebd2bf56c7a1914686218c303fc4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4029694886202650a2fd95af42387409"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a4029694886202650a2fd95af42387409">active</a> () const </td></tr>
<tr class="memdesc:a4029694886202650a2fd95af42387409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of currently active/busy threads.  <a href="#a4029694886202650a2fd95af42387409">More...</a><br /></td></tr>
<tr class="separator:a4029694886202650a2fd95af42387409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0f92696a423d68446a634ab30d5b60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a5f0f92696a423d68446a634ab30d5b60">ready</a> () const </td></tr>
<tr class="memdesc:a5f0f92696a423d68446a634ab30d5b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of currently ready/inactive threads.  <a href="#a5f0f92696a423d68446a634ab30d5b60">More...</a><br /></td></tr>
<tr class="separator:a5f0f92696a423d68446a634ab30d5b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scheduling functions</div></td></tr>
<tr class="memitem:a2c654f88916b7a62f90d017fdf37fa32"><td class="memTemplParams" colspan="2">template&lt;typename Callable &gt; </td></tr>
<tr class="memitem:a2c654f88916b7a62f90d017fdf37fa32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a2c654f88916b7a62f90d017fdf37fa32">schedule</a> (Callable func)</td></tr>
<tr class="memdesc:a2c654f88916b7a62f90d017fdf37fa32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling the given zero argument function/functor for execution.  <a href="#a2c654f88916b7a62f90d017fdf37fa32">More...</a><br /></td></tr>
<tr class="separator:a2c654f88916b7a62f90d017fdf37fa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26fc610a1d0570d8515cec3ac75e0b9"><td class="memTemplParams" colspan="2">template&lt;typename Callable , typename A1 &gt; </td></tr>
<tr class="memitem:ae26fc610a1d0570d8515cec3ac75e0b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#ae26fc610a1d0570d8515cec3ac75e0b9">schedule</a> (Callable func, A1 a1)</td></tr>
<tr class="memdesc:ae26fc610a1d0570d8515cec3ac75e0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling the given unary function/functor for execution.  <a href="#ae26fc610a1d0570d8515cec3ac75e0b9">More...</a><br /></td></tr>
<tr class="separator:ae26fc610a1d0570d8515cec3ac75e0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc30f86447e611725b8215af21a4b5ed"><td class="memTemplParams" colspan="2">template&lt;typename Callable , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:adc30f86447e611725b8215af21a4b5ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#adc30f86447e611725b8215af21a4b5ed">schedule</a> (Callable func, A1 a1, A2 a2)</td></tr>
<tr class="memdesc:adc30f86447e611725b8215af21a4b5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling the given binary function/functor for execution.  <a href="#adc30f86447e611725b8215af21a4b5ed">More...</a><br /></td></tr>
<tr class="separator:adc30f86447e611725b8215af21a4b5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a53abfbecdada61334c1d498582138"><td class="memTemplParams" colspan="2">template&lt;typename Callable , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ad8a53abfbecdada61334c1d498582138"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#ad8a53abfbecdada61334c1d498582138">schedule</a> (Callable func, A1 a1, A2 a2, A3 a3)</td></tr>
<tr class="memdesc:ad8a53abfbecdada61334c1d498582138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling the given ternary function/functor for execution.  <a href="#ad8a53abfbecdada61334c1d498582138">More...</a><br /></td></tr>
<tr class="separator:ad8a53abfbecdada61334c1d498582138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd76cba634d3455bda2f02c1416f241"><td class="memTemplParams" colspan="2">template&lt;typename Callable , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:a4fd76cba634d3455bda2f02c1416f241"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a4fd76cba634d3455bda2f02c1416f241">schedule</a> (Callable func, A1 a1, A2 a2, A3 a3, A4 a4)</td></tr>
<tr class="memdesc:a4fd76cba634d3455bda2f02c1416f241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling the given four argument function/functor for execution.  <a href="#a4fd76cba634d3455bda2f02c1416f241">More...</a><br /></td></tr>
<tr class="separator:a4fd76cba634d3455bda2f02c1416f241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee593e98c60a6f810119b5048a53feb"><td class="memTemplParams" colspan="2">template&lt;typename Callable , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 &gt; </td></tr>
<tr class="memitem:aeee593e98c60a6f810119b5048a53feb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#aeee593e98c60a6f810119b5048a53feb">schedule</a> (Callable func, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)</td></tr>
<tr class="memdesc:aeee593e98c60a6f810119b5048a53feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling the given four argument function/functor for execution.  <a href="#aeee593e98c60a6f810119b5048a53feb">More...</a><br /></td></tr>
<tr class="separator:aeee593e98c60a6f810119b5048a53feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility functions</div></td></tr>
<tr class="memitem:a4d1b06119db318de012cf4c6c14b9a2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a4d1b06119db318de012cf4c6c14b9a2c">resize</a> (<a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> n, bool block=false)</td></tr>
<tr class="memdesc:a4d1b06119db318de012cf4c6c14b9a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the total number of threads in the thread pool.  <a href="#a4d1b06119db318de012cf4c6c14b9a2c">More...</a><br /></td></tr>
<tr class="separator:a4d1b06119db318de012cf4c6c14b9a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad975aab73f0d27c5589240bd1a4a70c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#ad975aab73f0d27c5589240bd1a4a70c1">wait</a> ()</td></tr>
<tr class="memdesc:ad975aab73f0d27c5589240bd1a4a70c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waiting for all scheduled tasks to be completed.  <a href="#ad975aab73f0d27c5589240bd1a4a70c1">More...</a><br /></td></tr>
<tr class="separator:ad975aab73f0d27c5589240bd1a4a70c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca70662b512933582f801b0f94a6145"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a0ca70662b512933582f801b0f94a6145">clear</a> ()</td></tr>
<tr class="memdesc:a0ca70662b512933582f801b0f94a6145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removing all scheduled tasks from the thread pool.  <a href="#a0ca70662b512933582f801b0f94a6145">More...</a><br /></td></tr>
<tr class="separator:a0ca70662b512933582f801b0f94a6145"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ae26969bacded05d0cc4f03b1ddfb8a2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae26969bacded05d0cc4f03b1ddfb8a2e"></a>
typedef <a class="el" href="../../de/d7d/classblaze_1_1Thread.html">Thread</a>&lt; TT, MT, LT, CT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#ae26969bacded05d0cc4f03b1ddfb8a2e">ManagedThread</a></td></tr>
<tr class="memdesc:ae26969bacded05d0cc4f03b1ddfb8a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the managed threads. <br /></td></tr>
<tr class="separator:ae26969bacded05d0cc4f03b1ddfb8a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bb78134ac4e04e68ee7c8073db89d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77bb78134ac4e04e68ee7c8073db89d3"></a>
typedef <a class="el" href="../../d3/ddf/classblaze_1_1PtrVector.html">PtrVector</a>&lt; <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#ae26969bacded05d0cc4f03b1ddfb8a2e">ManagedThread</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a77bb78134ac4e04e68ee7c8073db89d3">Threads</a></td></tr>
<tr class="memdesc:a77bb78134ac4e04e68ee7c8073db89d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the thread container. <br /></td></tr>
<tr class="separator:a77bb78134ac4e04e68ee7c8073db89d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a531ec419eb2f1cae7d963e77f86974"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a531ec419eb2f1cae7d963e77f86974"></a>
typedef <a class="el" href="../../db/dee/classblaze_1_1threadpool_1_1TaskQueue.html">threadpool::TaskQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a8a531ec419eb2f1cae7d963e77f86974">TaskQueue</a></td></tr>
<tr class="memdesc:a8a531ec419eb2f1cae7d963e77f86974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the task queue. <br /></td></tr>
<tr class="separator:a8a531ec419eb2f1cae7d963e77f86974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db3de2d49f2dad56ffc4a28b167d1b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9db3de2d49f2dad56ffc4a28b167d1b6"></a>
typedef MT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a9db3de2d49f2dad56ffc4a28b167d1b6">Mutex</a></td></tr>
<tr class="memdesc:a9db3de2d49f2dad56ffc4a28b167d1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the mutex. <br /></td></tr>
<tr class="separator:a9db3de2d49f2dad56ffc4a28b167d1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c866ad0a86e34d07100d6757cc6e09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69c866ad0a86e34d07100d6757cc6e09"></a>
typedef LT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a69c866ad0a86e34d07100d6757cc6e09">Lock</a></td></tr>
<tr class="memdesc:a69c866ad0a86e34d07100d6757cc6e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a locking object. <br /></td></tr>
<tr class="separator:a69c866ad0a86e34d07100d6757cc6e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472cb4f8fa498c8b992e60798811e6df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a472cb4f8fa498c8b992e60798811e6df"></a>
typedef CT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a472cb4f8fa498c8b992e60798811e6df">Condition</a></td></tr>
<tr class="memdesc:a472cb4f8fa498c8b992e60798811e6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variable type. <br /></td></tr>
<tr class="separator:a472cb4f8fa498c8b992e60798811e6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Thread functions</div></td></tr>
<tr class="memitem:a52bdd2b2de4bc83bbab6ec3fc4c4b446"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a52bdd2b2de4bc83bbab6ec3fc4c4b446">createThread</a> ()</td></tr>
<tr class="memdesc:a52bdd2b2de4bc83bbab6ec3fc4c4b446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adding a new thread to the thread pool.  <a href="#a52bdd2b2de4bc83bbab6ec3fc4c4b446">More...</a><br /></td></tr>
<tr class="separator:a52bdd2b2de4bc83bbab6ec3fc4c4b446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa419ce260788be0f424c21357ef3a372"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#aa419ce260788be0f424c21357ef3a372">executeTask</a> ()</td></tr>
<tr class="memdesc:aa419ce260788be0f424c21357ef3a372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executing a scheduled task.  <a href="#aa419ce260788be0f424c21357ef3a372">More...</a><br /></td></tr>
<tr class="separator:aa419ce260788be0f424c21357ef3a372"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member variables</div></td></tr>
<tr class="memitem:a78a01b52bae227450d824155c942f680"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78a01b52bae227450d824155c942f680"></a>
volatile <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a78a01b52bae227450d824155c942f680">total_</a></td></tr>
<tr class="memdesc:a78a01b52bae227450d824155c942f680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of threads in the thread pool. <br /></td></tr>
<tr class="separator:a78a01b52bae227450d824155c942f680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d2457237fa6fc84b3facc75c2fcf06"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a30d2457237fa6fc84b3facc75c2fcf06">expected_</a></td></tr>
<tr class="memdesc:a30d2457237fa6fc84b3facc75c2fcf06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected number of threads in the thread pool.  <a href="#a30d2457237fa6fc84b3facc75c2fcf06">More...</a><br /></td></tr>
<tr class="separator:a30d2457237fa6fc84b3facc75c2fcf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9565cb0631f2048ee11dd58d24eb7c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9565cb0631f2048ee11dd58d24eb7c2"></a>
volatile <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#af9565cb0631f2048ee11dd58d24eb7c2">active_</a></td></tr>
<tr class="memdesc:af9565cb0631f2048ee11dd58d24eb7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of currently active/busy threads. <br /></td></tr>
<tr class="separator:af9565cb0631f2048ee11dd58d24eb7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b496a652c11d25fdf4ca12353795231"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b496a652c11d25fdf4ca12353795231"></a>
<a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a77bb78134ac4e04e68ee7c8073db89d3">Threads</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a2b496a652c11d25fdf4ca12353795231">threads_</a></td></tr>
<tr class="memdesc:a2b496a652c11d25fdf4ca12353795231"><td class="mdescLeft">&#160;</td><td class="mdescRight">The threads contained in the thread pool. <br /></td></tr>
<tr class="separator:a2b496a652c11d25fdf4ca12353795231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be88b93495267d9ac83617028a7056f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9be88b93495267d9ac83617028a7056f"></a>
<a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a8a531ec419eb2f1cae7d963e77f86974">TaskQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a9be88b93495267d9ac83617028a7056f">taskqueue_</a></td></tr>
<tr class="memdesc:a9be88b93495267d9ac83617028a7056f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task queue for the scheduled tasks. <br /></td></tr>
<tr class="separator:a9be88b93495267d9ac83617028a7056f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d23882a696a765b705172e0ac29dfd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d23882a696a765b705172e0ac29dfd5"></a>
<a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a9db3de2d49f2dad56ffc4a28b167d1b6">Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a5d23882a696a765b705172e0ac29dfd5">mutex_</a></td></tr>
<tr class="memdesc:a5d23882a696a765b705172e0ac29dfd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronization mutex. <br /></td></tr>
<tr class="separator:a5d23882a696a765b705172e0ac29dfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8eda15c6f40531ae60b43ed8e346e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf8eda15c6f40531ae60b43ed8e346e5"></a>
<a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a472cb4f8fa498c8b992e60798811e6df">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#adf8eda15c6f40531ae60b43ed8e346e5">waitForTask_</a></td></tr>
<tr class="memdesc:adf8eda15c6f40531ae60b43ed8e346e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait condition for idle threads. <br /></td></tr>
<tr class="separator:adf8eda15c6f40531ae60b43ed8e346e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3421ba3c7930fdc19fb1c5cff7e5d6e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3421ba3c7930fdc19fb1c5cff7e5d6e5"></a>
<a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a472cb4f8fa498c8b992e60798811e6df">Condition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a3421ba3c7930fdc19fb1c5cff7e5d6e5">waitForThread_</a></td></tr>
<tr class="memdesc:a3421ba3c7930fdc19fb1c5cff7e5d6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait condition for the thread management. <br /></td></tr>
<tr class="separator:a3421ba3c7930fdc19fb1c5cff7e5d6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TT, typename MT, typename LT, typename CT&gt;<br />
class blaze::ThreadPool&lt; TT, MT, LT, CT &gt;</h3>

<p>Implementation of a thread pool. </p>
<h1><a class="anchor" id="threadpool_general"></a>
General</h1>
<p>The <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class template represents a thread pool according to the thread pool pattern (see for example <a href="http://en.wikipedia.org/wiki/Thread_pool_pattern">http://en.wikipedia.org/wiki/Thread_pool_pattern</a>). It manages a certain number of threads in order to process a larger number of independent tasks.</p>
<div class="image">
<img src="../../threadpool.png" alt="threadpool.png"/>
</div>
 <p>The primary purpose of a thread pool is the reuse of system resources: instead of creating a single thread for every individual task, threads are reused to handle several tasks. This increases the performance in comparison to different threading strategies, as illustrated in the graph below. The first bar indicates the sequential performance of 1000 matrix-matrix multiplications of arbitrarily sized square matrices. The second bar shows the performance of the same work performed by 1000 distinct threads (i.e. one thread for each matrix-matrix multiplication) on a quad-core system. In this case, all cores of the system can be used, but the additional overhead of creating and managing new threads prevents the expected performance increase by a factor of four. The third bar illustrates the performance of four threads distributing the work between them (i.e. 250 matrix-matrix multiplications per thread), again using the same quad-core system. This approach nearly achieves four times the performance of the sequential execution. The fourth bar represents the performance of the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class using fourth threads for the execution of the 1000 individual multiplications.</p>
<div class="image">
<img src="../../threadpool2.png" alt="threadpool2.png"/>
</div>
 <p>Additionally, the thread pool approach simplifies load balancing and increases the stability of the system.</p>
<h1><a class="anchor" id="threadpool_definition"></a>
Class Definition</h1>
<p>The implementation of the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class template is based on the implementation of standard thread functionality as provided by the C++11 standard or the Boost library. Via the four template parameters it is possible to configure a <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> instance as either a C++11 thread pool or as Boost thread pool:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> TT, <span class="keyword">typename</span> MT, <span class="keyword">typename</span> LT, <span class="keyword">typename</span> CT &gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="../../db/d38/classblaze_1_1ThreadPool.html#a5fb200ed35908231bba1d72a71c78c17">ThreadPool</a>;</div>
</div><!-- fragment --><ul>
<li>TT: specifies the type of the encapsulated thread. This can either be <code>std::thread</code>, <code>boost::thread</code>, or any other standard conforming thread type.</li>
<li>MT: specifies the type of the used synchronization mutex. This can for instance be <code>std::mutex</code>, <code>boost::mutex</code>, or any other standard conforming mutex type.</li>
<li>LT: specifies the type of lock used in combination with the given mutex type. This can be any standard conforming lock type, as for instance <code>std::unique_lock</code>, <code>boost::unique_lock</code>.</li>
<li>CT: specifies the type of the used condition variable. This can for instance be <code>std::condition_variable</code>, <code>boost::condition_variable</code>, or any other standard conforming condition variable type.</li>
</ul>
<p>The following example demonstrates how to configure the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class template as either C++11 standard thread pool or as Boost thread pool:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; boost::thread</div>
<div class="line">                         , boost::mutex</div>
<div class="line">                         , boost::unique_lock&lt;boost::mutex&gt;</div>
<div class="line">                         , boost::condition_variable &gt;  BoostThreadPool;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; std::thread</div>
<div class="line">                         , std::mutex</div>
<div class="line">                         , std::unique_lock&lt;std::mutex&gt;</div>
<div class="line">                         , std::condition_variable &gt;  StdThreadPool;</div>
</div><!-- fragment --><p>For more information about the standard thread functionality, see [1] or [2] or the current documentation at the Boost homepage: www.boost.org.</p>
<h1><a class="anchor" id="threadpool_setup"></a>
Using the ThreadPool class</h1>
<p>The following example demonstrates the use of the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class. In contrast to the setup of individual threads (see the <a class="el" href="../../de/d7d/classblaze_1_1Thread.html" title="Implementation of a single thread of execution. ">Thread</a> class description for more details), it is not necessary to create and manage individual threads, but only to schedules tasks for the accordingly sized thread pool.</p>
<div class="fragment"><div class="line"><span class="comment">// Definition of a function with no arguments that returns void</span></div>
<div class="line"><span class="keywordtype">void</span> function0() { ... }</div>
<div class="line"></div>
<div class="line"><span class="comment">// Definition of a functor (function object) taking two arguments and returning void</span></div>
<div class="line"><span class="keyword">struct </span>Functor2</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">void</span> operator()( <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b ) { ... }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Creating a thread pool with initially two working threads</span></div>
<div class="line">   StdThreadPool threadpool( 2 );</div>
<div class="line"></div>
<div class="line">   <span class="comment">// Scheduling two concurrent tasks</span></div>
<div class="line">   threadpool.schedule( function0 );</div>
<div class="line">   threadpool.schedule( Functor2(), 4, 6 );</div>
<div class="line"></div>
<div class="line">   <span class="comment">// Waiting for the thread pool to complete both tasks</span></div>
<div class="line">   threadpool.wait();</div>
<div class="line"></div>
<div class="line">   <span class="comment">// Resizing the thread pool to four working threads</span></div>
<div class="line">   threadpool.resize( 4 );</div>
<div class="line"></div>
<div class="line">   <span class="comment">// Scheduling other concurrent tasks</span></div>
<div class="line">   ...</div>
<div class="line">   threadpool.schedule( function0 );</div>
<div class="line">   ...</div>
<div class="line"></div>
<div class="line">   <span class="comment">// At the end of the thread pool scope, all tasks remaining in the task queue are removed</span></div>
<div class="line">   <span class="comment">// and all currently running tasks are completed. Additionally, all acquired resources are</span></div>
<div class="line">   <span class="comment">// safely released.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class template <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html#a2c654f88916b7a62f90d017fdf37fa32" title="Scheduling the given zero argument function/functor for execution. ">schedule()</a> function allows for up to five arguments for the given functions/functors.</p>
<h1><a class="anchor" id="threadpool_exception"></a>
Throwing exceptions in a thread parallel environment</h1>
<p>It can happen that during the execution of a given task a thread encounters an erroneous situation and has to throw an exception. However, exceptions thrown in the usual way cannot be caught by a try-catch-block in the main thread of execution:</p>
<div class="fragment"><div class="line"><span class="comment">// Definition of a function throwing a std::runtime_error during its execution</span></div>
<div class="line"><span class="keywordtype">void</span> task()</div>
<div class="line">{</div>
<div class="line">   ...</div>
<div class="line">   <span class="keywordflow">throw</span> std::runtime_error( ... );</div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating a thread pool executing the throwing function. Although the setup, the scheduling</span></div>
<div class="line"><span class="comment">// of the task, the wait() function and the destruction of the thread pool are encapsuled</span></div>
<div class="line"><span class="comment">// inside a try-catch-block, the exception cannot be caught and results in an abortion of the</span></div>
<div class="line"><span class="comment">// program.</span></div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">   StdThreadpool threadpool( 2 );</div>
<div class="line">   thread.schedule( task );</div>
<div class="line">   threadpool.wait();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>( ... )</div>
<div class="line">{</div>
<div class="line">   ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>For a detailed explanation how to portably transport exceptions between threads, see [1] or [2]. In case of the Boost library, the according Boost functionality as demonstrated in the following example has to be used. Note that any function/functor scheduled for execution is responsible to handle exceptions in this way!</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/bind.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/exception_ptr.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Definition of a function that happens to throw an exception. In order to throw the</span></div>
<div class="line"><span class="comment">// exception, boost::enable_current_exception() is used in combination with throw.</span></div>
<div class="line"><span class="keywordtype">void</span> throwException()</div>
<div class="line">{</div>
<div class="line">   ...</div>
<div class="line">   <span class="keywordflow">throw</span> boost::enable_current_exception( std::runtime_error( ... ) );</div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Definition of a thread function. The try-catch-block catches the exception and uses the</span></div>
<div class="line"><span class="comment">// boost::current_exception() function to get a boost::exception_ptr object.</span></div>
<div class="line"><span class="keywordtype">void</span> task( boost::exception_ptr&amp; error )</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">try</span> {</div>
<div class="line">      throwException();</div>
<div class="line">      error = boost::exception_ptr();</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">catch</span>( ... ) {</div>
<div class="line">      error = boost::current_exception();</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// The function that start a thread of execution can pass along a boost::exception_ptr object</span></div>
<div class="line"><span class="comment">// that is set in case of an exception. Note that boost::current_exception() captures the</span></div>
<div class="line"><span class="comment">// original type of the exception object. The exception can be thrown again using the</span></div>
<div class="line"><span class="comment">// boost::rethrow_exception() function.</span></div>
<div class="line"><span class="keywordtype">void</span> work()</div>
<div class="line">{</div>
<div class="line">   boost::exception_ptr <a class="code" href="../../d8/dff/group__logging.html#gga7a7b703a7e8bec28aec7c92150184856a85df92226733b03810e0e4e7968a17b1">error</a>;</div>
<div class="line"></div>
<div class="line">   StdThreadPool threadpool( 2 );</div>
<div class="line">   threadpool.schedule( boost::bind( task, boost::ref(error) ) );</div>
<div class="line">   threadpool.wait();</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span>( error ) {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot; Exception during thread execution!\n\n&quot;</span>;</div>
<div class="line">      boost::rethrow_exception( error );</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="threadpool_known_issues"></a>
Known issues</h1>
<p>There is a known issue in Visual Studio 2012 and 2013 that may cause C++11 threads to hang if their destructor is executed after the <code>main()</code> function:</p>
<p><a href="http://connect.microsoft.com/VisualStudio/feedback/details/747145">http://connect.microsoft.com/VisualStudio/feedback/details/747145</a></p>
<p>In order to circumvent this problem, for Visual Studio compilers only, it is possible to explicitly resize a <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> instance to 0 threads and to block until all threads have been destroyed:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   <span class="keyword">static</span> StdThreadPool threadpool( 4 );</div>
<div class="line"></div>
<div class="line">   <span class="comment">// ... Using the thread pool</span></div>
<div class="line"></div>
<div class="line">   threadpool( 0, <span class="keyword">true</span> );</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that this should ONLY be used before the end of the <code>main()</code> function and ONLY if the threadpool will not be used anymore.</p>
<h1><a class="anchor" id="threadpool_references"></a>
References</h1>
<p>[1] A. Williams: C++ Concurrency in Action, Manning, 2012, ISBN: 978-1933988771<br />
[2] B. Stroustrup: The C++ Programming Language, Addison-Wesley, 2013, ISBN: 978-0321563842<br />
</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5fb200ed35908231bba1d72a71c78c17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::<a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">ThreadPool</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Initial number of threads <img class="formulaInl" alt="$[1..\infty)$" src="../../form_140.png"/>.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor creates a thread pool with initially <em>n</em> new threads. All threads are initially idle until a task is scheduled. </p>

</div>
</div>
<a class="anchor" id="a8dd5edaab373a5115f1570d8dcacfc00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::~<a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">ThreadPool</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor for the <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> class. </p>
<p>The destructor clears all remaining tasks from the task queue and waits for the currently active threads to complete their tasks. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4029694886202650a2fd95af42387409"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of currently active/busy threads. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of currently active threads. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ca70662b512933582f801b0f94a6145"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removing all scheduled tasks from the thread pool. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function removes all currently scheduled tasks from the thread pool. The total number of threads remains unchanged and all active threads continue completing their tasks. </p>

</div>
</div>
<a class="anchor" id="a52bdd2b2de4bc83bbab6ec3fc4c4b446"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::createThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adding a new thread to the thread pool. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="aa419ce260788be0f424c21357ef3a372"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::executeTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executing a scheduled task. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case a task was successfully finished, <em>false</em> if not.</dd></dl>
<p>This function is repeatedly called by every thread to execute one of the scheduled tasks. In case there is no task available, the thread blocks and waits for a new task to be scheduled. </p>

</div>
</div>
<a class="anchor" id="a6fadeb0b297815e4d7e1c21dae1ac05b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether any tasks are scheduled for execution. </p>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case task are scheduled, <em>false</em> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f0f92696a423d68446a634ab30d5b60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of currently ready/inactive threads. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of currently ready threads. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d1b06119db318de012cf4c6c14b9a2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the total number of threads in the thread pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The new number of threads <img class="formulaInl" alt="$[1..\infty)$" src="../../form_140.png"/>. </td></tr>
    <tr><td class="paramname">block</td><td><em>true</em> if the function shall block, <em>false</em> if not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>Invalid number of threads.</td></tr>
  </table>
  </dd>
</dl>
<p>This function changes the size of the thread pool, i.e. changes the total number of threads contained in the pool. <a class="el" href="../../d7/d0c/structblaze_1_1If.html" title="Compile time type selection.The If class template selects one of the two given types T2 and T3 depend...">If</a> <em>n</em> is smaller than the current size of the thread pool, the according number of threads is removed from the pool, otherwise new threads are added to the pool. Via the <em>block</em> flag it is possible to block the function until the desired number of threads is available.</p>
<p>Note that there is a known issue in Visual Studio 2012 and 2013 that may cause C++11 threads to hang if their destructor is executed after the <code>main()</code> function:</p>
<p><a href="http://connect.microsoft.com/VisualStudio/feedback/details/747145">http://connect.microsoft.com/VisualStudio/feedback/details/747145</a></p>
<p>In order to circumvent this problem, for Visual Studio compilers only, it is possible to explicitly resize a <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html" title="Implementation of a thread pool. ">ThreadPool</a> instance to 0 threads and to block until all threads have been destroyed:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   <span class="keyword">static</span> <a class="code" href="../../db/d38/classblaze_1_1ThreadPool.html#a5fb200ed35908231bba1d72a71c78c17">ThreadPool</a>&lt; std::thread</div>
<div class="line">                    , std::mutex</div>
<div class="line">                    , std::unique_lock&lt; std::mutex &gt;</div>
<div class="line">                    , std::condition_variable &gt; threadpool( 4 );</div>
<div class="line"></div>
<div class="line">   <span class="comment">// ... Using the thread pool</span></div>
<div class="line"></div>
<div class="line">   threadpool( 0, <span class="keyword">true</span> );</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that this should ONLY be used before the end of the <code>main()</code> function and ONLY if the threadpool will not be used anymore. </p>

</div>
</div>
<a class="anchor" id="a2c654f88916b7a62f90d017fdf37fa32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<div class="memtemplate">
template&lt;typename Callable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::schedule </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling the given zero argument function/functor for execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The given function/functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function schedules the given function/functor for execution. The given function/functor must be copyable, must be callable without arguments and must return void. </p>

</div>
</div>
<a class="anchor" id="ae26fc610a1d0570d8515cec3ac75e0b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<div class="memtemplate">
template&lt;typename Callable , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::schedule </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling the given unary function/functor for execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The given function/functor. </td></tr>
    <tr><td class="paramname">a1</td><td>The first argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function schedules the given function/functor for execution. The given function/functor must be copyable, must be callable with one argument and must return void. </p>

</div>
</div>
<a class="anchor" id="adc30f86447e611725b8215af21a4b5ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<div class="memtemplate">
template&lt;typename Callable , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::schedule </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling the given binary function/functor for execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The given function/functor. </td></tr>
    <tr><td class="paramname">a1</td><td>The first argument. </td></tr>
    <tr><td class="paramname">a2</td><td>The second argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function schedules the given function/functor for execution. The given function/functor must be copyable, must be callable with two arguments and must return void. </p>

</div>
</div>
<a class="anchor" id="ad8a53abfbecdada61334c1d498582138"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<div class="memtemplate">
template&lt;typename Callable , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::schedule </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&#160;</td>
          <td class="paramname"><em>a3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling the given ternary function/functor for execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The given function/functor. </td></tr>
    <tr><td class="paramname">a1</td><td>The first argument. </td></tr>
    <tr><td class="paramname">a2</td><td>The second argument. </td></tr>
    <tr><td class="paramname">a3</td><td>The third argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function schedules the given function/functor for execution. The given function/functor must be copyable, must be callable with three arguments and must return void. </p>

</div>
</div>
<a class="anchor" id="a4fd76cba634d3455bda2f02c1416f241"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<div class="memtemplate">
template&lt;typename Callable , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::schedule </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&#160;</td>
          <td class="paramname"><em>a4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling the given four argument function/functor for execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The given function/functor. </td></tr>
    <tr><td class="paramname">a1</td><td>The first argument. </td></tr>
    <tr><td class="paramname">a2</td><td>The second argument. </td></tr>
    <tr><td class="paramname">a3</td><td>The third argument. </td></tr>
    <tr><td class="paramname">a4</td><td>The fourth argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function schedules the given function/functor for execution. The given function/functor must be copyable, must be callable with four arguments and must return void. </p>

</div>
</div>
<a class="anchor" id="aeee593e98c60a6f810119b5048a53feb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<div class="memtemplate">
template&lt;typename Callable , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::schedule </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&#160;</td>
          <td class="paramname"><em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&#160;</td>
          <td class="paramname"><em>a5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling the given four argument function/functor for execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The given function/functor. </td></tr>
    <tr><td class="paramname">a1</td><td>The first argument. </td></tr>
    <tr><td class="paramname">a2</td><td>The second argument. </td></tr>
    <tr><td class="paramname">a3</td><td>The third argument. </td></tr>
    <tr><td class="paramname">a4</td><td>The fourth argument. </td></tr>
    <tr><td class="paramname">a5</td><td>The fifth argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function schedules the given function/functor for execution. The given function/functor must be copyable, must be callable with five arguments and must return void. </p>

</div>
</div>
<a class="anchor" id="a87ebd2bf56c7a1914686218c303fc4e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current size of the thread pool. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of threads in the thread pool. </dd></dl>

</div>
</div>
<a class="anchor" id="ad975aab73f0d27c5589240bd1a4a70c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waiting for all scheduled tasks to be completed. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>This function blocks until all scheduled tasks have been completed. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a30d2457237fa6fc84b3facc75c2fcf06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TT , typename MT , typename LT , typename CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="../../d9/dcd/classblaze_1_1size__t.html">size_t</a> <a class="el" href="../../db/d38/classblaze_1_1ThreadPool.html">blaze::ThreadPool</a>&lt; TT, MT, LT, CT &gt;::expected_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected number of threads in the thread pool. </p>
<p>This number may differ from the total number of threads during a resize of the thread pool. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>blaze/util/<a class="el" href="../../d0/d80/Thread_8h_source.html">Thread.h</a></li>
<li>blaze/util/<a class="el" href="../../d3/d43/ThreadPool_8h_source.html">ThreadPool.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:55:27 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
