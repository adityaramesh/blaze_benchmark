<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Sparse Subvector</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../../Blaze.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../blaze.jpg"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Sparse Subvector<div class="ingroups"><a class="el" href="../../de/df1/group__math.html">Math module</a> &raquo; <a class="el" href="../../d0/d48/group__views.html">Views</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dc0/classblaze_1_1SparseSubvector_1_1SubvectorElement.html">blaze::SparseSubvector&lt; VT, AF, TF &gt;::SubvectorElement&lt; VectorType, IteratorType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access proxy for a specific element of the sparse subvector.  <a href="../../dc/dc0/classblaze_1_1SparseSubvector_1_1SubvectorElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d6c/classblaze_1_1SparseSubvector_1_1SubvectorIterator.html">blaze::SparseSubvector&lt; VT, AF, TF &gt;::SubvectorIterator&lt; VectorType, IteratorType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the elements of the sparse subvector.  <a href="../../d8/d6c/classblaze_1_1SparseSubvector_1_1SubvectorIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">blaze::SparseSubvector&lt; VT, AF, TF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d4/dae/structblaze_1_1View.html" title="Base class for all views.The View class serves as a tag for all views (subvectors, submatrices, rows, columns, ...). All classes that represent a view and that are used within the expression template environment of the Blaze library have to derive from this class in order to qualify as a view. Only in case a class is derived from the View base class, the IsView type trait recognizes the class as valid view. ">View</a> on a specific subvector of a sparse vector.The <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html" title="View on a specific subvector of a sparse vector.The SparseSubvector template represents a view on a s...">SparseSubvector</a> template represents a view on a specific subvector of a sparse vector primitive. The type of the sparse vector is specified via the first template parameter:  <a href="../../d9/d7b/classblaze_1_1SparseSubvector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gad45404533dd8a1a215df040e42195781"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>useConst</b> = IsConst&lt;VT&gt;::value
 }</td></tr>
<tr class="memdesc:gad45404533dd8a1a215df040e42195781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the non-const reference and iterator types.  <a href="../../d8/de4/group__sparse__subvector.html#gad45404533dd8a1a215df040e42195781">More...</a><br /></td></tr>
<tr class="separator:gad45404533dd8a1a215df040e42195781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee7dd365091b4fdd9dac600afeb5307c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>returnConst</b> = IsConst&lt;VectorType&gt;::value
 }</td></tr>
<tr class="memdesc:gaee7dd365091b4fdd9dac600afeb5307c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the return type of the value member function.  <a href="../../d8/de4/group__sparse__subvector.html#gaee7dd365091b4fdd9dac600afeb5307c">More...</a><br /></td></tr>
<tr class="separator:gaee7dd365091b4fdd9dac600afeb5307c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84786732e35f3664d2ec2ff5cd747a59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga84786732e35f3664d2ec2ff5cd747a59"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>smpAssignable</b> = VT::smpAssignable
 }</td></tr>
<tr class="memdesc:ga84786732e35f3664d2ec2ff5cd747a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compilation switch for the expression template assignment strategy. <br /></td></tr>
<tr class="separator:ga84786732e35f3664d2ec2ff5cd747a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SparseSubvector operators</h2></td></tr>
<tr class="memitem:gac5bda553c46bc4467e634d3cc45909a7"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool AF, bool TF&gt; </td></tr>
<tr class="memitem:gac5bda553c46bc4467e634d3cc45909a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de4/group__sparse__subvector.html#gac5bda553c46bc4467e634d3cc45909a7">blaze::reset</a> (SparseSubvector&lt; VT, AF, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gac5bda553c46bc4467e634d3cc45909a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resetting the given sparse subvector.  <a href="#gac5bda553c46bc4467e634d3cc45909a7">More...</a><br /></td></tr>
<tr class="separator:gac5bda553c46bc4467e634d3cc45909a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecefeea7095ba24dd048f1cc03697d2b"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool AF, bool TF&gt; </td></tr>
<tr class="memitem:gaecefeea7095ba24dd048f1cc03697d2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de4/group__sparse__subvector.html#gaecefeea7095ba24dd048f1cc03697d2b">blaze::clear</a> (SparseSubvector&lt; VT, AF, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:gaecefeea7095ba24dd048f1cc03697d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clearing the given sparse subvector.  <a href="#gaecefeea7095ba24dd048f1cc03697d2b">More...</a><br /></td></tr>
<tr class="separator:gaecefeea7095ba24dd048f1cc03697d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a2a62c8e451e36df5e68b1786f710e7"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool AF, bool TF&gt; </td></tr>
<tr class="memitem:ga6a2a62c8e451e36df5e68b1786f710e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de4/group__sparse__subvector.html#ga6a2a62c8e451e36df5e68b1786f710e7">blaze::isDefault</a> (const SparseSubvector&lt; VT, AF, TF &gt; &amp;sv)</td></tr>
<tr class="memdesc:ga6a2a62c8e451e36df5e68b1786f710e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given sparse subvector is in default state.  <a href="#ga6a2a62c8e451e36df5e68b1786f710e7">More...</a><br /></td></tr>
<tr class="separator:ga6a2a62c8e451e36df5e68b1786f710e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0638d67df7a67d3b86a6a9eb02f8103b"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool AF, bool TF&gt; </td></tr>
<tr class="memitem:ga0638d67df7a67d3b86a6a9eb02f8103b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de4/group__sparse__subvector.html#ga0638d67df7a67d3b86a6a9eb02f8103b">blaze::isSame</a> (const SparseSubvector&lt; VT, AF, TF &gt; &amp;a, const SparseVector&lt; VT, TF &gt; &amp;b)</td></tr>
<tr class="memdesc:ga0638d67df7a67d3b86a6a9eb02f8103b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given sparse vector and subvector represent the same observable state.  <a href="#ga0638d67df7a67d3b86a6a9eb02f8103b">More...</a><br /></td></tr>
<tr class="separator:ga0638d67df7a67d3b86a6a9eb02f8103b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4f2a789c029b2263f3fc5b67930f45"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool AF, bool TF&gt; </td></tr>
<tr class="memitem:gaef4f2a789c029b2263f3fc5b67930f45"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de4/group__sparse__subvector.html#gaef4f2a789c029b2263f3fc5b67930f45">blaze::isSame</a> (const SparseVector&lt; VT, TF &gt; &amp;a, const SparseSubvector&lt; VT, AF, TF &gt; &amp;b)</td></tr>
<tr class="memdesc:gaef4f2a789c029b2263f3fc5b67930f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the given sparse vector and subvector represent the same observable state.  <a href="#gaef4f2a789c029b2263f3fc5b67930f45">More...</a><br /></td></tr>
<tr class="separator:gaef4f2a789c029b2263f3fc5b67930f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89901b47279f6a324b98f0a1506f68a1"><td class="memTemplParams" colspan="2">template&lt;typename VT , bool AF, bool TF&gt; </td></tr>
<tr class="memitem:ga89901b47279f6a324b98f0a1506f68a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de4/group__sparse__subvector.html#ga89901b47279f6a324b98f0a1506f68a1">blaze::isSame</a> (const SparseSubvector&lt; VT, AF, TF &gt; &amp;a, const SparseSubvector&lt; VT, AF, TF &gt; &amp;b)</td></tr>
<tr class="memdesc:ga89901b47279f6a324b98f0a1506f68a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the two given subvectors represent the same observable state.  <a href="#ga89901b47279f6a324b98f0a1506f68a1">More...</a><br /></td></tr>
<tr class="separator:ga89901b47279f6a324b98f0a1506f68a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gad45404533dd8a1a215df040e42195781"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compilation switch for the non-const reference and iterator types. </p>
<p>The <em>useConst</em> compile time constant expression represents a compilation switch for the non-const reference and iterator types. In case the given sparse vector of type <em>VT</em> is const qualified, <em>useConst</em> will be set to 1 and the sparse subvector will return references and iterators to const. Otherwise <em>useConst</em> will be set to 0 and the sparse subvector will offer write access to the sparse vector elements both via the subscript operator and iterators. </p>

</div>
</div>
<a class="anchor" id="gaee7dd365091b4fdd9dac600afeb5307c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT, bool AF = unaligned, bool TF = IsRowVector&lt;VT&gt;::value&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType , typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compilation switch for the return type of the value member function. </p>
<p>The <em>returnConst</em> compile time constant expression represents a compilation switch for the return type of the value member function. In case the given vector type <em>VectorType</em> is const qualified, <em>returnConst</em> will be set to 1 and the value member function will return a reference to const. Otherwise <em>returnConst</em> will be set to 0 and the value member function will offer write access to the sparse vector elements. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaecefeea7095ba24dd048f1cc03697d2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clearing the given sparse subvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse subvector to be cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>Clearing a sparse subvector is equivalent to resetting it via the <a class="el" href="../../d0/d90/group__diagonal__matrix.html#gab1218387fdd76e3eead49086d7fdc5e7" title="Resetting the represented element to the default initial values. ">reset()</a> function. </p>

</div>
</div>
<a class="anchor" id="ga6a2a62c8e451e36df5e68b1786f710e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isDefault </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given sparse subvector is in default state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse subvector to be tested for its default state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the given subvector is component-wise zero, <em>false</em> otherwise.</dd></dl>
<p>This function checks whether the sparse subvector is in default state. For instance, in case the subvector is instantiated for a vector of built-in integral or floating point data type, the function returns <em>true</em> in case all subvector elements are 0 and <em>false</em> in case any element is not 0. The following example demonstrates the use of the <em>isDefault</em> function:</p>
<div class="fragment"><div class="line"><a class="code" href="../../d5/d35/classblaze_1_1CompressedVector.html">blaze::CompressedVector&lt;double,rowVector&gt;</a> v;</div>
<div class="line"><span class="comment">// ... Resizing and initialization</span></div>
<div class="line"><span class="keywordflow">if</span>( <a class="code" href="../../d0/d90/group__diagonal__matrix.html#gaea8a8719fe7a9eea753f71016b8edb57">isDefault</a>( <a class="code" href="../../d0/d48/group__views.html#ga60c61bc1839ff240598ab6688fdb577c">subvector</a>( v, 10UL, 20UL ) ) ) { ... }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga0638d67df7a67d3b86a6a9eb02f8103b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isSame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given sparse vector and subvector represent the same observable state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The sparse subvector to be tested for its state. </td></tr>
    <tr><td class="paramname">b</td><td>The sparse vector to be tested for its state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the sparse subvector and vector share a state, <em>false</em> otherwise.</dd></dl>
<p>This overload of the isSame function tests if the given subvector refers to the entire range of the given sparse vector and by that represents the same observable state. In this case, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="gaef4f2a789c029b2263f3fc5b67930f45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isSame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d31/structblaze_1_1SparseVector.html">SparseVector</a>&lt; VT, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the given sparse vector and subvector represent the same observable state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The sparse vector to be tested for its state. </td></tr>
    <tr><td class="paramname">b</td><td>The sparse subvector to be tested for its state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the sparse vector and subvector share a state, <em>false</em> otherwise.</dd></dl>
<p>This overload of the isSame function tests if the given subvector refers to the entire range of the given sparse vector and by that represents the same observable state. In this case, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="ga89901b47279f6a324b98f0a1506f68a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool blaze::isSame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the two given subvectors represent the same observable state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first sparse subvector to be tested for its state. </td></tr>
    <tr><td class="paramname">b</td><td>The second sparse subvector to be tested for its state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> in case the two subvectors share a state, <em>false</em> otherwise.</dd></dl>
<p>This overload of the isSame function tests if the two given subvectors refer to exactly the same range of the same sparse vector. In case both subvectors represent the same observable state, the function returns <em>true</em>, otherwise it returns <em>false</em>. </p>

</div>
</div>
<a class="anchor" id="gac5bda553c46bc4467e634d3cc45909a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , bool AF, bool TF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void blaze::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d7b/classblaze_1_1SparseSubvector.html">SparseSubvector</a>&lt; VT, AF, TF &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resetting the given sparse subvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>The sparse subvector to be resetted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 04:55:21 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
